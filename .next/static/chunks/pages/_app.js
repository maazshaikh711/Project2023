/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/_app"],{

/***/ "./node_modules/gun/browser.js":
/*!*************************************!*\
  !*** ./node_modules/gun/browser.js ***!
  \*************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./gun.js */ \"./node_modules/gun/gun.js\")//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3VuL2Jyb3dzZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2d1bi9icm93c2VyLmpzPzAyYzIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2d1bi5qcycpIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/gun/browser.js\n"));

/***/ }),

/***/ "./node_modules/gun/gun.js":
/*!*********************************!*\
  !*** ./node_modules/gun/gun.js ***!
  \*********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/* module decorator */ module = __webpack_require__.nmd(module);\n;(function(){\n\n  /* UNBUILD */\n  function USE(arg, req){\n    return req? __webpack_require__(\"./node_modules/gun sync recursive\")(arg) : arg.slice? USE[R(arg)] : function(mod, path){\n      arg(mod = {exports: {}});\n      USE[R(path)] = mod.exports;\n    }\n    function R(p){\n      return p.split('/').slice(-1).toString().replace('.js','');\n    }\n  }\n  if(true){ var MODULE = module }\n  /* UNBUILD */\n\n\t;USE(function(module){\n\t\t// Shim for generic javascript utilities.\n\t\tString.random = function(l, c){\n\t\t\tvar s = '';\n\t\t\tl = l || 24; // you are not going to make a 0 length random number, so no need to check type\n\t\t\tc = c || '0123456789ABCDEFGHIJKLMNOPQRSTUVWXZabcdefghijklmnopqrstuvwxyz';\n\t\t\twhile(l-- > 0){ s += c.charAt(Math.floor(Math.random() * c.length)) }\n\t\t\treturn s;\n\t\t}\n\t\tString.match = function(t, o){ var tmp, u;\n\t\t\tif('string' !== typeof t){ return false }\n\t\t\tif('string' == typeof o){ o = {'=': o} }\n\t\t\to = o || {};\n\t\t\ttmp = (o['='] || o['*'] || o['>'] || o['<']);\n\t\t\tif(t === tmp){ return true }\n\t\t\tif(u !== o['=']){ return false }\n\t\t\ttmp = (o['*'] || o['>']);\n\t\t\tif(t.slice(0, (tmp||'').length) === tmp){ return true }\n\t\t\tif(u !== o['*']){ return false }\n\t\t\tif(u !== o['>'] && u !== o['<']){\n\t\t\t\treturn (t >= o['>'] && t <= o['<'])? true : false;\n\t\t\t}\n\t\t\tif(u !== o['>'] && t >= o['>']){ return true }\n\t\t\tif(u !== o['<'] && t <= o['<']){ return true }\n\t\t\treturn false;\n\t\t}\n\t\tString.hash = function(s, c){ // via SO\n\t\t\tif(typeof s !== 'string'){ return }\n\t    c = c || 0; // CPU schedule hashing by\n\t    if(!s.length){ return c }\n\t    for(var i=0,l=s.length,n; i<l; ++i){\n\t      n = s.charCodeAt(i);\n\t      c = ((c<<5)-c)+n;\n\t      c |= 0;\n\t    }\n\t    return c;\n\t  }\n\t\tvar has = Object.prototype.hasOwnProperty;\n\t\tObject.plain = function(o){ return o? (o instanceof Object && o.constructor === Object) || Object.prototype.toString.call(o).match(/^\\[object (\\w+)\\]$/)[1] === 'Object' : false }\n\t\tObject.empty = function(o, n){\n\t\t\tfor(var k in o){ if(has.call(o, k) && (!n || -1==n.indexOf(k))){ return false } }\n\t\t\treturn true;\n\t\t}\n\t\tObject.keys = Object.keys || function(o){\n\t\t\tvar l = [];\n\t\t\tfor(var k in o){ if(has.call(o, k)){ l.push(k) } }\n\t\t\treturn l;\n\t\t}\n\t\t;(function(){ // max ~1ms or before stack overflow \n\t\t\tvar u, sT = setTimeout, l = 0, c = 0, sI = (typeof setImmediate !== ''+u && setImmediate) || sT; // queueMicrotask faster but blocks UI\n\t\t\tsT.hold = sT.hold || 9;\n\t\t\tsT.poll = sT.poll || function(f){ //f(); return; // for testing\n\t\t\t\tif((sT.hold >= (+new Date - l)) && c++ < 3333){ f(); return }\n\t\t\t\tsI(function(){ l = +new Date; f() },c=0)\n\t\t\t}\n\t\t}());\n\t\t;(function(){ // Too many polls block, this \"threads\" them in turns over a single thread in time.\n\t\t\tvar sT = setTimeout, t = sT.turn = sT.turn || function(f){ 1 == s.push(f) && p(T) }\n\t\t\t, s = t.s = [], p = sT.poll, i = 0, f, T = function(){\n\t\t\t\tif(f = s[i++]){ f() }\n\t\t\t\tif(i == s.length || 99 == i){\n\t\t\t\t\ts = t.s = s.slice(i);\n\t\t\t\t\ti = 0;\n\t\t\t\t}\n\t\t\t\tif(s.length){ p(T) }\n\t\t\t}\n\t\t}());\n\t\t;(function(){\n\t\t\tvar u, sT = setTimeout, T = sT.turn;\n\t\t\t(sT.each = sT.each || function(l,f,e,S){ S = S || 9; (function t(s,L,r){\n\t\t\t  if(L = (s = (l||[]).splice(0,S)).length){\n\t\t\t  \tfor(var i = 0; i < L; i++){\n\t\t\t  \t\tif(u !== (r = f(s[i]))){ break }\n\t\t\t  \t}\n\t\t\t  \tif(u === r){ T(t); return }\n\t\t\t  } e && e(r);\n\t\t\t}())})();\n\t\t}());\n\t})(USE, './shim');\n\n\t;USE(function(module){\n\t\t// On event emitter generic javascript utility.\n\t\tmodule.exports = function onto(tag, arg, as){\n\t\t\tif(!tag){ return {to: onto} }\n\t\t\tvar u, f = 'function' == typeof arg, tag = (this.tag || (this.tag = {}))[tag] || f && (\n\t\t\t\tthis.tag[tag] = {tag: tag, to: onto._ = { next: function(arg){ var tmp;\n\t\t\t\t\tif(tmp = this.to){ tmp.next(arg) }\n\t\t\t}}});\n\t\t\tif(f){\n\t\t\t\tvar be = {\n\t\t\t\t\toff: onto.off ||\n\t\t\t\t\t(onto.off = function(){\n\t\t\t\t\t\tif(this.next === onto._.next){ return !0 }\n\t\t\t\t\t\tif(this === this.the.last){\n\t\t\t\t\t\t\tthis.the.last = this.back;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.to.back = this.back;\n\t\t\t\t\t\tthis.next = onto._.next;\n\t\t\t\t\t\tthis.back.to = this.to;\n\t\t\t\t\t\tif(this.the.last === this.the){\n\t\t\t\t\t\t\tdelete this.on.tag[this.the.tag];\n\t\t\t\t\t\t}\n\t\t\t\t\t}),\n\t\t\t\t\tto: onto._,\n\t\t\t\t\tnext: arg,\n\t\t\t\t\tthe: tag,\n\t\t\t\t\ton: this,\n\t\t\t\t\tas: as,\n\t\t\t\t};\n\t\t\t\t(be.back = tag.last || tag).to = be;\n\t\t\t\treturn tag.last = be;\n\t\t\t}\n\t\t\tif((tag = tag.to) && u !== arg){ tag.next(arg) }\n\t\t\treturn tag;\n\t\t};\n\t})(USE, './onto');\n\n\t;USE(function(module){\n\t\t// Valid values are a subset of JSON: null, binary, number (!Infinity), text,\n\t\t// or a soul relation. Arrays need special algorithms to handle concurrency,\n\t\t// so they are not supported directly. Use an extension that supports them if\n\t\t// needed but research their problems first.\n\t\tmodule.exports = function (v) {\n\t\t  // \"deletes\", nulling out keys.\n\t\t  return v === null ||\n\t\t\t\"string\" === typeof v ||\n\t\t\t\"boolean\" === typeof v ||\n\t\t\t// we want +/- Infinity to be, but JSON does not support it, sad face.\n\t\t\t// can you guess what v === v checks for? ;)\n\t\t\t(\"number\" === typeof v && v != Infinity && v != -Infinity && v === v) ||\n\t\t\t(!!v && \"string\" == typeof v[\"#\"] && Object.keys(v).length === 1 && v[\"#\"]);\n\t\t}\n\t})(USE, './valid');\n\n\t;USE(function(module){\n\t\tUSE('./shim');\n\t\tfunction State(){\n\t\t\tvar t = +new Date;\n\t\t\tif(last < t){\n\t\t\t\treturn N = 0, last = t + State.drift;\n\t\t\t}\n\t\t\treturn last = t + ((N += 1) / D) + State.drift;\n\t\t}\n\t\tState.drift = 0;\n\t\tvar NI = -Infinity, N = 0, D = 999, last = NI, u; // WARNING! In the future, on machines that are D times faster than 2016AD machines, you will want to increase D by another several orders of magnitude so the processing speed never out paces the decimal resolution (increasing an integer effects the state accuracy).\n\t\tState.is = function(n, k, o){ // convenience function to get the state on a key on a node and return it.\n\t\t\tvar tmp = (k && n && n._ && n._['>']) || o;\n\t\t\tif(!tmp){ return }\n\t\t\treturn ('number' == typeof (tmp = tmp[k]))? tmp : NI;\n\t\t}\n\t\tState.ify = function(n, k, s, v, soul){ // put a key's state on a node.\n\t\t\t(n = n || {})._ = n._ || {}; // safety check or init.\n\t\t\tif(soul){ n._['#'] = soul } // set a soul if specified.\n\t\t\tvar tmp = n._['>'] || (n._['>'] = {}); // grab the states data.\n\t\t\tif(u !== k && k !== '_'){\n\t\t\t\tif('number' == typeof s){ tmp[k] = s } // add the valid state.\n\t\t\t\tif(u !== v){ n[k] = v } // Note: Not its job to check for valid values!\n\t\t\t}\n\t\t\treturn n;\n\t\t}\n\t\tmodule.exports = State;\n\t})(USE, './state');\n\n\t;USE(function(module){\n\t\tUSE('./shim');\n\t\tfunction Dup(opt){\n\t\t\tvar dup = {s:{}}, s = dup.s;\n\t\t\topt = opt || {max: 999, age: 1000 * 9};//*/ 1000 * 9 * 3};\n\t\t\tdup.check = function(id){\n\t\t\t\tif(!s[id]){ return false }\n\t\t\t\treturn dt(id);\n\t\t\t}\n\t\t\tvar dt = dup.track = function(id){\n\t\t\t\tvar it = s[id] || (s[id] = {});\n\t\t\t\tit.was = dup.now = +new Date;\n\t\t\t\tif(!dup.to){ dup.to = setTimeout(dup.drop, opt.age + 9) }\n\t\t\t\treturn it;\n\t\t\t}\n\t\t\tdup.drop = function(age){\n\t\t\t\tdup.to = null;\n\t\t\t\tdup.now = +new Date;\n\t\t\t\tvar l = Object.keys(s);\n\t\t\t\tconsole.STAT && console.STAT(dup.now, +new Date - dup.now, 'dup drop keys'); // prev ~20% CPU 7% RAM 300MB // now ~25% CPU 7% RAM 500MB\n\t\t\t\tsetTimeout.each(l, function(id){ var it = s[id]; // TODO: .keys( is slow?\n\t\t\t\t\tif(it && (age || opt.age) > (dup.now - it.was)){ return }\n\t\t\t\t\tdelete s[id];\n\t\t\t\t},0,99);\n\t\t\t}\n\t\t\treturn dup;\n\t\t}\n\t\tmodule.exports = Dup;\n\t})(USE, './dup');\n\n\t;USE(function(module){\n\t\t// request / response module, for asking and acking messages.\n\t\tUSE('./onto'); // depends upon onto!\n\t\tmodule.exports = function ask(cb, as){\n\t\t\tif(!this.on){ return }\n\t\t\tvar lack = (this.opt||{}).lack || 9000;\n\t\t\tif(!('function' == typeof cb)){\n\t\t\t\tif(!cb){ return }\n\t\t\t\tvar id = cb['#'] || cb, tmp = (this.tag||'')[id];\n\t\t\t\tif(!tmp){ return }\n\t\t\t\tif(as){\n\t\t\t\t\ttmp = this.on(id, as);\n\t\t\t\t\tclearTimeout(tmp.err);\n\t\t\t\t\ttmp.err = setTimeout(function(){ tmp.off() }, lack);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tvar id = (as && as['#']) || random(9);\n\t\t\tif(!cb){ return id }\n\t\t\tvar to = this.on(id, cb, as);\n\t\t\tto.err = to.err || setTimeout(function(){ to.off();\n\t\t\t\tto.next({err: \"Error: No ACK yet.\", lack: true});\n\t\t\t}, lack);\n\t\t\treturn id;\n\t\t}\n\t\tvar random = String.random || function(){ return Math.random().toString(36).slice(2) }\n\t})(USE, './ask');\n\n\t;USE(function(module){\n\n\t\tfunction Gun(o){\n\t\t\tif(o instanceof Gun){ return (this._ = {$: this}).$ }\n\t\t\tif(!(this instanceof Gun)){ return new Gun(o) }\n\t\t\treturn Gun.create(this._ = {$: this, opt: o});\n\t\t}\n\n\t\tGun.is = function($){ return ($ instanceof Gun) || ($ && $._ && ($ === $._.$)) || false }\n\n\t\tGun.version = 0.2020;\n\n\t\tGun.chain = Gun.prototype;\n\t\tGun.chain.toJSON = function(){};\n\n\t\tUSE('./shim');\n\t\tGun.valid = USE('./valid');\n\t\tGun.state = USE('./state');\n\t\tGun.on = USE('./onto');\n\t\tGun.dup = USE('./dup');\n\t\tGun.ask = USE('./ask');\n\n\t\t;(function(){\n\t\t\tGun.create = function(at){\n\t\t\t\tat.root = at.root || at;\n\t\t\t\tat.graph = at.graph || {};\n\t\t\t\tat.on = at.on || Gun.on;\n\t\t\t\tat.ask = at.ask || Gun.ask;\n\t\t\t\tat.dup = at.dup || Gun.dup();\n\t\t\t\tvar gun = at.$.opt(at.opt);\n\t\t\t\tif(!at.once){\n\t\t\t\t\tat.on('in', universe, at);\n\t\t\t\t\tat.on('out', universe, at);\n\t\t\t\t\tat.on('put', map, at);\n\t\t\t\t\tGun.on('create', at);\n\t\t\t\t\tat.on('create', at);\n\t\t\t\t}\n\t\t\t\tat.once = 1;\n\t\t\t\treturn gun;\n\t\t\t}\n\t\t\tfunction universe(msg){\n\t\t\t\t// TODO: BUG! msg.out = null being set!\n\t\t\t\t//if(!F){ var eve = this; setTimeout(function(){ universe.call(eve, msg,1) },Math.random() * 100);return; } // ADD F TO PARAMS!\n\t\t\t\tif(!msg){ return }\n\t\t\t\tif(msg.out === universe){ this.to.next(msg); return }\n\t\t\t\tvar eve = this, as = eve.as, at = as.at || as, gun = at.$, dup = at.dup, tmp, DBG = msg.DBG;\n\t\t\t\t(tmp = msg['#']) || (tmp = msg['#'] = text_rand(9));\n\t\t\t\tif(dup.check(tmp)){ return } dup.track(tmp);\n\t\t\t\ttmp = msg._; msg._ = ('function' == typeof tmp)? tmp : function(){};\n\t\t\t\t(msg.$ && (msg.$ === (msg.$._||'').$)) || (msg.$ = gun);\n\t\t\t\tif(msg['@'] && !msg.put){ ack(msg) }\n\t\t\t\tif(!at.ask(msg['@'], msg)){ // is this machine listening for an ack?\n\t\t\t\t\tDBG && (DBG.u = +new Date);\n\t\t\t\t\tif(msg.put){ put(msg); return } else\n\t\t\t\t\tif(msg.get){ Gun.on.get(msg, gun) }\n\t\t\t\t}\n\t\t\t\tDBG && (DBG.uc = +new Date);\n\t\t\t\teve.to.next(msg);\n\t\t\t\tDBG && (DBG.ua = +new Date);\n\t\t\t\tif(msg.nts || msg.NTS){ return } // TODO: This shouldn't be in core, but fast way to prevent NTS spread. Delete this line after all peers have upgraded to newer versions.\n\t\t\t\tmsg.out = universe; at.on('out', msg);\n\t\t\t\tDBG && (DBG.ue = +new Date);\n\t\t\t}\n\t\t\tfunction put(msg){\n\t\t\t\tif(!msg){ return }\n\t\t\t\tvar ctx = msg._||'', root = ctx.root = ((ctx.$ = msg.$||'')._||'').root;\n\t\t\t\tif(msg['@'] && ctx.faith && !ctx.miss){ // TODO: AXE may split/route based on 'put' what should we do here? Detect @ in AXE? I think we don't have to worry, as DAM will route it on @.\n\t\t\t\t\tmsg.out = universe;\n\t\t\t\t\troot.on('out', msg);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tctx.latch = root.hatch; ctx.match = root.hatch = [];\n\t\t\t\tvar put = msg.put;\n\t\t\t\tvar DBG = ctx.DBG = msg.DBG, S = +new Date; CT = CT || S;\n\t\t\t\tif(put['#'] && put['.']){ /*root && root.on('put', msg);*/ return } // TODO: BUG! This needs to call HAM instead.\n\t\t\t\tDBG && (DBG.p = S);\n\t\t\t\tctx['#'] = msg['#'];\n\t\t\t\tctx.msg = msg;\n\t\t\t\tctx.all = 0;\n\t\t\t\tctx.stun = 1;\n\t\t\t\tvar nl = Object.keys(put);//.sort(); // TODO: This is unbounded operation, large graphs will be slower. Write our own CPU scheduled sort? Or somehow do it in below? Keys itself is not O(1) either, create ES5 shim over ?weak map? or custom which is constant.\n\t\t\t\tconsole.STAT && console.STAT(S, ((DBG||ctx).pk = +new Date) - S, 'put sort');\n\t\t\t\tvar ni = 0, nj, kl, soul, node, states, err, tmp;\n\t\t\t\t(function pop(o){\n\t\t\t\t\tif(nj != ni){ nj = ni;\n\t\t\t\t\t\tif(!(soul = nl[ni])){\n\t\t\t\t\t\t\tconsole.STAT && console.STAT(S, ((DBG||ctx).pd = +new Date) - S, 'put');\n\t\t\t\t\t\t\tfire(ctx);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!(node = put[soul])){ err = ERR+cut(soul)+\"no node.\" } else\n\t\t\t\t\t\tif(!(tmp = node._)){ err = ERR+cut(soul)+\"no meta.\" } else\n\t\t\t\t\t\tif(soul !== tmp['#']){ err = ERR+cut(soul)+\"soul not same.\" } else\n\t\t\t\t\t\tif(!(states = tmp['>'])){ err = ERR+cut(soul)+\"no state.\" }\n\t\t\t\t\t\tkl = Object.keys(node||{}); // TODO: .keys( is slow\n\t\t\t\t\t}\n\t\t\t\t\tif(err){\n\t\t\t\t\t\tmsg.err = ctx.err = err; // invalid data should error and stun the message.\n\t\t\t\t\t\tfire(ctx);\n\t\t\t\t\t\t//console.log(\"handle error!\", err) // handle!\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tvar i = 0, key; o = o || 0;\n\t\t\t\t\twhile(o++ < 9 && (key = kl[i++])){\n\t\t\t\t\t\tif('_' === key){ continue }\n\t\t\t\t\t\tvar val = node[key], state = states[key];\n\t\t\t\t\t\tif(u === state){ err = ERR+cut(key)+\"on\"+cut(soul)+\"no state.\"; break }\n\t\t\t\t\t\tif(!valid(val)){ err = ERR+cut(key)+\"on\"+cut(soul)+\"bad \"+(typeof val)+cut(val); break }\n\t\t\t\t\t\t//ctx.all++; //ctx.ack[soul+key] = '';\n\t\t\t\t\t\tham(val, key, soul, state, msg);\n\t\t\t\t\t\t++C; // courtesy count;\n\t\t\t\t\t}\n\t\t\t\t\tif((kl = kl.slice(i)).length){ turn(pop); return }\n\t\t\t\t\t++ni; kl = null; pop(o);\n\t\t\t\t}());\n\t\t\t} Gun.on.put = put;\n\t\t\t// TODO: MARK!!! clock below, reconnect sync, SEA certify wire merge, User.auth taking multiple times, // msg put, put, say ack, hear loop...\n\t\t\t// WASIS BUG! local peer not ack. .off other people: .open\n\t\t\tfunction ham(val, key, soul, state, msg){\n\t\t\t\tvar ctx = msg._||'', root = ctx.root, graph = root.graph, lot, tmp;\n\t\t\t\tvar vertex = graph[soul] || empty, was = state_is(vertex, key, 1), known = vertex[key];\n\t\t\t\t\n\t\t\t\tvar DBG = ctx.DBG; if(tmp = console.STAT){ if(!graph[soul] || !known){ tmp.has = (tmp.has || 0) + 1 } }\n\n\t\t\t\tvar now = State(), u;\n\t\t\t\tif(state > now){\n\t\t\t\t\tsetTimeout(function(){ ham(val, key, soul, state, msg) }, (tmp = state - now) > MD? MD : tmp); // Max Defer 32bit. :(\n\t\t\t\t\tconsole.STAT && console.STAT(((DBG||ctx).Hf = +new Date), tmp, 'future');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(state < was){ /*old;*/ if(!ctx.miss){ return } } // but some chains have a cache miss that need to re-fire. // TODO: Improve in future. // for AXE this would reduce rebroadcast, but GUN does it on message forwarding.\n\t\t\t\tif(!ctx.faith){ // TODO: BUG? Can this be used for cache miss as well? // Yes this was a bug, need to check cache miss for RAD tests, but should we care about the faith check now? Probably not.\n\t\t\t\t\tif(state === was && (val === known || L(val) <= L(known))){ /*console.log(\"same\");*/ /*same;*/ if(!ctx.miss){ return } } // same\n\t\t\t\t}\n\t\t\t\tctx.stun++; // TODO: 'forget' feature in SEA tied to this, bad approach, but hacked in for now. Any changes here must update there.\n\t\t\t\tvar aid = msg['#']+ctx.all++, id = {toString: function(){ return aid }, _: ctx}; id.toJSON = id.toString; // this *trick* makes it compatible between old & new versions.\n\t\t\t\tDBG && (DBG.ph = DBG.ph || +new Date);\n\t\t\t\troot.on('put', {'#': id, '@': msg['@'], put: {'#': soul, '.': key, ':': val, '>': state}, _: ctx});\n\t\t\t}\n\t\t\tfunction map(msg){\n\t\t\t\tvar DBG; if(DBG = (msg._||'').DBG){ DBG.pa = +new Date; DBG.pm = DBG.pm || +new Date}\n      \tvar eve = this, root = eve.as, graph = root.graph, ctx = msg._, put = msg.put, soul = put['#'], key = put['.'], val = put[':'], state = put['>'], id = msg['#'], tmp;\n      \tif((tmp = ctx.msg) && (tmp = tmp.put) && (tmp = tmp[soul])){ state_ify(tmp, key, state, val, soul) } // necessary! or else out messages do not get SEA transforms.\n\t\t\t\tgraph[soul] = state_ify(graph[soul], key, state, val, soul);\n\t\t\t\tif(tmp = (root.next||'')[soul]){ tmp.on('in', msg) }\n\t\t\t\tfire(ctx);\n\t\t\t\teve.to.next(msg);\n\t\t\t}\n\t\t\tfunction fire(ctx, msg){ var root;\n\t\t\t\tif(ctx.stop){ return }\n\t\t\t\tif(!ctx.err && 0 < --ctx.stun){ return } // TODO: 'forget' feature in SEA tied to this, bad approach, but hacked in for now. Any changes here must update there.\n\t\t\t\tctx.stop = 1;\n\t\t\t\tif(!(root = ctx.root)){ return }\n\t\t\t\tvar tmp = ctx.match; tmp.end = 1;\n\t\t\t\tif(tmp === root.hatch){ if(!(tmp = ctx.latch) || tmp.end){ delete root.hatch } else { root.hatch = tmp } }\n\t\t\t\tctx.hatch && ctx.hatch(); // TODO: rename/rework how put & this interact.\n\t\t\t\tsetTimeout.each(ctx.match, function(cb){cb && cb()}); \n\t\t\t\tif(!(msg = ctx.msg) || ctx.err || msg.err){ return }\n\t\t\t\tmsg.out = universe;\n\t\t\t\tctx.root.on('out', msg);\n\n\t\t\t\tCF(); // courtesy check;\n\t\t\t}\n\t\t\tfunction ack(msg){ // aggregate ACKs.\n\t\t\t\tvar id = msg['@'] || '', ctx;\n\t\t\t\tif(!(ctx = id._)){ return }\n\t\t\t\tctx.acks = (ctx.acks||0) + 1;\n\t\t\t\tif(ctx.err = msg.err){\n\t\t\t\t\tmsg['@'] = ctx['#'];\n\t\t\t\t\tfire(ctx); // TODO: BUG? How it skips/stops propagation of msg if any 1 item is error, this would assume a whole batch/resync has same malicious intent.\n\t\t\t\t}\n\t\t\t\tif(!ctx.stop && !ctx.crack){ ctx.crack = ctx.match && ctx.match.push(function(){back(ctx)}) } // handle synchronous acks\n\t\t\t\tback(ctx);\n\t\t\t}\n\t\t\tfunction back(ctx){\n\t\t\t\tif(!ctx || !ctx.root){ return }\n\t\t\t\tif(ctx.stun || ctx.acks !== ctx.all){ return }\n\t\t\t\tctx.root.on('in', {'@': ctx['#'], err: ctx.err, ok: ctx.err? u : {'':1}});\n\t\t\t}\n\n\t\t\tvar ERR = \"Error: Invalid graph!\";\n\t\t\tvar cut = function(s){ return \" '\"+(''+s).slice(0,9)+\"...' \" }\n\t\t\tvar L = JSON.stringify, MD = 2147483647, State = Gun.state;\n\t\t\tvar C = 0, CT, CF = function(){if(C>999 && (C/-(CT - (CT = +new Date))>1)){Gun.window && console.log(\"Warning: You're syncing 1K+ records a second, faster than DOM can update - consider limiting query.\");CF=function(){C=0}}};\n\n\t\t}());\n\n\t\t;(function(){\n\t\t\tGun.on.get = function(msg, gun){\n\t\t\t\tvar root = gun._, get = msg.get, soul = get['#'], node = root.graph[soul], has = get['.'];\n\t\t\t\tvar next = root.next || (root.next = {}), at = next[soul];\n\t\t\t\t// queue concurrent GETs?\n\t\t\t\t// TODO: consider tagging original message into dup for DAM.\n\t\t\t\t// TODO: ^ above? In chat app, 12 messages resulted in same peer asking for `#user.pub` 12 times. (same with #user GET too, yipes!) // DAM note: This also resulted in 12 replies from 1 peer which all had same ##hash but none of them deduped because each get was different.\n\t\t\t\t// TODO: Moving quick hacks fixing these things to axe for now.\n\t\t\t\t// TODO: a lot of GET #foo then GET #foo.\"\" happening, why?\n\t\t\t\t// TODO: DAM's ## hash check, on same get ACK, producing multiple replies still, maybe JSON vs YSON?\n\t\t\t\t// TMP note for now: viMZq1slG was chat LEX query #.\n\t\t\t\t/*if(gun !== (tmp = msg.$) && (tmp = (tmp||'')._)){\n\t\t\t\t\tif(tmp.Q){ tmp.Q[msg['#']] = ''; return } // chain does not need to ask for it again.\n\t\t\t\t\ttmp.Q = {};\n\t\t\t\t}*/\n\t\t\t\t/*if(u === has){\n\t\t\t\t\tif(at.Q){\n\t\t\t\t\t\t//at.Q[msg['#']] = '';\n\t\t\t\t\t\t//return;\n\t\t\t\t\t}\n\t\t\t\t\tat.Q = {};\n\t\t\t\t}*/\n\t\t\t\tvar ctx = msg._||{}, DBG = ctx.DBG = msg.DBG;\n\t\t\t\tDBG && (DBG.g = +new Date);\n\t\t\t\t//console.log(\"GET:\", get, node, has);\n\t\t\t\tif(!node){ return root.on('get', msg) }\n\t\t\t\tif(has){\n\t\t\t\t\tif('string' != typeof has || u === node[has]){ return root.on('get', msg) }\n\t\t\t\t\tnode = state_ify({}, has, state_is(node, has), node[has], soul);\n\t\t\t\t\t// If we have a key in-memory, do we really need to fetch?\n\t\t\t\t\t// Maybe... in case the in-memory key we have is a local write\n\t\t\t\t\t// we still need to trigger a pull/merge from peers.\n\t\t\t\t}\n\t\t\t\t//Gun.window? Gun.obj.copy(node) : node; // HNPERF: If !browser bump Performance? Is this too dangerous to reference root graph? Copy / shallow copy too expensive for big nodes. Gun.obj.to(node); // 1 layer deep copy // Gun.obj.copy(node); // too slow on big nodes\n\t\t\t\tnode && ack(msg, node);\n\t\t\t\troot.on('get', msg); // send GET to storage adapters.\n\t\t\t}\n\t\t\tfunction ack(msg, node){\n\t\t\t\tvar S = +new Date, ctx = msg._||{}, DBG = ctx.DBG = msg.DBG;\n\t\t\t\tvar to = msg['#'], id = text_rand(9), keys = Object.keys(node||'').sort(), soul = ((node||'')._||'')['#'], kl = keys.length, j = 0, root = msg.$._.root, F = (node === root.graph[soul]);\n\t\t\t\tconsole.STAT && console.STAT(S, ((DBG||ctx).gk = +new Date) - S, 'got keys');\n\t\t\t\t// PERF: Consider commenting this out to force disk-only reads for perf testing? // TODO: .keys( is slow\n\t\t\t\tnode && (function go(){\n\t\t\t\t\tS = +new Date;\n\t\t\t\t\tvar i = 0, k, put = {}, tmp;\n\t\t\t\t\twhile(i < 9 && (k = keys[i++])){\n\t\t\t\t\t\tstate_ify(put, k, state_is(node, k), node[k], soul);\n\t\t\t\t\t}\n\t\t\t\t\tkeys = keys.slice(i);\n\t\t\t\t\t(tmp = {})[soul] = put; put = tmp;\n\t\t\t\t\tvar faith; if(F){ faith = function(){}; faith.ram = faith.faith = true; } // HNPERF: We're testing performance improvement by skipping going through security again, but this should be audited.\n\t\t\t\t\ttmp = keys.length;\n\t\t\t\t\tconsole.STAT && console.STAT(S, -(S - (S = +new Date)), 'got copied some');\n\t\t\t\t\tDBG && (DBG.ga = +new Date);\n\t\t\t\t\troot.on('in', {'@': to, '#': id, put: put, '%': (tmp? (id = text_rand(9)) : u), $: root.$, _: faith, DBG: DBG});\n\t\t\t\t\tconsole.STAT && console.STAT(S, +new Date - S, 'got in');\n\t\t\t\t\tif(!tmp){ return }\n\t\t\t\t\tsetTimeout.turn(go);\n\t\t\t\t}());\n\t\t\t\tif(!node){ root.on('in', {'@': msg['#']}) } // TODO: I don't think I like this, the default lS adapter uses this but \"not found\" is a sensitive issue, so should probably be handled more carefully/individually.\n\t\t\t} Gun.on.get.ack = ack;\n\t\t}());\n\n\t\t;(function(){\n\t\t\tGun.chain.opt = function(opt){\n\t\t\t\topt = opt || {};\n\t\t\t\tvar gun = this, at = gun._, tmp = opt.peers || opt;\n\t\t\t\tif(!Object.plain(opt)){ opt = {} }\n\t\t\t\tif(!Object.plain(at.opt)){ at.opt = opt }\n\t\t\t\tif('string' == typeof tmp){ tmp = [tmp] }\n\t\t\t\tif(!Object.plain(at.opt.peers)){ at.opt.peers = {}}\n\t\t\t\tif(tmp instanceof Array){\n\t\t\t\t\topt.peers = {};\n\t\t\t\t\ttmp.forEach(function(url){\n\t\t\t\t\t\tvar p = {}; p.id = p.url = url;\n\t\t\t\t\t\topt.peers[url] = at.opt.peers[url] = at.opt.peers[url] || p;\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\tobj_each(opt, function each(k){ var v = this[k];\n\t\t\t\t\tif((this && this.hasOwnProperty(k)) || 'string' == typeof v || Object.empty(v)){ this[k] = v; return }\n\t\t\t\t\tif(v && v.constructor !== Object && !(v instanceof Array)){ return }\n\t\t\t\t\tobj_each(v, each);\n\t\t\t\t});\n\t\t\t\tat.opt.from = opt;\n\t\t\t\tGun.on('opt', at);\n\t\t\t\tat.opt.uuid = at.opt.uuid || function uuid(l){ return Gun.state().toString(36).replace('.','') + String.random(l||12) }\n\t\t\t\treturn gun;\n\t\t\t}\n\t\t}());\n\n\t\tvar obj_each = function(o,f){ Object.keys(o).forEach(f,o) }, text_rand = String.random, turn = setTimeout.turn, valid = Gun.valid, state_is = Gun.state.is, state_ify = Gun.state.ify, u, empty = {}, C;\n\n\t\tGun.log = function(){ return (!Gun.log.off && C.log.apply(C, arguments)), [].slice.call(arguments).join(' ') };\n\t\tGun.log.once = function(w,s,o){ return (o = Gun.log.once)[w] = o[w] || 0, o[w]++ || Gun.log(s) };\n\n\t\tif(typeof window !== \"undefined\"){ (window.GUN = window.Gun = Gun).window = window }\n\t\ttry{ if(typeof MODULE !== \"undefined\"){ MODULE.exports = Gun } }catch(e){}\n\t\tmodule.exports = Gun;\n\t\t\n\t\t(Gun.window||{}).console = (Gun.window||{}).console || {log: function(){}};\n\t\t(C = console).only = function(i, s){ return (C.only.i && i === C.only.i && C.only.i++) && (C.log.apply(C, arguments) || s) };\n\n\t\t;\"Please do not remove welcome log unless you are paying for a monthly sponsorship, thanks!\";\n\t\tGun.log.once(\"welcome\", \"Hello wonderful person! :) Thanks for using GUN, please ask for help on http://chat.gun.eco if anything takes you longer than 5min to figure out!\");\n\t})(USE, './root');\n\n\t;USE(function(module){\n\t\tvar Gun = USE('./root');\n\t\tGun.chain.back = function(n, opt){ var tmp;\n\t\t\tn = n || 1;\n\t\t\tif(-1 === n || Infinity === n){\n\t\t\t\treturn this._.root.$;\n\t\t\t} else\n\t\t\tif(1 === n){\n\t\t\t\treturn (this._.back || this._).$;\n\t\t\t}\n\t\t\tvar gun = this, at = gun._;\n\t\t\tif(typeof n === 'string'){\n\t\t\t\tn = n.split('.');\n\t\t\t}\n\t\t\tif(n instanceof Array){\n\t\t\t\tvar i = 0, l = n.length, tmp = at;\n\t\t\t\tfor(i; i < l; i++){\n\t\t\t\t\ttmp = (tmp||empty)[n[i]];\n\t\t\t\t}\n\t\t\t\tif(u !== tmp){\n\t\t\t\t\treturn opt? gun : tmp;\n\t\t\t\t} else\n\t\t\t\tif((tmp = at.back)){\n\t\t\t\t\treturn tmp.$.back(n, opt);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif('function' == typeof n){\n\t\t\t\tvar yes, tmp = {back: at};\n\t\t\t\twhile((tmp = tmp.back)\n\t\t\t\t&& u === (yes = n(tmp, opt))){}\n\t\t\t\treturn yes;\n\t\t\t}\n\t\t\tif('number' == typeof n){\n\t\t\t\treturn (at.back || at).$.back(n - 1);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tvar empty = {}, u;\n\t})(USE, './back');\n\n\t;USE(function(module){\n\t\t// WARNING: GUN is very simple, but the JavaScript chaining API around GUN\n\t\t// is complicated and was extremely hard to build. If you port GUN to another\n\t\t// language, consider implementing an easier API to build.\n\t\tvar Gun = USE('./root');\n\t\tGun.chain.chain = function(sub){\n\t\t\tvar gun = this, at = gun._, chain = new (sub || gun).constructor(gun), cat = chain._, root;\n\t\t\tcat.root = root = at.root;\n\t\t\tcat.id = ++root.once;\n\t\t\tcat.back = gun._;\n\t\t\tcat.on = Gun.on;\n\t\t\tcat.on('in', Gun.on.in, cat); // For 'in' if I add my own listeners to each then I MUST do it before in gets called. If I listen globally for all incoming data instead though, regardless of individual listeners, I can transform the data there and then as well.\n\t\t\tcat.on('out', Gun.on.out, cat); // However for output, there isn't really the global option. I must listen by adding my own listener individually BEFORE this one is ever called.\n\t\t\treturn chain;\n\t\t}\n\n\t\tfunction output(msg){\n\t\t\tvar put, get, at = this.as, back = at.back, root = at.root, tmp;\n\t\t\tif(!msg.$){ msg.$ = at.$ }\n\t\t\tthis.to.next(msg);\n\t\t\tif(at.err){ at.on('in', {put: at.put = u, $: at.$}); return }\n\t\t\tif(get = msg.get){\n\t\t\t\t/*if(u !== at.put){\n\t\t\t\t\tat.on('in', at);\n\t\t\t\t\treturn;\n\t\t\t\t}*/\n\t\t\t\tif(root.pass){ root.pass[at.id] = at; } // will this make for buggy behavior elsewhere?\n\t\t\t\tif(at.lex){ Object.keys(at.lex).forEach(function(k){ tmp[k] = at.lex[k] }, tmp = msg.get = msg.get || {}) }\n\t\t\t\tif(get['#'] || at.soul){\n\t\t\t\t\tget['#'] = get['#'] || at.soul;\n\t\t\t\t\tmsg['#'] || (msg['#'] = text_rand(9)); // A3120 ?\n\t\t\t\t\tback = (root.$.get(get['#'])._);\n\t\t\t\t\tif(!(get = get['.'])){ // soul\n\t\t\t\t\t\ttmp = back.ask && back.ask['']; // check if we have already asked for the full node\n\t\t\t\t\t\t(back.ask || (back.ask = {}))[''] = back; // add a flag that we are now.\n\t\t\t\t\t\tif(u !== back.put){ // if we already have data,\n\t\t\t\t\t\t\tback.on('in', back); // send what is cached down the chain\n\t\t\t\t\t\t\tif(tmp){ return } // and don't ask for it again.\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmsg.$ = back.$;\n\t\t\t\t\t} else\n\t\t\t\t\tif(obj_has(back.put, get)){ // TODO: support #LEX !\n\t\t\t\t\t\ttmp = back.ask && back.ask[get];\n\t\t\t\t\t\t(back.ask || (back.ask = {}))[get] = back.$.get(get)._;\n\t\t\t\t\t\tback.on('in', {get: get, put: {'#': back.soul, '.': get, ':': back.put[get], '>': state_is(root.graph[back.soul], get)}});\n\t\t\t\t\t\tif(tmp){ return }\n\t\t\t\t\t}\n\t\t\t\t\t\t/*put = (back.$.get(get)._);\n\t\t\t\t\t\tif(!(tmp = put.ack)){ put.ack = -1 }\n\t\t\t\t\t\tback.on('in', {\n\t\t\t\t\t\t\t$: back.$,\n\t\t\t\t\t\t\tput: Gun.state.ify({}, get, Gun.state(back.put, get), back.put[get]),\n\t\t\t\t\t\t\tget: back.get\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif(tmp){ return }\n\t\t\t\t\t} else\n\t\t\t\t\tif('string' != typeof get){\n\t\t\t\t\t\tvar put = {}, meta = (back.put||{})._;\n\t\t\t\t\t\tGun.obj.map(back.put, function(v,k){\n\t\t\t\t\t\t\tif(!Gun.text.match(k, get)){ return }\n\t\t\t\t\t\t\tput[k] = v;\n\t\t\t\t\t\t})\n\t\t\t\t\t\tif(!Gun.obj.empty(put)){\n\t\t\t\t\t\t\tput._ = meta;\n\t\t\t\t\t\t\tback.on('in', {$: back.$, put: put, get: back.get})\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(tmp = at.lex){\n\t\t\t\t\t\t\ttmp = (tmp._) || (tmp._ = function(){});\n\t\t\t\t\t\t\tif(back.ack < tmp.ask){ tmp.ask = back.ack }\n\t\t\t\t\t\t\tif(tmp.ask){ return }\n\t\t\t\t\t\t\ttmp.ask = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t\troot.ask(ack, msg); // A3120 ?\n\t\t\t\t\treturn root.on('in', msg);\n\t\t\t\t}\n\t\t\t\t//if(root.now){ root.now[at.id] = root.now[at.id] || true; at.pass = {} }\n\t\t\t\tif(get['.']){\n\t\t\t\t\tif(at.get){\n\t\t\t\t\t\tmsg = {get: {'.': at.get}, $: at.$};\n\t\t\t\t\t\t(back.ask || (back.ask = {}))[at.get] = msg.$._; // TODO: PERFORMANCE? More elegant way?\n\t\t\t\t\t\treturn back.on('out', msg);\n\t\t\t\t\t}\n\t\t\t\t\tmsg = {get: at.lex? msg.get : {}, $: at.$};\n\t\t\t\t\treturn back.on('out', msg);\n\t\t\t\t}\n\t\t\t\t(at.ask || (at.ask = {}))[''] = at;\t //at.ack = at.ack || -1;\n\t\t\t\tif(at.get){\n\t\t\t\t\tget['.'] = at.get;\n\t\t\t\t\t(back.ask || (back.ask = {}))[at.get] = msg.$._; // TODO: PERFORMANCE? More elegant way?\n\t\t\t\t\treturn back.on('out', msg);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn back.on('out', msg);\n\t\t}; Gun.on.out = output;\n\n\t\tfunction input(msg, cat){ cat = cat || this.as; // TODO: V8 may not be able to optimize functions with different parameter calls, so try to do benchmark to see if there is any actual difference.\n\t\t\tvar root = cat.root, gun = msg.$ || (msg.$ = cat.$), at = (gun||'')._ || empty, tmp = msg.put||'', soul = tmp['#'], key = tmp['.'], change = (u !== tmp['='])? tmp['='] : tmp[':'], state = tmp['>'] || -Infinity, sat; // eve = event, at = data at, cat = chain at, sat = sub at (children chains).\n\t\t\tif(u !== msg.put && (u === tmp['#'] || u === tmp['.'] || (u === tmp[':'] && u === tmp['=']) || u === tmp['>'])){ // convert from old format\n\t\t\t\tif(!valid(tmp)){\n\t\t\t\t\tif(!(soul = ((tmp||'')._||'')['#'])){ console.log(\"chain not yet supported for\", tmp, '...', msg, cat); return; }\n\t\t\t\t\tgun = cat.root.$.get(soul);\n\t\t\t\t\treturn setTimeout.each(Object.keys(tmp).sort(), function(k){ // TODO: .keys( is slow // BUG? ?Some re-in logic may depend on this being sync?\n\t\t\t\t\t\tif('_' == k || u === (state = state_is(tmp, k))){ return }\n\t\t\t\t\t\tcat.on('in', {$: gun, put: {'#': soul, '.': k, '=': tmp[k], '>': state}, VIA: msg});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tcat.on('in', {$: at.back.$, put: {'#': soul = at.back.soul, '.': key = at.has || at.get, '=': tmp, '>': state_is(at.back.put, key)}, via: msg}); // TODO: This could be buggy! It assumes/approxes data, other stuff could have corrupted it.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif((msg.seen||'')[cat.id]){ return } (msg.seen || (msg.seen = function(){}))[cat.id] = cat; // help stop some infinite loops\n\n\t\t\tif(cat !== at){ // don't worry about this when first understanding the code, it handles changing contexts on a message. A soul chain will never have a different context.\n\t\t\t\tObject.keys(msg).forEach(function(k){ tmp[k] = msg[k] }, tmp = {}); // make copy of message\n\t\t\t\ttmp.get = cat.get || tmp.get;\n\t\t\t\tif(!cat.soul && !cat.has){ // if we do not recognize the chain type\n\t\t\t\t\ttmp.$$$ = tmp.$$$ || cat.$; // make a reference to wherever it came from.\n\t\t\t\t} else\n\t\t\t\tif(at.soul){ // a has (property) chain will have a different context sometimes if it is linked (to a soul chain). Anything that is not a soul or has chain, will always have different contexts.\n\t\t\t\t\ttmp.$ = cat.$;\n\t\t\t\t\ttmp.$$ = tmp.$$ || at.$;\n\t\t\t\t}\n\t\t\t\tmsg = tmp; // use the message with the new context instead;\n\t\t\t}\n\t\t\tunlink(msg, cat);\n\n\t\t\tif(((cat.soul/* && (cat.ask||'')['']*/) || msg.$$) && state >= state_is(root.graph[soul], key)){ // The root has an in-memory cache of the graph, but if our peer has asked for the data then we want a per deduplicated chain copy of the data that might have local edits on it.\n\t\t\t\t(tmp = root.$.get(soul)._).put = state_ify(tmp.put, key, state, change, soul);\n\t\t\t}\n\t\t\tif(!at.soul /*&& (at.ask||'')['']*/ && state >= state_is(root.graph[soul], key) && (sat = (root.$.get(soul)._.next||'')[key])){ // Same as above here, but for other types of chains. // TODO: Improve perf by preventing echoes recaching.\n\t\t\t\tsat.put = change; // update cache\n\t\t\t\tif('string' == typeof (tmp = valid(change))){\n\t\t\t\t\tsat.put = root.$.get(tmp)._.put || change; // share same cache as what we're linked to.\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.to && this.to.next(msg); // 1st API job is to call all chain listeners.\n\t\t\t// TODO: Make input more reusable by only doing these (some?) calls if we are a chain we recognize? This means each input listener would be responsible for when listeners need to be called, which makes sense, as they might want to filter.\n\t\t\tcat.any && setTimeout.each(Object.keys(cat.any), function(any){ (any = cat.any[any]) && any(msg) },0,99); // 1st API job is to call all chain listeners. // TODO: .keys( is slow // BUG: Some re-in logic may depend on this being sync.\n\t\t\tcat.echo && setTimeout.each(Object.keys(cat.echo), function(lat){ (lat = cat.echo[lat]) && lat.on('in', msg) },0,99); // & linked at chains // TODO: .keys( is slow // BUG: Some re-in logic may depend on this being sync.\n\n\t\t\tif(((msg.$$||'')._||at).soul){ // comments are linear, but this line of code is non-linear, so if I were to comment what it does, you'd have to read 42 other comments first... but you can't read any of those comments until you first read this comment. What!? // shouldn't this match link's check?\n\t\t\t\t// is there cases where it is a $$ that we do NOT want to do the following? \n\t\t\t\tif((sat = cat.next) && (sat = sat[key])){ // TODO: possible trick? Maybe have `ionmap` code set a sat? // TODO: Maybe we should do `cat.ask` instead? I guess does not matter.\n\t\t\t\t\ttmp = {}; Object.keys(msg).forEach(function(k){ tmp[k] = msg[k] });\n\t\t\t\t\ttmp.$ = (msg.$$||msg.$).get(tmp.get = key); delete tmp.$$; delete tmp.$$$;\n\t\t\t\t\tsat.on('in', tmp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlink(msg, cat);\n\t\t}; Gun.on.in = input;\n\n\t\tfunction link(msg, cat){ cat = cat || this.as || msg.$._;\n\t\t\tif(msg.$$ && this !== Gun.on){ return } // $$ means we came from a link, so we are at the wrong level, thus ignore it unless overruled manually by being called directly.\n\t\t\tif(!msg.put || cat.soul){ return } // But you cannot overrule being linked to nothing, or trying to link a soul chain - that must never happen.\n\t\t\tvar put = msg.put||'', link = put['=']||put[':'], tmp;\n\t\t\tvar root = cat.root, tat = root.$.get(put['#']).get(put['.'])._;\n\t\t\tif('string' != typeof (link = valid(link))){\n\t\t\t\tif(this === Gun.on){ (tat.echo || (tat.echo = {}))[cat.id] = cat } // allow some chain to explicitly force linking to simple data.\n\t\t\t\treturn; // by default do not link to data that is not a link.\n\t\t\t}\n\t\t\tif((tat.echo || (tat.echo = {}))[cat.id] // we've already linked ourselves so we do not need to do it again. Except... (annoying implementation details)\n\t\t\t\t&& !(root.pass||'')[cat.id]){ return } // if a new event listener was added, we need to make a pass through for it. The pass will be on the chain, not always the chain passed down. \n\t\t\tif(tmp = root.pass){ if(tmp[link+cat.id]){ return } tmp[link+cat.id] = 1 } // But the above edge case may \"pass through\" on a circular graph causing infinite passes, so we hackily add a temporary check for that.\n\n\t\t\t(tat.echo||(tat.echo={}))[cat.id] = cat; // set ourself up for the echo! // TODO: BUG? Echo to self no longer causes problems? Confirm.\n\n\t\t\tif(cat.has){ cat.link = link }\n\t\t\tvar sat = root.$.get(tat.link = link)._; // grab what we're linking to.\n\t\t\t(sat.echo || (sat.echo = {}))[tat.id] = tat; // link it.\n\t\t\tvar tmp = cat.ask||''; // ask the chain for what needs to be loaded next!\n\t\t\tif(tmp[''] || cat.lex){ // we might need to load the whole thing // TODO: cat.lex probably has edge case bugs to it, need more test coverage.\n\t\t\t\tsat.on('out', {get: {'#': link}});\n\t\t\t}\n\t\t\tsetTimeout.each(Object.keys(tmp), function(get, sat){ // if sub chains are asking for data. // TODO: .keys( is slow // BUG? ?Some re-in logic may depend on this being sync?\n\t\t\t\tif(!get || !(sat = tmp[get])){ return }\n\t\t\t\tsat.on('out', {get: {'#': link, '.': get}}); // go get it.\n\t\t\t},0,99);\n\t\t}; Gun.on.link = link;\n\n\t\tfunction unlink(msg, cat){ // ugh, so much code for seemingly edge case behavior.\n\t\t\tvar put = msg.put||'', change = (u !== put['='])? put['='] : put[':'], root = cat.root, link, tmp;\n\t\t\tif(u === change){ // 1st edge case: If we have a brand new database, no data will be found.\n\t\t\t\t// TODO: BUG! because emptying cache could be async from below, make sure we are not emptying a newer cache. So maybe pass an Async ID to check against?\n\t\t\t\t// TODO: BUG! What if this is a map? // Warning! Clearing things out needs to be robust against sync/async ops, or else you'll see `map val get put` test catastrophically fail because map attempts to link when parent graph is streamed before child value gets set. Need to differentiate between lack acks and force clearing.\n\t\t\t\tif(cat.soul && u !== cat.put){ return } // data may not be found on a soul, but if a soul already has data, then nothing can clear the soul as a whole.\n\t\t\t\t//if(!cat.has){ return }\n\t\t\t\ttmp = (msg.$$||msg.$||'')._||'';\n\t\t\t\tif(msg['@'] && (u !== tmp.put || u !== cat.put)){ return } // a \"not found\" from other peers should not clear out data if we have already found it.\n\t\t\t\t//if(cat.has && u === cat.put && !(root.pass||'')[cat.id]){ return } // if we are already unlinked, do not call again, unless edge case. // TODO: BUG! This line should be deleted for \"unlink deeply nested\".\n\t\t\t\tif(link = cat.link || msg.linked){\n\t\t\t\t\tdelete (root.$.get(link)._.echo||'')[cat.id];\n\t\t\t\t}\n\t\t\t\tif(cat.has){ // TODO: Empty out links, maps, echos, acks/asks, etc.?\n\t\t\t\t\tcat.link = null;\n\t\t\t\t}\n\t\t\t\tcat.put = u; // empty out the cache if, for example, alice's car's color no longer exists (relative to alice) if alice no longer has a car.\n\t\t\t\t// TODO: BUG! For maps, proxy this so the individual sub is triggered, not all subs.\n\t\t\t\tsetTimeout.each(Object.keys(cat.next||''), function(get, sat){ // empty out all sub chains. // TODO: .keys( is slow // BUG? ?Some re-in logic may depend on this being sync? // TODO: BUG? This will trigger deeper put first, does put logic depend on nested order? // TODO: BUG! For map, this needs to be the isolated child, not all of them.\n\t\t\t\t\tif(!(sat = cat.next[get])){ return }\n\t\t\t\t\t//if(cat.has && u === sat.put && !(root.pass||'')[sat.id]){ return } // if we are already unlinked, do not call again, unless edge case. // TODO: BUG! This line should be deleted for \"unlink deeply nested\".\n\t\t\t\t\tif(link){ delete (root.$.get(link).get(get)._.echo||'')[sat.id] }\n\t\t\t\t\tsat.on('in', {get: get, put: u, $: sat.$}); // TODO: BUG? Add recursive seen check?\n\t\t\t\t},0,99);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(cat.soul){ return } // a soul cannot unlink itself.\n\t\t\tif(msg.$$){ return } // a linked chain does not do the unlinking, the sub chain does. // TODO: BUG? Will this cancel maps?\n\t\t\tlink = valid(change); // need to unlink anytime we are not the same link, though only do this once per unlink (and not on init).\n\t\t\ttmp = msg.$._||'';\n\t\t\tif(link === tmp.link || (cat.has && !tmp.link)){\n\t\t\t\tif((root.pass||'')[cat.id] && 'string' !== typeof link){\n\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdelete (tmp.echo||'')[cat.id];\n\t\t\tunlink({get: cat.get, put: u, $: msg.$, linked: msg.linked = msg.linked || tmp.link}, cat); // unlink our sub chains.\n\t\t}; Gun.on.unlink = unlink;\n\n\t\tfunction ack(msg, ev){\n\t\t\t//if(!msg['%'] && (this||'').off){ this.off() } // do NOT memory leak, turn off listeners! Now handled by .ask itself\n\t\t\t// manhattan:\n\t\t\tvar as = this.as, at = as.$._, root = at.root, get = as.get||'', tmp = (msg.put||'')[get['#']]||'';\n\t\t\tif(!msg.put || ('string' == typeof get['.'] && u === tmp[get['.']])){\n\t\t\t\tif(u !== at.put){ return }\n\t\t\t\tif(!at.soul && !at.has){ return } // TODO: BUG? For now, only core-chains will handle not-founds, because bugs creep in if non-core chains are used as $ but we can revisit this later for more powerful extensions.\n\t\t\t\tat.ack = (at.ack || 0) + 1;\n\t\t\t\tat.on('in', {\n\t\t\t\t\tget: at.get,\n\t\t\t\t\tput: at.put = u,\n\t\t\t\t\t$: at.$,\n\t\t\t\t\t'@': msg['@']\n\t\t\t\t});\n\t\t\t\t/*(tmp = at.Q) && setTimeout.each(Object.keys(tmp), function(id){ // TODO: Temporary testing, not integrated or being used, probably delete.\n\t\t\t\t\tObject.keys(msg).forEach(function(k){ tmp[k] = msg[k] }, tmp = {}); tmp['@'] = id; // copy message\n\t\t\t\t\troot.on('in', tmp);\n\t\t\t\t}); delete at.Q;*/\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t(msg._||{}).miss = 1;\n\t\t\tGun.on.put(msg);\n\t\t\treturn; // eom\n\t\t}\n\n\t\tvar empty = {}, u, text_rand = String.random, valid = Gun.valid, obj_has = function(o, k){ return o && Object.prototype.hasOwnProperty.call(o, k) }, state = Gun.state, state_is = state.is, state_ify = state.ify;\n\t})(USE, './chain');\n\n\t;USE(function(module){\n\t\tvar Gun = USE('./root');\n\t\tGun.chain.get = function(key, cb, as){\n\t\t\tvar gun, tmp;\n\t\t\tif(typeof key === 'string'){\n\t\t\t\tif(key.length == 0) {\t\n\t\t\t\t\t(gun = this.chain())._.err = {err: Gun.log('0 length key!', key)};\n\t\t\t\t\tif(cb){ cb.call(gun, gun._.err) }\n\t\t\t\t\treturn gun;\n\t\t\t\t}\n\t\t\t\tvar back = this, cat = back._;\n\t\t\t\tvar next = cat.next || empty;\n\t\t\t\tif(!(gun = next[key])){\n\t\t\t\t\tgun = key && cache(key, back);\n\t\t\t\t}\n\t\t\t\tgun = gun && gun.$;\n\t\t\t} else\n\t\t\tif('function' == typeof key){\n\t\t\t\tif(true === cb){ return soul(this, key, cb, as), this }\n\t\t\t\tgun = this;\n\t\t\t\tvar cat = gun._, opt = cb || {}, root = cat.root, id;\n\t\t\t\topt.at = cat;\n\t\t\t\topt.ok = key;\n\t\t\t\tvar wait = {}; // can we assign this to the at instead, like in once?\n\t\t\t\t//var path = []; cat.$.back(at => { at.get && path.push(at.get.slice(0,9))}); path = path.reverse().join('.');\n\t\t\t\tfunction any(msg, eve, f){\n\t\t\t\t\tif(any.stun){ return }\n\t\t\t\t\tif((tmp = root.pass) && !tmp[id]){ return }\n\t\t\t\t\tvar at = msg.$._, sat = (msg.$$||'')._, data = (sat||at).put, odd = (!at.has && !at.soul), test = {}, link, tmp;\n\t\t\t\t\tif(odd || u === data){ // handles non-core\n\t\t\t\t\t\tdata = (u === ((tmp = msg.put)||'')['='])? (u === (tmp||'')[':'])? tmp : tmp[':'] : tmp['='];\n\t\t\t\t\t}\n\t\t\t\t\tif(link = ('string' == typeof (tmp = Gun.valid(data)))){\n\t\t\t\t\t\tdata = (u === (tmp = root.$.get(tmp)._.put))? opt.not? u : data : tmp;\n\t\t\t\t\t}\n\t\t\t\t\tif(opt.not && u === data){ return }\n\t\t\t\t\tif(u === opt.stun){\n\t\t\t\t\t\tif((tmp = root.stun) && tmp.on){\n\t\t\t\t\t\t\tcat.$.back(function(a){ // our chain stunned?\n\t\t\t\t\t\t\t\ttmp.on(''+a.id, test = {});\n\t\t\t\t\t\t\t\tif((test.run || 0) < any.id){ return test } // if there is an earlier stun on gapless parents/self.\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t!test.run && tmp.on(''+at.id, test = {}); // this node stunned?\n\t\t\t\t\t\t\t!test.run && sat && tmp.on(''+sat.id, test = {}); // linked node stunned?\n\t\t\t\t\t\t\tif(any.id > test.run){\n\t\t\t\t\t\t\t\tif(!test.stun || test.stun.end){\n\t\t\t\t\t\t\t\t\ttest.stun = tmp.on('stun');\n\t\t\t\t\t\t\t\t\ttest.stun = test.stun && test.stun.last;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(test.stun && !test.stun.end){\n\t\t\t\t\t\t\t\t\t//if(odd && u === data){ return }\n\t\t\t\t\t\t\t\t\t//if(u === msg.put){ return } // \"not found\" acks will be found if there is stun, so ignore these.\n\t\t\t\t\t\t\t\t\t(test.stun.add || (test.stun.add = {}))[id] = function(){ any(msg,eve,1) } // add ourself to the stun callback list that is called at end of the write.\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(/*odd &&*/ u === data){ f = 0 } // if data not found, keep waiting/trying.\n\t\t\t\t\t\t/*if(f && u === data){\n\t\t\t\t\t\t\tcat.on('out', opt.out);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}*/\n\t\t\t\t\t\tif((tmp = root.hatch) && !tmp.end && u === opt.hatch && !f){ // quick hack! // What's going on here? Because data is streamed, we get things one by one, but a lot of developers would rather get a callback after each batch instead, so this does that by creating a wait list per chain id that is then called at the end of the batch by the hatch code in the root put listener.\n\t\t\t\t\t\t\tif(wait[at.$._.id]){ return } wait[at.$._.id] = 1;\n\t\t\t\t\t\t\ttmp.push(function(){any(msg,eve,1)});\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}; wait = {}; // end quick hack.\n\t\t\t\t\t}\n\t\t\t\t\t// call:\n\t\t\t\t\tif(root.pass){ if(root.pass[id+at.id]){ return } root.pass[id+at.id] = 1 }\n\t\t\t\t\tif(opt.on){ opt.ok.call(at.$, data, at.get, msg, eve || any); return } // TODO: Also consider breaking `this` since a lot of people do `=>` these days and `.call(` has slower performance.\n\t\t\t\t\tif(opt.v2020){ opt.ok(msg, eve || any); return }\n\t\t\t\t\tObject.keys(msg).forEach(function(k){ tmp[k] = msg[k] }, tmp = {}); msg = tmp; msg.put = data; // 2019 COMPATIBILITY! TODO: GET RID OF THIS!\n\t\t\t\t\topt.ok.call(opt.as, msg, eve || any); // is this the right\n\t\t\t\t};\n\t\t\t\tany.at = cat;\n\t\t\t\t//(cat.any||(cat.any=function(msg){ setTimeout.each(Object.keys(cat.any||''), function(act){ (act = cat.any[act]) && act(msg) },0,99) }))[id = String.random(7)] = any; // maybe switch to this in future?\n\t\t\t\t(cat.any||(cat.any={}))[id = String.random(7)] = any;\n\t\t\t\tany.off = function(){ any.stun = 1; if(!cat.any){ return } delete cat.any[id] }\n\t\t\t\tany.rid = rid; // logic from old version, can we clean it up now?\n\t\t\t\tany.id = opt.run || ++root.once; // used in callback to check if we are earlier than a write. // will this ever cause an integer overflow?\n\t\t\t\ttmp = root.pass; (root.pass = {})[id] = 1; // Explanation: test trade-offs want to prevent recursion so we add/remove pass flag as it gets fulfilled to not repeat, however map map needs many pass flags - how do we reconcile?\n\t\t\t\topt.out = opt.out || {get: {}};\n\t\t\t\tcat.on('out', opt.out);\n\t\t\t\troot.pass = tmp;\n\t\t\t\treturn gun;\n\t\t\t} else\n\t\t\tif('number' == typeof key){\n\t\t\t\treturn this.get(''+key, cb, as);\n\t\t\t} else\n\t\t\tif('string' == typeof (tmp = valid(key))){\n\t\t\t\treturn this.get(tmp, cb, as);\n\t\t\t} else\n\t\t\tif(tmp = this.get.next){\n\t\t\t\tgun = tmp(this, key);\n\t\t\t}\n\t\t\tif(!gun){\n\t\t\t\t(gun = this.chain())._.err = {err: Gun.log('Invalid get request!', key)}; // CLEAN UP\n\t\t\t\tif(cb){ cb.call(gun, gun._.err) }\n\t\t\t\treturn gun;\n\t\t\t}\n\t\t\tif(cb && 'function' == typeof cb){\n\t\t\t\tgun.get(cb, as);\n\t\t\t}\n\t\t\treturn gun;\n\t\t}\n\t\tfunction cache(key, back){\n\t\t\tvar cat = back._, next = cat.next, gun = back.chain(), at = gun._;\n\t\t\tif(!next){ next = cat.next = {} }\n\t\t\tnext[at.get = key] = at;\n\t\t\tif(back === cat.root.$){\n\t\t\t\tat.soul = key;\n\t\t\t} else\n\t\t\tif(cat.soul || cat.has){\n\t\t\t\tat.has = key;\n\t\t\t\t//if(obj_has(cat.put, key)){\n\t\t\t\t\t//at.put = cat.put[key];\n\t\t\t\t//}\n\t\t\t}\n\t\t\treturn at;\n\t\t}\n\t\tfunction soul(gun, cb, opt, as){\n\t\t\tvar cat = gun._, acks = 0, tmp;\n\t\t\tif(tmp = cat.soul || cat.link){ return cb(tmp, as, cat) }\n\t\t\tif(cat.jam){ return cat.jam.push([cb, as]) }\n\t\t\tcat.jam = [[cb,as]];\n\t\t\tgun.get(function go(msg, eve){\n\t\t\t\tif(u === msg.put && !cat.root.opt.super && (tmp = Object.keys(cat.root.opt.peers).length) && ++acks <= tmp){ // TODO: super should not be in core code, bring AXE up into core instead to fix? // TODO: .keys( is slow\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\teve.rid(msg);\n\t\t\t\tvar at = ((at = msg.$) && at._) || {}, i = 0, as;\n\t\t\t\ttmp = cat.jam; delete cat.jam; // tmp = cat.jam.splice(0, 100);\n\t\t\t\t//if(tmp.length){ process.nextTick(function(){ go(msg, eve) }) }\n\t\t\t\twhile(as = tmp[i++]){ //Gun.obj.map(tmp, function(as, cb){\n\t\t\t\t\tvar cb = as[0], id; as = as[1];\n\t\t\t\t\tcb && cb(id = at.link || at.soul || Gun.valid(msg.put) || ((msg.put||{})._||{})['#'], as, msg, eve);\n\t\t\t\t} //);\n\t\t\t}, {out: {get: {'.':true}}});\n\t\t\treturn gun;\n\t\t}\n\t\tfunction rid(at){\n\t\t\tvar cat = this.at || this.on;\n\t\t\tif(!at || cat.soul || cat.has){ return this.off() }\n\t\t\tif(!(at = (at = (at = at.$ || at)._ || at).id)){ return }\n\t\t\tvar map = cat.map, tmp, seen;\n\t\t\t//if(!map || !(tmp = map[at]) || !(tmp = tmp.at)){ return }\n\t\t\tif(tmp = (seen = this.seen || (this.seen = {}))[at]){ return true }\n\t\t\tseen[at] = true;\n\t\t\treturn;\n\t\t\t//tmp.echo[cat.id] = {}; // TODO: Warning: This unsubscribes ALL of this chain's listeners from this link, not just the one callback event.\n\t\t\t//obj.del(map, at); // TODO: Warning: This unsubscribes ALL of this chain's listeners from this link, not just the one callback event.\n\t\t\treturn;\n\t\t}\n\t\tvar empty = {}, valid = Gun.valid, u;\n\t})(USE, './get');\n\n\t;USE(function(module){\n\t\tvar Gun = USE('./root');\n\t\tGun.chain.put = function(data, cb, as){ // I rewrote it :)\n\t\t\tvar gun = this, at = gun._, root = at.root;\n\t\t\tas = as || {};\n\t\t\tas.root = at.root;\n\t\t\tas.run || (as.run = root.once);\n\t\t\tstun(as, at.id); // set a flag for reads to check if this chain is writing.\n\t\t\tas.ack = as.ack || cb;\n\t\t\tas.via = as.via || gun;\n\t\t\tas.data = as.data || data;\n\t\t\tas.soul || (as.soul = at.soul || ('string' == typeof cb && cb));\n\t\t\tvar s = as.state = as.state || Gun.state();\n\t\t\tif('function' == typeof data){ data(function(d){ as.data = d; gun.put(u,u,as) }); return gun }\n\t\t\tif(!as.soul){ return get(as), gun }\n\t\t\tas.$ = root.$.get(as.soul); // TODO: This may not allow user chaining and similar?\n\t\t\tas.todo = [{it: as.data, ref: as.$}];\n\t\t\tas.turn = as.turn || turn;\n\t\t\tas.ran = as.ran || ran;\n\t\t\t//var path = []; as.via.back(at => { at.get && path.push(at.get.slice(0,9)) }); path = path.reverse().join('.');\n\t\t\t// TODO: Perf! We only need to stun chains that are being modified, not necessarily written to.\n\t\t\t(function walk(){\n\t\t\t\tvar to = as.todo, at = to.pop(), d = at.it, cid = at.ref && at.ref._.id, v, k, cat, tmp, g;\n\t\t\t\tstun(as, at.ref);\n\t\t\t\tif(tmp = at.todo){\n\t\t\t\t\tk = tmp.pop(); d = d[k];\n\t\t\t\t\tif(tmp.length){ to.push(at) }\n\t\t\t\t}\n\t\t\t\tk && (to.path || (to.path = [])).push(k);\n\t\t\t\tif(!(v = valid(d)) && !(g = Gun.is(d))){\n\t\t\t\t\tif(!Object.plain(d)){ ran.err(as, \"Invalid data: \"+ check(d) +\" at \" + (as.via.back(function(at){at.get && tmp.push(at.get)}, tmp = []) || tmp.join('.'))+'.'+(to.path||[]).join('.')); return }\n\t\t\t\t\tvar seen = as.seen || (as.seen = []), i = seen.length;\n\t\t\t\t\twhile(i--){ if(d === (tmp = seen[i]).it){ v = d = tmp.link; break } }\n\t\t\t\t}\n\t\t\t\tif(k && v){ at.node = state_ify(at.node, k, s, d) } // handle soul later.\n\t\t\t\telse {\n\t\t\t\t\tif(!as.seen){ ran.err(as, \"Data at root of graph must be a node (an object).\"); return }\n\t\t\t\t\tas.seen.push(cat = {it: d, link: {}, todo: g? [] : Object.keys(d).sort().reverse(), path: (to.path||[]).slice(), up: at}); // Any perf reasons to CPU schedule this .keys( ?\n\t\t\t\t\tat.node = state_ify(at.node, k, s, cat.link);\n\t\t\t\t\t!g && cat.todo.length && to.push(cat);\n\t\t\t\t\t// ---------------\n\t\t\t\t\tvar id = as.seen.length;\n\t\t\t\t\t(as.wait || (as.wait = {}))[id] = '';\n\t\t\t\t\ttmp = (cat.ref = (g? d : k? at.ref.get(k) : at.ref))._;\n\t\t\t\t\t(tmp = (d && (d._||'')['#']) || tmp.soul || tmp.link)? resolve({soul: tmp}) : cat.ref.get(resolve, {run: as.run, /*hatch: 0,*/ v2020:1, out:{get:{'.':' '}}}); // TODO: BUG! This should be resolve ONLY soul to prevent full data from being loaded. // Fixed now?\n\t\t\t\t\t//setTimeout(function(){ if(F){ return } console.log(\"I HAVE NOT BEEN CALLED!\", path, id, cat.ref._.id, k) }, 9000); var F; // MAKE SURE TO ADD F = 1 below!\n\t\t\t\t\tfunction resolve(msg, eve){\n\t\t\t\t\t\tvar end = cat.link['#'];\n\t\t\t\t\t\tif(eve){ eve.off(); eve.rid(msg) } // TODO: Too early! Check all peers ack not found.\n\t\t\t\t\t\t// TODO: BUG maybe? Make sure this does not pick up a link change wipe, that it uses the changign link instead.\n\t\t\t\t\t\tvar soul = end || msg.soul || (tmp = (msg.$$||msg.$)._||'').soul || tmp.link || ((tmp = tmp.put||'')._||'')['#'] || tmp['#'] || (((tmp = msg.put||'') && msg.$$)? tmp['#'] : (tmp['=']||tmp[':']||'')['#']);\n\t\t\t\t\t\t!end && stun(as, msg.$);\n\t\t\t\t\t\tif(!soul && !at.link['#']){ // check soul link above us\n\t\t\t\t\t\t\t(at.wait || (at.wait = [])).push(function(){ resolve(msg, eve) }) // wait\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!soul){\n\t\t\t\t\t\t\tsoul = [];\n\t\t\t\t\t\t\t(msg.$$||msg.$).back(function(at){\n\t\t\t\t\t\t\t\tif(tmp = at.soul || at.link){ return soul.push(tmp) }\n\t\t\t\t\t\t\t\tsoul.push(at.get);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tsoul = soul.reverse().join('/');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcat.link['#'] = soul;\n\t\t\t\t\t\t!g && (((as.graph || (as.graph = {}))[soul] = (cat.node || (cat.node = {_:{}})))._['#'] = soul);\n\t\t\t\t\t\tdelete as.wait[id];\n\t\t\t\t\t\tcat.wait && setTimeout.each(cat.wait, function(cb){ cb && cb() });\n\t\t\t\t\t\tas.ran(as);\n\t\t\t\t\t};\n\t\t\t\t\t// ---------------\n\t\t\t\t}\n\t\t\t\tif(!to.length){ return as.ran(as) }\n\t\t\t\tas.turn(walk);\n\t\t\t}());\n\t\t\treturn gun;\n\t\t}\n\n\t\tfunction stun(as, id){\n\t\t\tif(!id){ return } id = (id._||'').id||id;\n\t\t\tvar run = as.root.stun || (as.root.stun = {on: Gun.on}), test = {}, tmp;\n\t\t\tas.stun || (as.stun = run.on('stun', function(){ }));\n\t\t\tif(tmp = run.on(''+id)){ tmp.the.last.next(test) }\n\t\t\tif(test.run >= as.run){ return }\n\t\t\trun.on(''+id, function(test){\n\t\t\t\tif(as.stun.end){\n\t\t\t\t\tthis.off();\n\t\t\t\t\tthis.to.next(test);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttest.run = test.run || as.run;\n\t\t\t\ttest.stun = test.stun || as.stun; return;\n\t\t\t\tif(this.to.to){\n\t\t\t\t\tthis.the.last.next(test);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttest.stun = as.stun;\n\t\t\t});\n\t\t}\n\n\t\tfunction ran(as){\n\t\t\tif(as.err){ ran.end(as.stun, as.root); return } // move log handle here.\n\t\t\tif(as.todo.length || as.end || !Object.empty(as.wait)){ return } as.end = 1;\n\t\t\tvar cat = (as.$.back(-1)._), root = cat.root, ask = cat.ask(function(ack){\n\t\t\t\troot.on('ack', ack);\n\t\t\t\tif(ack.err){ Gun.log(ack) }\n\t\t\t\tif(++acks > (as.acks || 0)){ this.off() } // Adjustable ACKs! Only 1 by default.\n\t\t\t\tif(!as.ack){ return }\n\t\t\t\tas.ack(ack, this);\n\t\t\t}, as.opt), acks = 0, stun = as.stun, tmp;\n\t\t\t(tmp = function(){ // this is not official yet, but quick solution to hack in for now.\n\t\t\t\tif(!stun){ return }\n\t\t\t\tran.end(stun, root);\n\t\t\t\tsetTimeout.each(Object.keys(stun = stun.add||''), function(cb){ if(cb = stun[cb]){cb()} }); // resume the stunned reads // Any perf reasons to CPU schedule this .keys( ?\n\t\t\t}).hatch = tmp; // this is not official yet ^\n\t\t\t//console.log(1, \"PUT\", as.run, as.graph);\n\t\t\t(as.via._).on('out', {put: as.out = as.graph, opt: as.opt, '#': ask, _: tmp});\n\t\t}; ran.end = function(stun,root){\n\t\t\tstun.end = noop; // like with the earlier id, cheaper to make this flag a function so below callbacks do not have to do an extra type check.\n\t\t\tif(stun.the.to === stun && stun === stun.the.last){ delete root.stun }\n\t\t\tstun.off();\n\t\t}; ran.err = function(as, err){\n\t\t\t(as.ack||noop).call(as, as.out = { err: as.err = Gun.log(err) });\n\t\t\tas.ran(as);\n\t\t}\n\n\t\tfunction get(as){\n\t\t\tvar at = as.via._, tmp;\n\t\t\tas.via = as.via.back(function(at){\n\t\t\t\tif(at.soul || !at.get){ return at.$ }\n\t\t\t\ttmp = as.data; (as.data = {})[at.get] = tmp;\n\t\t\t});\n\t\t\tif(!as.via || !as.via._.soul){\n\t\t\t\tas.via = at.root.$.get(((as.data||'')._||'')['#'] || at.$.back('opt.uuid')())\n\t\t\t}\n\t\t\tas.via.put(as.data, as.ack, as);\n\t\t\t\n\n\t\t\treturn;\n\t\t\tif(at.get && at.back.soul){\n\t\t\t\ttmp = as.data;\n\t\t\t\tas.via = at.back.$;\n\t\t\t\t(as.data = {})[at.get] = tmp; \n\t\t\t\tas.via.put(as.data, as.ack, as);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfunction check(d, tmp){ return ((d && (tmp = d.constructor) && tmp.name) || typeof d) }\n\n\t\tvar u, empty = {}, noop = function(){}, turn = setTimeout.turn, valid = Gun.valid, state_ify = Gun.state.ify;\n\t\tvar iife = function(fn,as){fn.call(as||empty)}\n\t})(USE, './put');\n\n\t;USE(function(module){\n\t\tvar Gun = USE('./root');\n\t\tUSE('./chain');\n\t\tUSE('./back');\n\t\tUSE('./put');\n\t\tUSE('./get');\n\t\tmodule.exports = Gun;\n\t})(USE, './index');\n\n\t;USE(function(module){\n\t\tvar Gun = USE('./index');\n\t\tGun.chain.on = function(tag, arg, eas, as){ // don't rewrite!\n\t\t\tvar gun = this, cat = gun._, root = cat.root, act, off, id, tmp;\n\t\t\tif(typeof tag === 'string'){\n\t\t\t\tif(!arg){ return cat.on(tag) }\n\t\t\t\tact = cat.on(tag, arg, eas || cat, as);\n\t\t\t\tif(eas && eas.$){\n\t\t\t\t\t(eas.subs || (eas.subs = [])).push(act);\n\t\t\t\t}\n\t\t\t\treturn gun;\n\t\t\t}\n\t\t\tvar opt = arg;\n\t\t\t(opt = (true === opt)? {change: true} : opt || {}).not = 1; opt.on = 1;\n\t\t\t//opt.at = cat;\n\t\t\t//opt.ok = tag;\n\t\t\t//opt.last = {};\n\t\t\tvar wait = {}; // can we assign this to the at instead, like in once?\n\t\t\tgun.get(tag, opt);\n\t\t\t/*gun.get(function on(data,key,msg,eve){ var $ = this;\n\t\t\t\tif(tmp = root.hatch){ // quick hack!\n\t\t\t\t\tif(wait[$._.id]){ return } wait[$._.id] = 1;\n\t\t\t\t\ttmp.push(function(){on.call($, data,key,msg,eve)});\n\t\t\t\t\treturn;\n\t\t\t\t}; wait = {}; // end quick hack.\n\t\t\t\ttag.call($, data,key,msg,eve);\n\t\t\t}, opt); // TODO: PERF! Event listener leak!!!?*/\n\t\t\t/*\n\t\t\tfunction one(msg, eve){\n\t\t\t\tif(one.stun){ return }\n\t\t\t\tvar at = msg.$._, data = at.put, tmp;\n\t\t\t\tif(tmp = at.link){ data = root.$.get(tmp)._.put }\n\t\t\t\tif(opt.not===u && u === data){ return }\n\t\t\t\tif(opt.stun===u && (tmp = root.stun) && (tmp = tmp[at.id] || tmp[at.back.id]) && !tmp.end){ // Remember! If you port this into `.get(cb` make sure you allow stun:0 skip option for `.put(`.\n\t\t\t\t\ttmp[id] = function(){one(msg,eve)};\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t//tmp = one.wait || (one.wait = {}); console.log(tmp[at.id] === ''); if(tmp[at.id] !== ''){ tmp[at.id] = tmp[at.id] || setTimeout(function(){tmp[at.id]='';one(msg,eve)},1); return } delete tmp[at.id];\n\t\t\t\t// call:\n\t\t\t\tif(opt.as){\n\t\t\t\t\topt.ok.call(opt.as, msg, eve || one);\n\t\t\t\t} else {\n\t\t\t\t\topt.ok.call(at.$, data, msg.get || at.get, msg, eve || one);\n\t\t\t\t}\n\t\t\t};\n\t\t\tone.at = cat;\n\t\t\t(cat.act||(cat.act={}))[id = String.random(7)] = one;\n\t\t\tone.off = function(){ one.stun = 1; if(!cat.act){ return } delete cat.act[id] }\n\t\t\tcat.on('out', {get: {}});*/\n\t\t\treturn gun;\n\t\t}\n\t\t// Rules:\n\t\t// 1. If cached, should be fast, but not read while write.\n\t\t// 2. Should not retrigger other listeners, should get triggered even if nothing found.\n\t\t// 3. If the same callback passed to many different once chains, each should resolve - an unsubscribe from the same callback should not effect the state of the other resolving chains, if you do want to cancel them all early you should mutate the callback itself with a flag & check for it at top of callback\n\t\tGun.chain.once = function(cb, opt){ opt = opt || {}; // avoid rewriting\n\t\t\tif(!cb){ return none(this,opt) }\n\t\t\tvar gun = this, cat = gun._, root = cat.root, data = cat.put, id = String.random(7), one, tmp;\n\t\t\tgun.get(function(data,key,msg,eve){\n\t\t\t\tvar $ = this, at = $._, one = (at.one||(at.one={}));\n\t\t\t\tif(eve.stun){ return } if('' === one[id]){ return }\n\t\t\t\tif(true === (tmp = Gun.valid(data))){ once(); return }\n\t\t\t\tif('string' == typeof tmp){ return } // TODO: BUG? Will this always load?\n\t\t\t\tclearTimeout((cat.one||'')[id]); // clear \"not found\" since they only get set on cat.\n\t\t\t\tclearTimeout(one[id]); one[id] = setTimeout(once, opt.wait||99); // TODO: Bug? This doesn't handle plural chains.\n\t\t\t\tfunction once(f){\n\t\t\t\t\tif(!at.has && !at.soul){ at = {put: data, get: key} } // handles non-core messages.\n\t\t\t\t\tif(u === (tmp = at.put)){ tmp = ((msg.$$||'')._||'').put }\n\t\t\t\t\tif('string' == typeof Gun.valid(tmp)){\n\t\t\t\t\t\ttmp = root.$.get(tmp)._.put;\n\t\t\t\t\t\tif(tmp === u && !f){\n\t\t\t\t\t\t\tone[id] = setTimeout(function(){ once(1) }, opt.wait||99); // TODO: Quick fix. Maybe use ack count for more predictable control?\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//console.log(\"AND VANISHED\", data);\n\t\t\t\t\tif(eve.stun){ return } if('' === one[id]){ return } one[id] = '';\n\t\t\t\t\tif(cat.soul || cat.has){ eve.off() } // TODO: Plural chains? // else { ?.off() } // better than one check?\n\t\t\t\t\tcb.call($, tmp, at.get);\n\t\t\t\t\tclearTimeout(one[id]); // clear \"not found\" since they only get set on cat. // TODO: This was hackily added, is it necessary or important? Probably not, in future try removing this. Was added just as a safety for the `&& !f` check.\n\t\t\t\t};\n\t\t\t}, {on: 1});\n\t\t\treturn gun;\n\t\t}\n\t\tfunction none(gun,opt,chain){\n\t\t\tGun.log.once(\"valonce\", \"Chainable val is experimental, its behavior and API may change moving forward. Please play with it and report bugs and ideas on how to improve it.\");\n\t\t\t(chain = gun.chain())._.nix = gun.once(function(data, key){ chain._.on('in', this._) });\n\t\t\tchain._.lex = gun._.lex; // TODO: Better approach in future? This is quick for now.\n\t\t\treturn chain;\n\t\t}\n\n\t\tGun.chain.off = function(){\n\t\t\t// make off more aggressive. Warning, it might backfire!\n\t\t\tvar gun = this, at = gun._, tmp;\n\t\t\tvar cat = at.back;\n\t\t\tif(!cat){ return }\n\t\t\tat.ack = 0; // so can resubscribe.\n\t\t\tif(tmp = cat.next){\n\t\t\t\tif(tmp[at.get]){\n\t\t\t\t\tdelete tmp[at.get];\n\t\t\t\t} else {\n\n\t\t\t\t}\n\t\t\t}\n\t\t\t// TODO: delete cat.one[map.id]?\n\t\t\tif(tmp = cat.ask){\n\t\t\t\tdelete tmp[at.get];\n\t\t\t}\n\t\t\tif(tmp = cat.put){\n\t\t\t\tdelete tmp[at.get];\n\t\t\t}\n\t\t\tif(tmp = at.soul){\n\t\t\t\tdelete cat.root.graph[tmp];\n\t\t\t}\n\t\t\tif(tmp = at.map){\n\t\t\t\tObject.keys(tmp).forEach(function(i,at){ at = tmp[i]; //obj_map(tmp, function(at){\n\t\t\t\t\tif(at.link){\n\t\t\t\t\t\tcat.root.$.get(at.link).off();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tif(tmp = at.next){\n\t\t\t\tObject.keys(tmp).forEach(function(i,neat){ neat = tmp[i]; //obj_map(tmp, function(neat){\n\t\t\t\t\tneat.$.off();\n\t\t\t\t});\n\t\t\t}\n\t\t\tat.on('off', {});\n\t\t\treturn gun;\n\t\t}\n\t\tvar empty = {}, noop = function(){}, u;\n\t})(USE, './on');\n\n\t;USE(function(module){\n\t\tvar Gun = USE('./index'), next = Gun.chain.get.next;\n\t\tGun.chain.get.next = function(gun, lex){ var tmp;\n\t\t\tif(!Object.plain(lex)){ return (next||noop)(gun, lex) }\n\t\t\tif(tmp = ((tmp = lex['#'])||'')['='] || tmp){ return gun.get(tmp) }\n\t\t\t(tmp = gun.chain()._).lex = lex; // LEX!\n\t\t\tgun.on('in', function(eve){\n\t\t\t\tif(String.match(eve.get|| (eve.put||'')['.'], lex['.'] || lex['#'] || lex)){\n\t\t\t\t\ttmp.on('in', eve);\n\t\t\t\t}\n\t\t\t\tthis.to.next(eve);\n\t\t\t});\n\t\t\treturn tmp.$;\n\t\t}\n\t\tGun.chain.map = function(cb, opt, t){\n\t\t\tvar gun = this, cat = gun._, lex, chain;\n\t\t\tif(Object.plain(cb)){ lex = cb['.']? cb : {'.': cb}; cb = u }\n\t\t\tif(!cb){\n\t\t\t\tif(chain = cat.each){ return chain }\n\t\t\t\t(cat.each = chain = gun.chain())._.lex = lex || chain._.lex || cat.lex;\n\t\t\t\tchain._.nix = gun.back('nix');\n\t\t\t\tgun.on('in', map, chain._);\n\t\t\t\treturn chain;\n\t\t\t}\n\t\t\tGun.log.once(\"mapfn\", \"Map functions are experimental, their behavior and API may change moving forward. Please play with it and report bugs and ideas on how to improve it.\");\n\t\t\tchain = gun.chain();\n\t\t\tgun.map().on(function(data, key, msg, eve){\n\t\t\t\tvar next = (cb||noop).call(this, data, key, msg, eve);\n\t\t\t\tif(u === next){ return }\n\t\t\t\tif(data === next){ return chain._.on('in', msg) }\n\t\t\t\tif(Gun.is(next)){ return chain._.on('in', next._) }\n\t\t\t\tvar tmp = {}; Object.keys(msg.put).forEach(function(k){ tmp[k] = msg.put[k] }, tmp); tmp['='] = next; \n\t\t\t\tchain._.on('in', {get: key, put: tmp});\n\t\t\t});\n\t\t\treturn chain;\n\t\t}\n\t\tfunction map(msg){ this.to.next(msg);\n\t\t\tvar cat = this.as, gun = msg.$, at = gun._, put = msg.put, tmp;\n\t\t\tif(!at.soul && !msg.$$){ return } // this line took hundreds of tries to figure out. It only works if core checks to filter out above chains during link tho. This says \"only bother to map on a node\" for this layer of the chain. If something is not a node, map should not work.\n\t\t\tif((tmp = cat.lex) && !String.match(msg.get|| (put||'')['.'], tmp['.'] || tmp['#'] || tmp)){ return }\n\t\t\tGun.on.link(msg, cat);\n\t\t}\n\t\tvar noop = function(){}, event = {stun: noop, off: noop}, u;\n\t})(USE, './map');\n\n\t;USE(function(module){\n\t\tvar Gun = USE('./index');\n\t\tGun.chain.set = function(item, cb, opt){\n\t\t\tvar gun = this, root = gun.back(-1), soul, tmp;\n\t\t\tcb = cb || function(){};\n\t\t\topt = opt || {}; opt.item = opt.item || item;\n\t\t\tif(soul = ((item||'')._||'')['#']){ (item = {})['#'] = soul } // check if node, make link.\n\t\t\tif('string' == typeof (tmp = Gun.valid(item))){ return gun.get(soul = tmp).put(item, cb, opt) } // check if link\n\t\t\tif(!Gun.is(item)){\n\t\t\t\tif(Object.plain(item)){\n\t\t\t\t\titem = root.get(soul = gun.back('opt.uuid')()).put(item);\n\t\t\t\t}\n\t\t\t\treturn gun.get(soul || root.back('opt.uuid')(7)).put(item, cb, opt);\n\t\t\t}\n\t\t\tgun.put(function(go){\n\t\t\t\titem.get(function(soul, o, msg){ // TODO: BUG! We no longer have this option? & go error not handled?\n\t\t\t\t\tif(!soul){ return cb.call(gun, {err: Gun.log('Only a node can be linked! Not \"' + msg.put + '\"!')}) }\n\t\t\t\t\t(tmp = {})[soul] = {'#': soul}; go(tmp);\n\t\t\t\t},true);\n\t\t\t})\n\t\t\treturn item;\n\t\t}\n\t})(USE, './set');\n\n\t;USE(function(module){\n\t\tUSE('./shim');\n\n\t\tvar noop = function(){}\n\t\tvar parse = JSON.parseAsync || function(t,cb,r){ var u, d = +new Date; try{ cb(u, JSON.parse(t,r), json.sucks(+new Date - d)) }catch(e){ cb(e) } }\n\t\tvar json = JSON.stringifyAsync || function(v,cb,r,s){ var u, d = +new Date; try{ cb(u, JSON.stringify(v,r,s), json.sucks(+new Date - d)) }catch(e){ cb(e) } }\n\t\tjson.sucks = function(d){ if(d > 99){ console.log(\"Warning: JSON blocking CPU detected. Add `gun/lib/yson.js` to fix.\"); json.sucks = noop } }\n\n\t\tfunction Mesh(root){\n\t\t\tvar mesh = function(){};\n\t\t\tvar opt = root.opt || {};\n\t\t\topt.log = opt.log || console.log;\n\t\t\topt.gap = opt.gap || opt.wait || 0;\n\t\t\topt.max = opt.max || (opt.memory? (opt.memory * 999 * 999) : 300000000) * 0.3;\n\t\t\topt.pack = opt.pack || (opt.max * 0.01 * 0.01);\n\t\t\topt.puff = opt.puff || 9; // IDEA: do a start/end benchmark, divide ops/result.\n\t\t\tvar puff = setTimeout.turn || setTimeout;\n\n\t\t\tvar dup = root.dup, dup_check = dup.check, dup_track = dup.track;\n\n\t\t\tvar ST = +new Date, LT = ST;\n\n\t\t\tvar hear = mesh.hear = function(raw, peer){\n\t\t\t\tif(!raw){ return }\n\t\t\t\tif(opt.max <= raw.length){ return mesh.say({dam: '!', err: \"Message too big!\"}, peer) }\n\t\t\t\tif(mesh === this){\n\t\t\t\t\t/*if('string' == typeof raw){ try{\n\t\t\t\t\t\tvar stat = console.STAT || {};\n\t\t\t\t\t\t//console.log('HEAR:', peer.id, (raw||'').slice(0,250), ((raw||'').length / 1024 / 1024).toFixed(4));\n\t\t\t\t\t\t\n\t\t\t\t\t\t//console.log(setTimeout.turn.s.length, 'stacks', parseFloat((-(LT - (LT = +new Date))/1000).toFixed(3)), 'sec', parseFloat(((LT-ST)/1000 / 60).toFixed(1)), 'up', stat.peers||0, 'peers', stat.has||0, 'has', stat.memhused||0, stat.memused||0, stat.memax||0, 'heap mem max');\n\t\t\t\t\t}catch(e){ console.log('DBG err', e) }}*/\n\t\t\t\t\thear.d += raw.length||0 ; ++hear.c } // STATS!\n\t\t\t\tvar S = peer.SH = +new Date;\n\t\t\t\tvar tmp = raw[0], msg;\n\t\t\t\t//raw && raw.slice && console.log(\"hear:\", ((peer.wire||'').headers||'').origin, raw.length, raw.slice && raw.slice(0,50)); //tc-iamunique-tc-package-ds1\n\t\t\t\tif('[' === tmp){\n\t\t\t\t\tparse(raw, function(err, msg){\n\t\t\t\t\t\tif(err || !msg){ return mesh.say({dam: '!', err: \"DAM JSON parse error.\"}, peer) }\n\t\t\t\t\t\tconsole.STAT && console.STAT(+new Date, msg.length, '# on hear batch');\n\t\t\t\t\t\tvar P = opt.puff;\n\t\t\t\t\t\t(function go(){\n\t\t\t\t\t\t\tvar S = +new Date;\n\t\t\t\t\t\t\tvar i = 0, m; while(i < P && (m = msg[i++])){ mesh.hear(m, peer) }\n\t\t\t\t\t\t\tmsg = msg.slice(i); // slicing after is faster than shifting during.\n\t\t\t\t\t\t\tconsole.STAT && console.STAT(S, +new Date - S, 'hear loop');\n\t\t\t\t\t\t\tflush(peer); // force send all synchronously batched acks.\n\t\t\t\t\t\t\tif(!msg.length){ return }\n\t\t\t\t\t\t\tpuff(go, 0);\n\t\t\t\t\t\t}());\n\t\t\t\t\t});\n\t\t\t\t\traw = ''; // \n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif('{' === tmp || ((raw['#'] || Object.plain(raw)) && (msg = raw))){\n\t\t\t\t\tif(msg){ return hear.one(msg, peer, S) }\n\t\t\t\t\tparse(raw, function(err, msg){\n\t\t\t\t\t\tif(err || !msg){ return mesh.say({dam: '!', err: \"DAM JSON parse error.\"}, peer) }\n\t\t\t\t\t\thear.one(msg, peer, S);\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\thear.one = function(msg, peer, S){ // S here is temporary! Undo.\n\t\t\t\tvar id, hash, tmp, ash, DBG;\n\t\t\t\tif(msg.DBG){ msg.DBG = DBG = {DBG: msg.DBG} }\n\t\t\t\tDBG && (DBG.h = S);\n\t\t\t\tDBG && (DBG.hp = +new Date);\n\t\t\t\tif(!(id = msg['#'])){ id = msg['#'] = String.random(9) }\n\t\t\t\tif(tmp = dup_check(id)){ return }\n\t\t\t\t// DAM logic:\n\t\t\t\tif(!(hash = msg['##']) && false && 0){} // disable hashing for now // TODO: impose warning/penalty instead (?)\n\t\t\t\tif(hash && (tmp = msg['@'] || (msg.get && id)) && dup.check(ash = tmp+hash)){ return } // Imagine A <-> B <=> (C & D), C & D reply with same ACK but have different IDs, B can use hash to dedup. Or if a GET has a hash already, we shouldn't ACK if same.\n\t\t\t\t(msg._ = function(){}).via = mesh.leap = peer;\n\t\t\t\tif((tmp = msg['><']) && 'string' == typeof tmp){ tmp.slice(0,99).split(',').forEach(function(k){ this[k] = 1 }, (msg._).yo = {}) } // Peers already sent to, do not resend.\n\t\t\t\t// DAM ^\n\t\t\t\tif(tmp = msg.dam){\n\t\t\t\t\tif(tmp = mesh.hear[tmp]){\n\t\t\t\t\t\ttmp(msg, peer, root);\n\t\t\t\t\t}\n\t\t\t\t\tdup_track(id);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar S = +new Date;\n\t\t\t\tDBG && (DBG.is = S); peer.SI = id;\n\t\t\t\troot.on('in', mesh.last = msg);\n\t\t\t\t//ECHO = msg.put || ECHO; !(msg.ok !== -3740) && mesh.say({ok: -3740, put: ECHO, '@': msg['#']}, peer);\n\t\t\t\tDBG && (DBG.hd = +new Date);\n\t\t\t\tconsole.STAT && console.STAT(S, +new Date - S, msg.get? 'msg get' : msg.put? 'msg put' : 'msg');\n\t\t\t\t(tmp = dup_track(id)).via = peer; // don't dedup message ID till after, cause GUN has internal dedup check.\n\t\t\t\tif(msg.get){ tmp.it = msg }\n\t\t\t\tif(ash){ dup_track(ash) } //dup.track(tmp+hash, true).it = it(msg);\n\t\t\t\tmesh.leap = mesh.last = null; // warning! mesh.leap could be buggy.\n\t\t\t}\n\t\t\tvar tomap = function(k,i,m){m(k,true)};\n\t\t\thear.c = hear.d = 0;\n\n\t\t\t;(function(){\n\t\t\t\tvar SMIA = 0;\n\t\t\t\tvar loop;\n\t\t\t\tmesh.hash = function(msg, peer){ var h, s, t;\n\t\t\t\t\tvar S = +new Date;\n\t\t\t\t\tjson(msg.put, function hash(err, text){\n\t\t\t\t\t\tvar ss = (s || (s = t = text||'')).slice(0, 32768); // 1024 * 32\n\t\t\t\t\t  h = String.hash(ss, h); s = s.slice(32768);\n\t\t\t\t\t  if(s){ puff(hash, 0); return }\n\t\t\t\t\t\tconsole.STAT && console.STAT(S, +new Date - S, 'say json+hash');\n\t\t\t\t\t  msg._.$put = t;\n\t\t\t\t\t  msg['##'] = h;\n\t\t\t\t\t  mesh.say(msg, peer);\n\t\t\t\t\t  delete msg._.$put;\n\t\t\t\t\t}, sort);\n\t\t\t\t}\n\t\t\t\tfunction sort(k, v){ var tmp;\n\t\t\t\t\tif(!(v instanceof Object)){ return v }\n\t\t\t\t\tObject.keys(v).sort().forEach(sorta, {to: tmp = {}, on: v});\n\t\t\t\t\treturn tmp;\n\t\t\t\t} function sorta(k){ this.to[k] = this.on[k] }\n\n\t\t\t\tvar say = mesh.say = function(msg, peer){ var tmp;\n\t\t\t\t\tif((tmp = this) && (tmp = tmp.to) && tmp.next){ tmp.next(msg) } // compatible with middleware adapters.\n\t\t\t\t\tif(!msg){ return false }\n\t\t\t\t\tvar id, hash, raw, ack = msg['@'];\n//if(opt.super && (!ack || !msg.put)){ return } // TODO: MANHATTAN STUB //OBVIOUSLY BUG! But squelch relay. // :( get only is 100%+ CPU usage :(\n\t\t\t\t\tvar meta = msg._||(msg._=function(){});\n\t\t\t\t\tvar DBG = msg.DBG, S = +new Date; meta.y = meta.y || S; if(!peer){ DBG && (DBG.y = S) }\n\t\t\t\t\tif(!(id = msg['#'])){ id = msg['#'] = String.random(9) }\n\t\t\t\t\t!loop && dup_track(id);//.it = it(msg); // track for 9 seconds, default. Earth<->Mars would need more! // always track, maybe move this to the 'after' logic if we split function.\n\t\t\t\t\tif(msg.put && (msg.err || (dup.s[id]||'').err)){ return false } // TODO: in theory we should not be able to stun a message, but for now going to check if it can help network performance preventing invalid data to relay.\n\t\t\t\t\tif(!(hash = msg['##']) && u !== msg.put && !meta.via && ack){ mesh.hash(msg, peer); return } // TODO: Should broadcasts be hashed?\n\t\t\t\t\tif(!peer && ack){ peer = ((tmp = dup.s[ack]) && (tmp.via || ((tmp = tmp.it) && (tmp = tmp._) && tmp.via))) || ((tmp = mesh.last) && ack === tmp['#'] && mesh.leap) } // warning! mesh.leap could be buggy! mesh last check reduces this.\n\t\t\t\t\tif(!peer && ack){ // still no peer, then ack daisy chain lost.\n\t\t\t\t\t\tif(dup.s[ack]){ return } // in dups but no peer hints that this was ack to self, ignore.\n\t\t\t\t\t\tconsole.STAT && console.STAT(+new Date, ++SMIA, 'total no peer to ack to');\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} // TODO: Temporary? If ack via trace has been lost, acks will go to all peers, which trashes browser bandwidth. Not relaying the ack will force sender to ask for ack again. Note, this is technically wrong for mesh behavior.\n\t\t\t\t\tif(!peer && mesh.way){ return mesh.way(msg) }\n\t\t\t\t\tDBG && (DBG.yh = +new Date);\n\t\t\t\t\tif(!(raw = meta.raw)){ mesh.raw(msg, peer); return }\n\t\t\t\t\tDBG && (DBG.yr = +new Date);\n\t\t\t\t\tif(!peer || !peer.id){\n\t\t\t\t\t\tif(!Object.plain(peer || opt.peers)){ return false }\n\t\t\t\t\t\tvar S = +new Date;\n\t\t\t\t\t\tvar P = opt.puff, ps = opt.peers, pl = Object.keys(peer || opt.peers || {}); // TODO: .keys( is slow\n\t\t\t\t\t\tconsole.STAT && console.STAT(S, +new Date - S, 'peer keys');\n\t\t\t\t\t\t;(function go(){\n\t\t\t\t\t\t\tvar S = +new Date;\n\t\t\t\t\t\t\t//Type.obj.map(peer || opt.peers, each); // in case peer is a peer list.\n\t\t\t\t\t\t\tloop = 1; var wr = meta.raw; meta.raw = raw; // quick perf hack\n\t\t\t\t\t\t\tvar i = 0, p; while(i < 9 && (p = (pl||'')[i++])){\n\t\t\t\t\t\t\t\tif(!(p = ps[p])){ continue }\n\t\t\t\t\t\t\t\tmesh.say(msg, p);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmeta.raw = wr; loop = 0;\n\t\t\t\t\t\t\tpl = pl.slice(i); // slicing after is faster than shifting during.\n\t\t\t\t\t\t\tconsole.STAT && console.STAT(S, +new Date - S, 'say loop');\n\t\t\t\t\t\t\tif(!pl.length){ return }\n\t\t\t\t\t\t\tpuff(go, 0);\n\t\t\t\t\t\t\tack && dup_track(ack); // keep for later\n\t\t\t\t\t\t}());\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// TODO: PERF: consider splitting function here, so say loops do less work.\n\t\t\t\t\tif(!peer.wire && mesh.wire){ mesh.wire(peer) }\n\t\t\t\t\tif(id === peer.last){ return } peer.last = id;  // was it just sent?\n\t\t\t\t\tif(peer === meta.via){ return false } // don't send back to self.\n\t\t\t\t\tif((tmp = meta.yo) && (tmp[peer.url] || tmp[peer.pid] || tmp[peer.id]) /*&& !o*/){ return false }\n\t\t\t\t\tconsole.STAT && console.STAT(S, ((DBG||meta).yp = +new Date) - (meta.y || S), 'say prep');\n\t\t\t\t\t!loop && ack && dup_track(ack); // streaming long responses needs to keep alive the ack.\n\t\t\t\t\tif(peer.batch){\n\t\t\t\t\t\tpeer.tail = (tmp = peer.tail || 0) + raw.length;\n\t\t\t\t\t\tif(peer.tail <= opt.pack){\n\t\t\t\t\t\t\tpeer.batch += (tmp?',':'')+raw;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tflush(peer);\n\t\t\t\t\t}\n\t\t\t\t\tpeer.batch = '['; // Prevents double JSON!\n\t\t\t\t\tvar ST = +new Date;\n\t\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t\tconsole.STAT && console.STAT(ST, +new Date - ST, '0ms TO');\n\t\t\t\t\t\tflush(peer);\n\t\t\t\t\t}, opt.gap); // TODO: queuing/batching might be bad for low-latency video game performance! Allow opt out?\n\t\t\t\t\tsend(raw, peer);\n\t\t\t\t\tconsole.STAT && (ack === peer.SI) && console.STAT(S, +new Date - peer.SH, 'say ack');\n\t\t\t\t}\n\t\t\t\tmesh.say.c = mesh.say.d = 0;\n\t\t\t\t// TODO: this caused a out-of-memory crash!\n\t\t\t\tmesh.raw = function(msg, peer){ // TODO: Clean this up / delete it / move logic out!\n\t\t\t\t\tif(!msg){ return '' }\n\t\t\t\t\tvar meta = (msg._) || {}, put, tmp;\n\t\t\t\t\tif(tmp = meta.raw){ return tmp }\n\t\t\t\t\tif('string' == typeof msg){ return msg }\n\t\t\t\t\tvar hash = msg['##'], ack = msg['@'];\n\t\t\t\t\tif(hash && ack){\n\t\t\t\t\t\tif(!meta.via && dup_check(ack+hash)){ return false } // for our own out messages, memory & storage may ack the same thing, so dedup that. Tho if via another peer, we already tracked it upon hearing, so this will always trigger false positives, so don't do that!\n\t\t\t\t\t\tif((tmp = (dup.s[ack]||'').it) || ((tmp = mesh.last) && ack === tmp['#'])){\n\t\t\t\t\t\t\tif(hash === tmp['##']){ return false } // if ask has a matching hash, acking is optional.\n\t\t\t\t\t\t\tif(!tmp['##']){ tmp['##'] = hash } // if none, add our hash to ask so anyone we relay to can dedup. // NOTE: May only check against 1st ack chunk, 2nd+ won't know and still stream back to relaying peers which may then dedup. Any way to fix this wasted bandwidth? I guess force rate limiting breaking change, that asking peer has to ask for next lexical chunk.\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!msg.dam){\n\t\t\t\t\t\tvar i = 0, to = []; tmp = opt.peers;\n\t\t\t\t\t\tfor(var k in tmp){ var p = tmp[k]; // TODO: Make it up peers instead!\n\t\t\t\t\t\t\tto.push(p.url || p.pid || p.id);\n\t\t\t\t\t\t\tif(++i > 6){ break }\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i > 1){ msg['><'] = to.join() } // TODO: BUG! This gets set regardless of peers sent to! Detect?\n\t\t\t\t\t}\n\t\t\t\t\tif(put = meta.$put){\n\t\t\t\t\t\ttmp = {}; Object.keys(msg).forEach(function(k){ tmp[k] = msg[k] });\n\t\t\t\t\t\ttmp.put = ':])([:';\n\t\t\t\t\t\tjson(tmp, function(err, raw){\n\t\t\t\t\t\t\tif(err){ return } // TODO: Handle!!\n\t\t\t\t\t\t\tvar S = +new Date;\n\t\t\t\t\t\t\ttmp = raw.indexOf('\"put\":\":])([:\"');\n\t\t\t\t\t\t\tres(u, raw = raw.slice(0, tmp+6) + put + raw.slice(tmp + 14));\n\t\t\t\t\t\t\tconsole.STAT && console.STAT(S, +new Date - S, 'say slice');\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tjson(msg, res);\n\t\t\t\t\tfunction res(err, raw){\n\t\t\t\t\t\tif(err){ return } // TODO: Handle!!\n\t\t\t\t\t\tmeta.raw = raw; //if(meta && (raw||'').length < (999 * 99)){ meta.raw = raw } // HNPERF: If string too big, don't keep in memory.\n\t\t\t\t\t\tmesh.say(msg, peer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}());\n\n\t\t\tfunction flush(peer){\n\t\t\t\tvar tmp = peer.batch, t = 'string' == typeof tmp, l;\n\t\t\t\tif(t){ tmp += ']' }// TODO: Prevent double JSON!\n\t\t\t\tpeer.batch = peer.tail = null;\n\t\t\t\tif(!tmp){ return }\n\t\t\t\tif(t? 3 > tmp.length : !tmp.length){ return } // TODO: ^\n\t\t\t\tif(!t){try{tmp = (1 === tmp.length? tmp[0] : JSON.stringify(tmp));\n\t\t\t\t}catch(e){return opt.log('DAM JSON stringify error', e)}}\n\t\t\t\tif(!tmp){ return }\n\t\t\t\tsend(tmp, peer);\n\t\t\t}\n\t\t\t// for now - find better place later.\n\t\t\tfunction send(raw, peer){ try{\n\t\t\t\tvar wire = peer.wire;\n\t\t\t\tif(peer.say){\n\t\t\t\t\tpeer.say(raw);\n\t\t\t\t} else\n\t\t\t\tif(wire.send){\n\t\t\t\t\twire.send(raw);\n\t\t\t\t}\n\t\t\t\tmesh.say.d += raw.length||0; ++mesh.say.c; // STATS!\n\t\t\t}catch(e){\n\t\t\t\t(peer.queue = peer.queue || []).push(raw);\n\t\t\t}}\n\n\t\t\tmesh.hi = function(peer){\n\t\t\t\tvar wire = peer.wire, tmp;\n\t\t\t\tif(!wire){ mesh.wire((peer.length && {url: peer}) || peer); return }\n\t\t\t\tif(peer.id){\n\t\t\t\t\topt.peers[peer.url || peer.id] = peer;\n\t\t\t\t} else {\n\t\t\t\t\ttmp = peer.id = peer.id || String.random(9);\n\t\t\t\t\tmesh.say({dam: '?', pid: root.opt.pid}, opt.peers[tmp] = peer);\n\t\t\t\t\tdelete dup.s[peer.last]; // IMPORTANT: see https://gun.eco/docs/DAM#self\n\t\t\t\t}\n\t\t\t\tpeer.met = peer.met || +(new Date);\n\t\t\t\tif(!wire.hied){ root.on(wire.hied = 'hi', peer) }\n\t\t\t\t// @rogowski I need this here by default for now to fix go1dfish's bug\n\t\t\t\ttmp = peer.queue; peer.queue = [];\n\t\t\t\tsetTimeout.each(tmp||[],function(msg){\n\t\t\t\t\tsend(msg, peer);\n\t\t\t\t},0,9);\n\t\t\t\t//Type.obj.native && Type.obj.native(); // dirty place to check if other JS polluted.\n\t\t\t}\n\t\t\tmesh.bye = function(peer){\n\t\t\t\troot.on('bye', peer);\n\t\t\t\tvar tmp = +(new Date); tmp = (tmp - (peer.met||tmp));\n\t\t\t\tmesh.bye.time = ((mesh.bye.time || tmp) + tmp) / 2;\n\t\t\t}\n\t\t\tmesh.hear['!'] = function(msg, peer){ opt.log('Error:', msg.err) }\n\t\t\tmesh.hear['?'] = function(msg, peer){\n\t\t\t\tif(msg.pid){\n\t\t\t\t\tif(!peer.pid){ peer.pid = msg.pid }\n\t\t\t\t\tif(msg['@']){ return }\n\t\t\t\t}\n\t\t\t\tmesh.say({dam: '?', pid: opt.pid, '@': msg['#']}, peer);\n\t\t\t\tdelete dup.s[peer.last]; // IMPORTANT: see https://gun.eco/docs/DAM#self\n\t\t\t}\n\n\t\t\troot.on('create', function(root){\n\t\t\t\troot.opt.pid = root.opt.pid || String.random(9);\n\t\t\t\tthis.to.next(root);\n\t\t\t\troot.on('out', mesh.say);\n\t\t\t});\n\n\t\t\troot.on('bye', function(peer, tmp){\n\t\t\t\tpeer = opt.peers[peer.id || peer] || peer;\n\t\t\t\tthis.to.next(peer);\n\t\t\t\tpeer.bye? peer.bye() : (tmp = peer.wire) && tmp.close && tmp.close();\n\t\t\t\tdelete opt.peers[peer.id];\n\t\t\t\tpeer.wire = null;\n\t\t\t});\n\n\t\t\tvar gets = {};\n\t\t\troot.on('bye', function(peer, tmp){ this.to.next(peer);\n\t\t\t\tif(tmp = console.STAT){ tmp.peers = (tmp.peers || 0) - 1; }\n\t\t\t\tif(!(tmp = peer.url)){ return } gets[tmp] = true;\n\t\t\t\tsetTimeout(function(){ delete gets[tmp] },opt.lack || 9000);\n\t\t\t});\n\t\t\troot.on('hi', function(peer, tmp){ this.to.next(peer);\n\t\t\t\tif(tmp = console.STAT){ tmp.peers = (tmp.peers || 0) + 1 }\n\t\t\t\tif(!(tmp = peer.url) || !gets[tmp]){ return } delete gets[tmp];\n\t\t\t\tif(opt.super){ return } // temporary (?) until we have better fix/solution?\n\t\t\t\tsetTimeout.each(Object.keys(root.next), function(soul){ var node = root.next[soul]; // TODO: .keys( is slow\n\t\t\t\t\ttmp = {}; tmp[soul] = root.graph[soul]; tmp = String.hash(tmp); // TODO: BUG! This is broken.\n\t\t\t\t\tmesh.say({'##': tmp, get: {'#': soul}}, peer);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\treturn mesh;\n\t\t}\n\t  var empty = {}, ok = true, u;\n\n\t  try{ module.exports = Mesh }catch(e){}\n\n\t})(USE, './mesh');\n\n\t;USE(function(module){\n\t\tvar Gun = USE('../index');\n\t\tGun.Mesh = USE('./mesh');\n\n\t\t// TODO: resync upon reconnect online/offline\n\t\t//window.ononline = window.onoffline = function(){ console.log('online?', navigator.onLine) }\n\n\t\tGun.on('opt', function(root){\n\t\t\tthis.to.next(root);\n\t\t\tif(root.once){ return }\n\t\t\tvar opt = root.opt;\n\t\t\tif(false === opt.WebSocket){ return }\n\n\t\t\tvar env = Gun.window || {};\n\t\t\tvar websocket = opt.WebSocket || env.WebSocket || env.webkitWebSocket || env.mozWebSocket;\n\t\t\tif(!websocket){ return }\n\t\t\topt.WebSocket = websocket;\n\n\t\t\tvar mesh = opt.mesh = opt.mesh || Gun.Mesh(root);\n\n\t\t\tvar wire = mesh.wire || opt.wire;\n\t\t\tmesh.wire = opt.wire = open;\n\t\t\tfunction open(peer){ try{\n\t\t\t\tif(!peer || !peer.url){ return wire && wire(peer) }\n\t\t\t\tvar url = peer.url.replace(/^http/, 'ws');\n\t\t\t\tvar wire = peer.wire = new opt.WebSocket(url);\n\t\t\t\twire.onclose = function(){\n\t\t\t\t\topt.mesh.bye(peer);\n\t\t\t\t\treconnect(peer);\n\t\t\t\t};\n\t\t\t\twire.onerror = function(error){\n\t\t\t\t\treconnect(peer);\n\t\t\t\t};\n\t\t\t\twire.onopen = function(){\n\t\t\t\t\topt.mesh.hi(peer);\n\t\t\t\t}\n\t\t\t\twire.onmessage = function(msg){\n\t\t\t\t\tif(!msg){ return }\n\t\t\t\t\topt.mesh.hear(msg.data || msg, peer);\n\t\t\t\t};\n\t\t\t\treturn wire;\n\t\t\t}catch(e){}}\n\n\t\t\tsetTimeout(function(){ !opt.super && root.on('out', {dam:'hi'}) },1); // it can take a while to open a socket, so maybe no longer lazy load for perf reasons?\n\n\t\t\tvar wait = 2 * 999;\n\t\t\tfunction reconnect(peer){\n\t\t\t\tclearTimeout(peer.defer);\n\t\t\t\tif(!opt.peers[peer.url]){ return }\n\t\t\t\tif(doc && peer.retry <= 0){ return }\n\t\t\t\tpeer.retry = (peer.retry || opt.retry+1 || 60) - ((-peer.tried + (peer.tried = +new Date) < wait*4)?1:0);\n\t\t\t\tpeer.defer = setTimeout(function to(){\n\t\t\t\t\tif(doc && doc.hidden){ return setTimeout(to,wait) }\n\t\t\t\t\topen(peer);\n\t\t\t\t}, wait);\n\t\t\t}\n\t\t\tvar doc = (''+u !== typeof document) && document;\n\t\t});\n\t\tvar noop = function(){}, u;\n\t})(USE, './websocket');\n\n\t;USE(function(module){\n\t\tif(typeof Gun === 'undefined'){ return }\n\n\t\tvar noop = function(){}, store, u;\n\t\ttry{store = (Gun.window||noop).localStorage}catch(e){}\n\t\tif(!store){\n\t\t\tGun.log(\"Warning: No localStorage exists to persist data to!\");\n\t\t\tstore = {setItem: function(k,v){this[k]=v}, removeItem: function(k){delete this[k]}, getItem: function(k){return this[k]}};\n\t\t}\n\n\t\tvar parse = JSON.parseAsync || function(t,cb,r){ var u; try{ cb(u, JSON.parse(t,r)) }catch(e){ cb(e) } }\n\t\tvar json = JSON.stringifyAsync || function(v,cb,r,s){ var u; try{ cb(u, JSON.stringify(v,r,s)) }catch(e){ cb(e) } }\n\n\t\tGun.on('create', function lg(root){\n\t\t\tthis.to.next(root);\n\t\t\tvar opt = root.opt, graph = root.graph, acks = [], disk, to, size, stop;\n\t\t\tif(false === opt.localStorage){ return }\n\t\t\topt.prefix = opt.file || 'gun/';\n\t\t\ttry{ disk = lg[opt.prefix] = lg[opt.prefix] || JSON.parse(size = store.getItem(opt.prefix)) || {}; // TODO: Perf! This will block, should we care, since limited to 5MB anyways?\n\t\t\t}catch(e){ disk = lg[opt.prefix] = {}; }\n\t\t\tsize = (size||'').length;\n\n\t\t\troot.on('get', function(msg){\n\t\t\t\tthis.to.next(msg);\n\t\t\t\tvar lex = msg.get, soul, data, tmp, u;\n\t\t\t\tif(!lex || !(soul = lex['#'])){ return }\n\t\t\t\tdata = disk[soul] || u;\n\t\t\t\tif(data && (tmp = lex['.']) && !Object.plain(tmp)){ // pluck!\n\t\t\t\t\tdata = Gun.state.ify({}, tmp, Gun.state.is(data, tmp), data[tmp], soul);\n\t\t\t\t}\n\t\t\t\t//if(data){ (tmp = {})[soul] = data } // back into a graph.\n\t\t\t\t//setTimeout(function(){\n\t\t\t\tGun.on.get.ack(msg, data); //root.on('in', {'@': msg['#'], put: tmp, lS:1});// || root.$});\n\t\t\t\t//}, Math.random() * 10); // FOR TESTING PURPOSES!\n\t\t\t});\n\n\t\t\troot.on('put', function(msg){\n\t\t\t\tthis.to.next(msg); // remember to call next middleware adapter\n\t\t\t\tvar put = msg.put, soul = put['#'], key = put['.'], id = msg['#'], tmp; // pull data off wire envelope\n\t\t\t\tdisk[soul] = Gun.state.ify(disk[soul], key, put['>'], put[':'], soul); // merge into disk object\n\t\t\t\tif(stop && size > (4999880)){ root.on('in', {'@': id, err: \"localStorage max!\"}); return; }\n\t\t\t\tif(!msg['@']){ acks.push(id) } // then ack any non-ack write. // TODO: use batch id.\n\t\t\t\tif(to){ return }\n\t\t\t\tto = setTimeout(flush, 9+(size / 333)); // 0.1MB = 0.3s, 5MB = 15s \n\t\t\t});\n\t\t\tfunction flush(){\n\t\t\t\tif(!acks.length && ((setTimeout.turn||'').s||'').length){ setTimeout(flush,99); return; } // defer if \"busy\" && no saves.\n\t\t\t\tvar err, ack = acks; clearTimeout(to); to = false; acks = [];\n\t\t\t\tjson(disk, function(err, tmp){\n\t\t\t\t\ttry{!err && store.setItem(opt.prefix, tmp);\n\t\t\t\t\t}catch(e){ err = stop = e || \"localStorage failure\" }\n\t\t\t\t\tif(err){\n\t\t\t\t\t\tGun.log(err + \" Consider using GUN's IndexedDB plugin for RAD for more storage space, https://gun.eco/docs/RAD#install\");\n\t\t\t\t\t\troot.on('localStorage:error', {err: err, get: opt.prefix, put: disk});\n\t\t\t\t\t}\n\t\t\t\t\tsize = tmp.length;\n\n\t\t\t\t\tif(!err && !Object.empty(opt.peers)){ return } // only ack if there are no peers. // Switch this to probabilistic mode\n\t\t\t\t\tsetTimeout.each(ack, function(id){\n\t\t\t\t\t\troot.on('in', {'@': id, err: err, ok: 0}); // localStorage isn't reliable, so make its `ok` code be a low number.\n\t\t\t\t\t},0,99);\n\t\t\t\t})\n\t\t\t}\n\t\t\n\t\t});\n\t})(USE, './localStorage');\n\n}());\n\n/* BELOW IS TEMPORARY FOR OLD INTERNAL COMPATIBILITY, THEY ARE IMMEDIATELY DEPRECATED AND WILL BE REMOVED IN NEXT VERSION */\n;(function(){\n\tvar u;\n\tif(''+u == typeof Gun){ return }\n\tvar DEP = function(n){ console.warn(\"Warning! Deprecated internal utility will break in next version:\", n) }\n\t// Generic javascript utilities.\n\tvar Type = Gun;\n\t//Type.fns = Type.fn = {is: function(fn){ return (!!fn && fn instanceof Function) }}\n\tType.fn = Type.fn || {is: function(fn){ DEP('fn'); return (!!fn && 'function' == typeof fn) }}\n\tType.bi = Type.bi || {is: function(b){ DEP('bi');return (b instanceof Boolean || typeof b == 'boolean') }}\n\tType.num = Type.num || {is: function(n){ DEP('num'); return !list_is(n) && ((n - parseFloat(n) + 1) >= 0 || Infinity === n || -Infinity === n) }}\n\tType.text = Type.text || {is: function(t){ DEP('text'); return (typeof t == 'string') }}\n\tType.text.ify = Type.text.ify || function(t){ DEP('text.ify');\n\t\tif(Type.text.is(t)){ return t }\n\t\tif(typeof JSON !== \"undefined\"){ return JSON.stringify(t) }\n\t\treturn (t && t.toString)? t.toString() : t;\n\t}\n\tType.text.random = Type.text.random || function(l, c){ DEP('text.random');\n\t\tvar s = '';\n\t\tl = l || 24; // you are not going to make a 0 length random number, so no need to check type\n\t\tc = c || '0123456789ABCDEFGHIJKLMNOPQRSTUVWXZabcdefghijklmnopqrstuvwxyz';\n\t\twhile(l > 0){ s += c.charAt(Math.floor(Math.random() * c.length)); l-- }\n\t\treturn s;\n\t}\n\tType.text.match = Type.text.match || function(t, o){ var tmp, u; DEP('text.match');\n\t\tif('string' !== typeof t){ return false }\n\t\tif('string' == typeof o){ o = {'=': o} }\n\t\to = o || {};\n\t\ttmp = (o['='] || o['*'] || o['>'] || o['<']);\n\t\tif(t === tmp){ return true }\n\t\tif(u !== o['=']){ return false }\n\t\ttmp = (o['*'] || o['>'] || o['<']);\n\t\tif(t.slice(0, (tmp||'').length) === tmp){ return true }\n\t\tif(u !== o['*']){ return false }\n\t\tif(u !== o['>'] && u !== o['<']){\n\t\t\treturn (t >= o['>'] && t <= o['<'])? true : false;\n\t\t}\n\t\tif(u !== o['>'] && t >= o['>']){ return true }\n\t\tif(u !== o['<'] && t <= o['<']){ return true }\n\t\treturn false;\n\t}\n\tType.text.hash = Type.text.hash || function(s, c){ // via SO\n\t\tDEP('text.hash');\n\t\tif(typeof s !== 'string'){ return }\n\t  c = c || 0;\n\t  if(!s.length){ return c }\n\t  for(var i=0,l=s.length,n; i<l; ++i){\n\t    n = s.charCodeAt(i);\n\t    c = ((c<<5)-c)+n;\n\t    c |= 0;\n\t  }\n\t  return c;\n\t}\n\tType.list = Type.list || {is: function(l){ DEP('list'); return (l instanceof Array) }}\n\tType.list.slit = Type.list.slit || Array.prototype.slice;\n\tType.list.sort = Type.list.sort || function(k){ // creates a new sort function based off some key\n\t\tDEP('list.sort');\n\t\treturn function(A,B){\n\t\t\tif(!A || !B){ return 0 } A = A[k]; B = B[k];\n\t\t\tif(A < B){ return -1 }else if(A > B){ return 1 }\n\t\t\telse { return 0 }\n\t\t}\n\t}\n\tType.list.map = Type.list.map || function(l, c, _){ DEP('list.map'); return obj_map(l, c, _) }\n\tType.list.index = 1; // change this to 0 if you want non-logical, non-mathematical, non-matrix, non-convenient array notation\n\tType.obj = Type.boj || {is: function(o){ DEP('obj'); return o? (o instanceof Object && o.constructor === Object) || Object.prototype.toString.call(o).match(/^\\[object (\\w+)\\]$/)[1] === 'Object' : false }}\n\tType.obj.put = Type.obj.put || function(o, k, v){ DEP('obj.put'); return (o||{})[k] = v, o }\n\tType.obj.has = Type.obj.has || function(o, k){ DEP('obj.has'); return o && Object.prototype.hasOwnProperty.call(o, k) }\n\tType.obj.del = Type.obj.del || function(o, k){ DEP('obj.del'); \n\t\tif(!o){ return }\n\t\to[k] = null;\n\t\tdelete o[k];\n\t\treturn o;\n\t}\n\tType.obj.as = Type.obj.as || function(o, k, v, u){ DEP('obj.as'); return o[k] = o[k] || (u === v? {} : v) }\n\tType.obj.ify = Type.obj.ify || function(o){ DEP('obj.ify'); \n\t\tif(obj_is(o)){ return o }\n\t\ttry{o = JSON.parse(o);\n\t\t}catch(e){o={}};\n\t\treturn o;\n\t}\n\t;(function(){ var u;\n\t\tfunction map(v,k){\n\t\t\tif(obj_has(this,k) && u !== this[k]){ return }\n\t\t\tthis[k] = v;\n\t\t}\n\t\tType.obj.to = Type.obj.to || function(from, to){ DEP('obj.to'); \n\t\t\tto = to || {};\n\t\t\tobj_map(from, map, to);\n\t\t\treturn to;\n\t\t}\n\t}());\n\tType.obj.copy = Type.obj.copy || function(o){ DEP('obj.copy'); // because http://web.archive.org/web/20140328224025/http://jsperf.com/cloning-an-object/2\n\t\treturn !o? o : JSON.parse(JSON.stringify(o)); // is shockingly faster than anything else, and our data has to be a subset of JSON anyways!\n\t}\n\t;(function(){\n\t\tfunction empty(v,i){ var n = this.n, u;\n\t\t\tif(n && (i === n || (obj_is(n) && obj_has(n, i)))){ return }\n\t\t\tif(u !== i){ return true }\n\t\t}\n\t\tType.obj.empty = Type.obj.empty || function(o, n){ DEP('obj.empty'); \n\t\t\tif(!o){ return true }\n\t\t\treturn obj_map(o,empty,{n:n})? false : true;\n\t\t}\n\t}());\n\t;(function(){\n\t\tfunction t(k,v){\n\t\t\tif(2 === arguments.length){\n\t\t\t\tt.r = t.r || {};\n\t\t\t\tt.r[k] = v;\n\t\t\t\treturn;\n\t\t\t} t.r = t.r || [];\n\t\t\tt.r.push(k);\n\t\t};\n\t\tvar keys = Object.keys, map, u;\n\t\tObject.keys = Object.keys || function(o){ return map(o, function(v,k,t){t(k)}) }\n\t\tType.obj.map = map = Type.obj.map || function(l, c, _){ DEP('obj.map'); \n\t\t\tvar u, i = 0, x, r, ll, lle, f = 'function' == typeof c;\n\t\t\tt.r = u;\n\t\t\tif(keys && obj_is(l)){\n\t\t\t\tll = keys(l); lle = true;\n\t\t\t}\n\t\t\t_ = _ || {};\n\t\t\tif(list_is(l) || ll){\n\t\t\t\tx = (ll || l).length;\n\t\t\t\tfor(;i < x; i++){\n\t\t\t\t\tvar ii = (i + Type.list.index);\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tr = lle? c.call(_, l[ll[i]], ll[i], t) : c.call(_, l[i], ii, t);\n\t\t\t\t\t\tif(r !== u){ return r }\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//if(Type.test.is(c,l[i])){ return ii } // should implement deep equality testing!\n\t\t\t\t\t\tif(c === l[lle? ll[i] : i]){ return ll? ll[i] : ii } // use this for now\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(i in l){\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tif(obj_has(l,i)){\n\t\t\t\t\t\t\tr = _? c.call(_, l[i], i, t) : c(l[i], i, t);\n\t\t\t\t\t\t\tif(r !== u){ return r }\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//if(a.test.is(c,l[i])){ return i } // should implement deep equality testing!\n\t\t\t\t\t\tif(c === l[i]){ return i } // use this for now\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn f? t.r : Type.list.index? 0 : -1;\n\t\t}\n\t}());\n\tType.time = Type.time || {};\n\tType.time.is = Type.time.is || function(t){ DEP('time'); return t? t instanceof Date : (+new Date().getTime()) }\n\n\tvar fn_is = Type.fn.is;\n\tvar list_is = Type.list.is;\n\tvar obj = Type.obj, obj_is = obj.is, obj_has = obj.has, obj_map = obj.map;\n\n\tvar Val = {};\n\tVal.is = function(v){ DEP('val.is'); // Valid values are a subset of JSON: null, binary, number (!Infinity), text, or a soul relation. Arrays need special algorithms to handle concurrency, so they are not supported directly. Use an extension that supports them if needed but research their problems first.\n\t\tif(v === u){ return false }\n\t\tif(v === null){ return true } // \"deletes\", nulling out keys.\n\t\tif(v === Infinity){ return false } // we want this to be, but JSON does not support it, sad face.\n\t\tif(text_is(v) // by \"text\" we mean strings.\n\t\t|| bi_is(v) // by \"binary\" we mean boolean.\n\t\t|| num_is(v)){ // by \"number\" we mean integers or decimals.\n\t\t\treturn true; // simple values are valid.\n\t\t}\n\t\treturn Val.link.is(v) || false; // is the value a soul relation? Then it is valid and return it. If not, everything else remaining is an invalid data type. Custom extensions can be built on top of these primitives to support other types.\n\t}\n\tVal.link = Val.rel = {_: '#'};\n\t;(function(){\n\t\tVal.link.is = function(v){ DEP('val.link.is'); // this defines whether an object is a soul relation or not, they look like this: {'#': 'UUID'}\n\t\t\tif(v && v[rel_] && !v._ && obj_is(v)){ // must be an object.\n\t\t\t\tvar o = {};\n\t\t\t\tobj_map(v, map, o);\n\t\t\t\tif(o.id){ // a valid id was found.\n\t\t\t\t\treturn o.id; // yay! Return it.\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false; // the value was not a valid soul relation.\n\t\t}\n\t\tfunction map(s, k){ var o = this; // map over the object...\n\t\t\tif(o.id){ return o.id = false } // if ID is already defined AND we're still looping through the object, it is considered invalid.\n\t\t\tif(k == rel_ && text_is(s)){ // the key should be '#' and have a text value.\n\t\t\t\to.id = s; // we found the soul!\n\t\t\t} else {\n\t\t\t\treturn o.id = false; // if there exists anything else on the object that isn't the soul, then it is considered invalid.\n\t\t\t}\n\t\t}\n\t}());\n\tVal.link.ify = function(t){ DEP('val.link.ify'); return obj_put({}, rel_, t) } // convert a soul into a relation and return it.\n\tType.obj.has._ = '.';\n\tvar rel_ = Val.link._, u;\n\tvar bi_is = Type.bi.is;\n\tvar num_is = Type.num.is;\n\tvar text_is = Type.text.is;\n\tvar obj = Type.obj, obj_is = obj.is, obj_put = obj.put, obj_map = obj.map;\n\n\tType.val = Type.val || Val;\n\n\tvar Node = {_: '_'};\n\tNode.soul = function(n, o){ DEP('node.soul'); return (n && n._ && n._[o || soul_]) } // convenience function to check to see if there is a soul on a node and return it.\n\tNode.soul.ify = function(n, o){ DEP('node.soul.ify'); // put a soul on an object.\n\t\to = (typeof o === 'string')? {soul: o} : o || {};\n\t\tn = n || {}; // make sure it exists.\n\t\tn._ = n._ || {}; // make sure meta exists.\n\t\tn._[soul_] = o.soul || n._[soul_] || text_random(); // put the soul on it.\n\t\treturn n;\n\t}\n\tNode.soul._ = Val.link._;\n\t;(function(){\n\t\tNode.is = function(n, cb, as){ DEP('node.is'); var s; // checks to see if an object is a valid node.\n\t\t\tif(!obj_is(n)){ return false } // must be an object.\n\t\t\tif(s = Node.soul(n)){ // must have a soul on it.\n\t\t\t\treturn !obj_map(n, map, {as:as,cb:cb,s:s,n:n});\n\t\t\t}\n\t\t\treturn false; // nope! This was not a valid node.\n\t\t}\n\t\tfunction map(v, k){ // we invert this because the way we check for this is via a negation.\n\t\t\tif(k === Node._){ return } // skip over the metadata.\n\t\t\tif(!Val.is(v)){ return true } // it is true that this is an invalid node.\n\t\t\tif(this.cb){ this.cb.call(this.as, v, k, this.n, this.s) } // optionally callback each key/value.\n\t\t}\n\t}());\n\t;(function(){\n\t\tNode.ify = function(obj, o, as){ DEP('node.ify'); // returns a node from a shallow object.\n\t\t\tif(!o){ o = {} }\n\t\t\telse if(typeof o === 'string'){ o = {soul: o} }\n\t\t\telse if('function' == typeof o){ o = {map: o} }\n\t\t\tif(o.map){ o.node = o.map.call(as, obj, u, o.node || {}) }\n\t\t\tif(o.node = Node.soul.ify(o.node || {}, o)){\n\t\t\t\tobj_map(obj, map, {o:o,as:as});\n\t\t\t}\n\t\t\treturn o.node; // This will only be a valid node if the object wasn't already deep!\n\t\t}\n\t\tfunction map(v, k){ var o = this.o, tmp, u; // iterate over each key/value.\n\t\t\tif(o.map){\n\t\t\t\ttmp = o.map.call(this.as, v, ''+k, o.node);\n\t\t\t\tif(u === tmp){\n\t\t\t\t\tobj_del(o.node, k);\n\t\t\t\t} else\n\t\t\t\tif(o.node){ o.node[k] = tmp }\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(Val.is(v)){\n\t\t\t\to.node[k] = v;\n\t\t\t}\n\t\t}\n\t}());\n\tvar obj = Type.obj, obj_is = obj.is, obj_del = obj.del, obj_map = obj.map;\n\tvar text = Type.text, text_random = text.random;\n\tvar soul_ = Node.soul._;\n\tvar u;\n\tType.node = Type.node || Node;\n\n\tvar State = Type.state;\n\tState.lex = function(){ DEP('state.lex'); return State().toString(36).replace('.','') }\n\tState.to = function(from, k, to){ DEP('state.to'); \n\t\tvar val = (from||{})[k];\n\t\tif(obj_is(val)){\n\t\t\tval = obj_copy(val);\n\t\t}\n\t\treturn State.ify(to, k, State.is(from, k), val, Node.soul(from));\n\t}\n\t;(function(){\n\t\tState.map = function(cb, s, as){ DEP('state.map'); var u; // for use with Node.ify\n\t\t\tvar o = obj_is(o = cb || s)? o : null;\n\t\t\tcb = fn_is(cb = cb || s)? cb : null;\n\t\t\tif(o && !cb){\n\t\t\t\ts = num_is(s)? s : State();\n\t\t\t\to[N_] = o[N_] || {};\n\t\t\t\tobj_map(o, map, {o:o,s:s});\n\t\t\t\treturn o;\n\t\t\t}\n\t\t\tas = as || obj_is(s)? s : u;\n\t\t\ts = num_is(s)? s : State();\n\t\t\treturn function(v, k, o, opt){\n\t\t\t\tif(!cb){\n\t\t\t\t\tmap.call({o: o, s: s}, v,k);\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t\tcb.call(as || this || {}, v, k, o, opt);\n\t\t\t\tif(obj_has(o,k) && u === o[k]){ return }\n\t\t\t\tmap.call({o: o, s: s}, v,k);\n\t\t\t}\n\t\t}\n\t\tfunction map(v,k){\n\t\t\tif(N_ === k){ return }\n\t\t\tState.ify(this.o, k, this.s) ;\n\t\t}\n\t}());\n\tvar obj = Type.obj, obj_as = obj.as, obj_has = obj.has, obj_is = obj.is, obj_map = obj.map, obj_copy = obj.copy;\n\tvar num = Type.num, num_is = num.is;\n\tvar fn = Type.fn, fn_is = fn.is;\n\tvar N_ = Node._, u;\n\n\tvar Graph = {};\n\t;(function(){\n\t\tGraph.is = function(g, cb, fn, as){ DEP('graph.is'); // checks to see if an object is a valid graph.\n\t\t\tif(!g || !obj_is(g) || obj_empty(g)){ return false } // must be an object.\n\t\t\treturn !obj_map(g, map, {cb:cb,fn:fn,as:as}); // makes sure it wasn't an empty object.\n\t\t}\n\t\tfunction map(n, s){ // we invert this because the way'? we check for this is via a negation.\n\t\t\tif(!n || s !== Node.soul(n) || !Node.is(n, this.fn, this.as)){ return true } // it is true that this is an invalid graph.\n\t\t\tif(!this.cb){ return }\n\t\t\tnf.n = n; nf.as = this.as; // sequential race conditions aren't races.\n\t\t\tthis.cb.call(nf.as, n, s, nf);\n\t\t}\n\t\tfunction nf(fn){ // optional callback for each node.\n\t\t\tif(fn){ Node.is(nf.n, fn, nf.as) } // where we then have an optional callback for each key/value.\n\t\t}\n\t}());\n\t;(function(){\n\t\tGraph.ify = function(obj, env, as){ DEP('graph.ify'); \n\t\t\tvar at = {path: [], obj: obj};\n\t\t\tif(!env){\n\t\t\t\tenv = {};\n\t\t\t} else\n\t\t\tif(typeof env === 'string'){\n\t\t\t\tenv = {soul: env};\n\t\t\t} else\n\t\t\tif('function' == typeof env){\n\t\t\t\tenv.map = env;\n\t\t\t}\n\t\t\tif(typeof as === 'string'){\n\t\t\t\tenv.soul = env.soul || as;\n\t\t\t\tas = u;\n\t\t\t}\n\t\t\tif(env.soul){\n\t\t\t\tat.link = Val.link.ify(env.soul);\n\t\t\t}\n\t\t\tenv.shell = (as||{}).shell;\n\t\t\tenv.graph = env.graph || {};\n\t\t\tenv.seen = env.seen || [];\n\t\t\tenv.as = env.as || as;\n\t\t\tnode(env, at);\n\t\t\tenv.root = at.node;\n\t\t\treturn env.graph;\n\t\t}\n\t\tfunction node(env, at){ var tmp;\n\t\t\tif(tmp = seen(env, at)){ return tmp }\n\t\t\tat.env = env;\n\t\t\tat.soul = soul;\n\t\t\tif(Node.ify(at.obj, map, at)){\n\t\t\t\tat.link = at.link || Val.link.ify(Node.soul(at.node));\n\t\t\t\tif(at.obj !== env.shell){\n\t\t\t\t\tenv.graph[Val.link.is(at.link)] = at.node;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn at;\n\t\t}\n\t\tfunction map(v,k,n){\n\t\t\tvar at = this, env = at.env, is, tmp;\n\t\t\tif(Node._ === k && obj_has(v,Val.link._)){\n\t\t\t\treturn n._; // TODO: Bug?\n\t\t\t}\n\t\t\tif(!(is = valid(v,k,n, at,env))){ return }\n\t\t\tif(!k){\n\t\t\t\tat.node = at.node || n || {};\n\t\t\t\tif(obj_has(v, Node._) && Node.soul(v)){ // ? for safety ?\n\t\t\t\t\tat.node._ = obj_copy(v._);\n\t\t\t\t}\n\t\t\t\tat.node = Node.soul.ify(at.node, Val.link.is(at.link));\n\t\t\t\tat.link = at.link || Val.link.ify(Node.soul(at.node));\n\t\t\t}\n\t\t\tif(tmp = env.map){\n\t\t\t\ttmp.call(env.as || {}, v,k,n, at);\n\t\t\t\tif(obj_has(n,k)){\n\t\t\t\t\tv = n[k];\n\t\t\t\t\tif(u === v){\n\t\t\t\t\t\tobj_del(n, k);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(!(is = valid(v,k,n, at,env))){ return }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!k){ return at.node }\n\t\t\tif(true === is){\n\t\t\t\treturn v;\n\t\t\t}\n\t\t\ttmp = node(env, {obj: v, path: at.path.concat(k)});\n\t\t\tif(!tmp.node){ return }\n\t\t\treturn tmp.link; //{'#': Node.soul(tmp.node)};\n\t\t}\n\t\tfunction soul(id){ var at = this;\n\t\t\tvar prev = Val.link.is(at.link), graph = at.env.graph;\n\t\t\tat.link = at.link || Val.link.ify(id);\n\t\t\tat.link[Val.link._] = id;\n\t\t\tif(at.node && at.node[Node._]){\n\t\t\t\tat.node[Node._][Val.link._] = id;\n\t\t\t}\n\t\t\tif(obj_has(graph, prev)){\n\t\t\t\tgraph[id] = graph[prev];\n\t\t\t\tobj_del(graph, prev);\n\t\t\t}\n\t\t}\n\t\tfunction valid(v,k,n, at,env){ var tmp;\n\t\t\tif(Val.is(v)){ return true }\n\t\t\tif(obj_is(v)){ return 1 }\n\t\t\tif(tmp = env.invalid){\n\t\t\t\tv = tmp.call(env.as || {}, v,k,n);\n\t\t\t\treturn valid(v,k,n, at,env);\n\t\t\t}\n\t\t\tenv.err = \"Invalid value at '\" + at.path.concat(k).join('.') + \"'!\";\n\t\t\tif(Type.list.is(v)){ env.err += \" Use `.set(item)` instead of an Array.\" }\n\t\t}\n\t\tfunction seen(env, at){\n\t\t\tvar arr = env.seen, i = arr.length, has;\n\t\t\twhile(i--){ has = arr[i];\n\t\t\t\tif(at.obj === has.obj){ return has }\n\t\t\t}\n\t\t\tarr.push(at);\n\t\t}\n\t}());\n\tGraph.node = function(node){ DEP('graph.node'); \n\t\tvar soul = Node.soul(node);\n\t\tif(!soul){ return }\n\t\treturn obj_put({}, soul, node);\n\t}\n\t;(function(){\n\t\tGraph.to = function(graph, root, opt){ DEP('graph.to'); \n\t\t\tif(!graph){ return }\n\t\t\tvar obj = {};\n\t\t\topt = opt || {seen: {}};\n\t\t\tobj_map(graph[root], map, {obj:obj, graph: graph, opt: opt});\n\t\t\treturn obj;\n\t\t}\n\t\tfunction map(v,k){ var tmp, obj;\n\t\t\tif(Node._ === k){\n\t\t\t\tif(obj_empty(v, Val.link._)){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.obj[k] = obj_copy(v);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(!(tmp = Val.link.is(v))){\n\t\t\t\tthis.obj[k] = v;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(obj = this.opt.seen[tmp]){\n\t\t\t\tthis.obj[k] = obj;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.obj[k] = this.opt.seen[tmp] = Graph.to(this.graph, tmp, this.opt);\n\t\t}\n\t}());\n\tvar fn_is = Type.fn.is;\n\tvar obj = Type.obj, obj_is = obj.is, obj_del = obj.del, obj_has = obj.has, obj_empty = obj.empty, obj_put = obj.put, obj_map = obj.map, obj_copy = obj.copy;\n\tvar u;\n\tType.graph = Type.graph || Graph;\n}());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ3VuL2d1bi5qcz9mNjFkIl0sInNvdXJjZXNDb250ZW50IjpbIjsoZnVuY3Rpb24oKXtcblxuICAvKiBVTkJVSUxEICovXG4gIGZ1bmN0aW9uIFVTRShhcmcsIHJlcSl7XG4gICAgcmV0dXJuIHJlcT8gcmVxdWlyZShhcmcpIDogYXJnLnNsaWNlPyBVU0VbUihhcmcpXSA6IGZ1bmN0aW9uKG1vZCwgcGF0aCl7XG4gICAgICBhcmcobW9kID0ge2V4cG9ydHM6IHt9fSk7XG4gICAgICBVU0VbUihwYXRoKV0gPSBtb2QuZXhwb3J0cztcbiAgICB9XG4gICAgZnVuY3Rpb24gUihwKXtcbiAgICAgIHJldHVybiBwLnNwbGl0KCcvJykuc2xpY2UoLTEpLnRvU3RyaW5nKCkucmVwbGFjZSgnLmpzJywnJyk7XG4gICAgfVxuICB9XG4gIGlmKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIpeyB2YXIgTU9EVUxFID0gbW9kdWxlIH1cbiAgLyogVU5CVUlMRCAqL1xuXG5cdDtVU0UoZnVuY3Rpb24obW9kdWxlKXtcblx0XHQvLyBTaGltIGZvciBnZW5lcmljIGphdmFzY3JpcHQgdXRpbGl0aWVzLlxuXHRcdFN0cmluZy5yYW5kb20gPSBmdW5jdGlvbihsLCBjKXtcblx0XHRcdHZhciBzID0gJyc7XG5cdFx0XHRsID0gbCB8fCAyNDsgLy8geW91IGFyZSBub3QgZ29pbmcgdG8gbWFrZSBhIDAgbGVuZ3RoIHJhbmRvbSBudW1iZXIsIHNvIG5vIG5lZWQgdG8gY2hlY2sgdHlwZVxuXHRcdFx0YyA9IGMgfHwgJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1haYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonO1xuXHRcdFx0d2hpbGUobC0tID4gMCl7IHMgKz0gYy5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYy5sZW5ndGgpKSB9XG5cdFx0XHRyZXR1cm4gcztcblx0XHR9XG5cdFx0U3RyaW5nLm1hdGNoID0gZnVuY3Rpb24odCwgbyl7IHZhciB0bXAsIHU7XG5cdFx0XHRpZignc3RyaW5nJyAhPT0gdHlwZW9mIHQpeyByZXR1cm4gZmFsc2UgfVxuXHRcdFx0aWYoJ3N0cmluZycgPT0gdHlwZW9mIG8peyBvID0geyc9Jzogb30gfVxuXHRcdFx0byA9IG8gfHwge307XG5cdFx0XHR0bXAgPSAob1snPSddIHx8IG9bJyonXSB8fCBvWyc+J10gfHwgb1snPCddKTtcblx0XHRcdGlmKHQgPT09IHRtcCl7IHJldHVybiB0cnVlIH1cblx0XHRcdGlmKHUgIT09IG9bJz0nXSl7IHJldHVybiBmYWxzZSB9XG5cdFx0XHR0bXAgPSAob1snKiddIHx8IG9bJz4nXSk7XG5cdFx0XHRpZih0LnNsaWNlKDAsICh0bXB8fCcnKS5sZW5ndGgpID09PSB0bXApeyByZXR1cm4gdHJ1ZSB9XG5cdFx0XHRpZih1ICE9PSBvWycqJ10peyByZXR1cm4gZmFsc2UgfVxuXHRcdFx0aWYodSAhPT0gb1snPiddICYmIHUgIT09IG9bJzwnXSl7XG5cdFx0XHRcdHJldHVybiAodCA+PSBvWyc+J10gJiYgdCA8PSBvWyc8J10pPyB0cnVlIDogZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZih1ICE9PSBvWyc+J10gJiYgdCA+PSBvWyc+J10peyByZXR1cm4gdHJ1ZSB9XG5cdFx0XHRpZih1ICE9PSBvWyc8J10gJiYgdCA8PSBvWyc8J10peyByZXR1cm4gdHJ1ZSB9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdFN0cmluZy5oYXNoID0gZnVuY3Rpb24ocywgYyl7IC8vIHZpYSBTT1xuXHRcdFx0aWYodHlwZW9mIHMgIT09ICdzdHJpbmcnKXsgcmV0dXJuIH1cblx0ICAgIGMgPSBjIHx8IDA7IC8vIENQVSBzY2hlZHVsZSBoYXNoaW5nIGJ5XG5cdCAgICBpZighcy5sZW5ndGgpeyByZXR1cm4gYyB9XG5cdCAgICBmb3IodmFyIGk9MCxsPXMubGVuZ3RoLG47IGk8bDsgKytpKXtcblx0ICAgICAgbiA9IHMuY2hhckNvZGVBdChpKTtcblx0ICAgICAgYyA9ICgoYzw8NSktYykrbjtcblx0ICAgICAgYyB8PSAwO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGM7XG5cdCAgfVxuXHRcdHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXHRcdE9iamVjdC5wbGFpbiA9IGZ1bmN0aW9uKG8peyByZXR1cm4gbz8gKG8gaW5zdGFuY2VvZiBPYmplY3QgJiYgby5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykubWF0Y2goL15cXFtvYmplY3QgKFxcdyspXFxdJC8pWzFdID09PSAnT2JqZWN0JyA6IGZhbHNlIH1cblx0XHRPYmplY3QuZW1wdHkgPSBmdW5jdGlvbihvLCBuKXtcblx0XHRcdGZvcih2YXIgayBpbiBvKXsgaWYoaGFzLmNhbGwobywgaykgJiYgKCFuIHx8IC0xPT1uLmluZGV4T2YoaykpKXsgcmV0dXJuIGZhbHNlIH0gfVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdE9iamVjdC5rZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24obyl7XG5cdFx0XHR2YXIgbCA9IFtdO1xuXHRcdFx0Zm9yKHZhciBrIGluIG8peyBpZihoYXMuY2FsbChvLCBrKSl7IGwucHVzaChrKSB9IH1cblx0XHRcdHJldHVybiBsO1xuXHRcdH1cblx0XHQ7KGZ1bmN0aW9uKCl7IC8vIG1heCB+MW1zIG9yIGJlZm9yZSBzdGFjayBvdmVyZmxvdyBcblx0XHRcdHZhciB1LCBzVCA9IHNldFRpbWVvdXQsIGwgPSAwLCBjID0gMCwgc0kgPSAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJycrdSAmJiBzZXRJbW1lZGlhdGUpIHx8IHNUOyAvLyBxdWV1ZU1pY3JvdGFzayBmYXN0ZXIgYnV0IGJsb2NrcyBVSVxuXHRcdFx0c1QuaG9sZCA9IHNULmhvbGQgfHwgOTtcblx0XHRcdHNULnBvbGwgPSBzVC5wb2xsIHx8IGZ1bmN0aW9uKGYpeyAvL2YoKTsgcmV0dXJuOyAvLyBmb3IgdGVzdGluZ1xuXHRcdFx0XHRpZigoc1QuaG9sZCA+PSAoK25ldyBEYXRlIC0gbCkpICYmIGMrKyA8IDMzMzMpeyBmKCk7IHJldHVybiB9XG5cdFx0XHRcdHNJKGZ1bmN0aW9uKCl7IGwgPSArbmV3IERhdGU7IGYoKSB9LGM9MClcblx0XHRcdH1cblx0XHR9KCkpO1xuXHRcdDsoZnVuY3Rpb24oKXsgLy8gVG9vIG1hbnkgcG9sbHMgYmxvY2ssIHRoaXMgXCJ0aHJlYWRzXCIgdGhlbSBpbiB0dXJucyBvdmVyIGEgc2luZ2xlIHRocmVhZCBpbiB0aW1lLlxuXHRcdFx0dmFyIHNUID0gc2V0VGltZW91dCwgdCA9IHNULnR1cm4gPSBzVC50dXJuIHx8IGZ1bmN0aW9uKGYpeyAxID09IHMucHVzaChmKSAmJiBwKFQpIH1cblx0XHRcdCwgcyA9IHQucyA9IFtdLCBwID0gc1QucG9sbCwgaSA9IDAsIGYsIFQgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRpZihmID0gc1tpKytdKXsgZigpIH1cblx0XHRcdFx0aWYoaSA9PSBzLmxlbmd0aCB8fCA5OSA9PSBpKXtcblx0XHRcdFx0XHRzID0gdC5zID0gcy5zbGljZShpKTtcblx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihzLmxlbmd0aCl7IHAoVCkgfVxuXHRcdFx0fVxuXHRcdH0oKSk7XG5cdFx0OyhmdW5jdGlvbigpe1xuXHRcdFx0dmFyIHUsIHNUID0gc2V0VGltZW91dCwgVCA9IHNULnR1cm47XG5cdFx0XHQoc1QuZWFjaCA9IHNULmVhY2ggfHwgZnVuY3Rpb24obCxmLGUsUyl7IFMgPSBTIHx8IDk7IChmdW5jdGlvbiB0KHMsTCxyKXtcblx0XHRcdCAgaWYoTCA9IChzID0gKGx8fFtdKS5zcGxpY2UoMCxTKSkubGVuZ3RoKXtcblx0XHRcdCAgXHRmb3IodmFyIGkgPSAwOyBpIDwgTDsgaSsrKXtcblx0XHRcdCAgXHRcdGlmKHUgIT09IChyID0gZihzW2ldKSkpeyBicmVhayB9XG5cdFx0XHQgIFx0fVxuXHRcdFx0ICBcdGlmKHUgPT09IHIpeyBUKHQpOyByZXR1cm4gfVxuXHRcdFx0ICB9IGUgJiYgZShyKTtcblx0XHRcdH0oKSl9KSgpO1xuXHRcdH0oKSk7XG5cdH0pKFVTRSwgJy4vc2hpbScpO1xuXG5cdDtVU0UoZnVuY3Rpb24obW9kdWxlKXtcblx0XHQvLyBPbiBldmVudCBlbWl0dGVyIGdlbmVyaWMgamF2YXNjcmlwdCB1dGlsaXR5LlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gb250byh0YWcsIGFyZywgYXMpe1xuXHRcdFx0aWYoIXRhZyl7IHJldHVybiB7dG86IG9udG99IH1cblx0XHRcdHZhciB1LCBmID0gJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgYXJnLCB0YWcgPSAodGhpcy50YWcgfHwgKHRoaXMudGFnID0ge30pKVt0YWddIHx8IGYgJiYgKFxuXHRcdFx0XHR0aGlzLnRhZ1t0YWddID0ge3RhZzogdGFnLCB0bzogb250by5fID0geyBuZXh0OiBmdW5jdGlvbihhcmcpeyB2YXIgdG1wO1xuXHRcdFx0XHRcdGlmKHRtcCA9IHRoaXMudG8peyB0bXAubmV4dChhcmcpIH1cblx0XHRcdH19fSk7XG5cdFx0XHRpZihmKXtcblx0XHRcdFx0dmFyIGJlID0ge1xuXHRcdFx0XHRcdG9mZjogb250by5vZmYgfHxcblx0XHRcdFx0XHQob250by5vZmYgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0aWYodGhpcy5uZXh0ID09PSBvbnRvLl8ubmV4dCl7IHJldHVybiAhMCB9XG5cdFx0XHRcdFx0XHRpZih0aGlzID09PSB0aGlzLnRoZS5sYXN0KXtcblx0XHRcdFx0XHRcdFx0dGhpcy50aGUubGFzdCA9IHRoaXMuYmFjaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMudG8uYmFjayA9IHRoaXMuYmFjaztcblx0XHRcdFx0XHRcdHRoaXMubmV4dCA9IG9udG8uXy5uZXh0O1xuXHRcdFx0XHRcdFx0dGhpcy5iYWNrLnRvID0gdGhpcy50bztcblx0XHRcdFx0XHRcdGlmKHRoaXMudGhlLmxhc3QgPT09IHRoaXMudGhlKXtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIHRoaXMub24udGFnW3RoaXMudGhlLnRhZ107XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSksXG5cdFx0XHRcdFx0dG86IG9udG8uXyxcblx0XHRcdFx0XHRuZXh0OiBhcmcsXG5cdFx0XHRcdFx0dGhlOiB0YWcsXG5cdFx0XHRcdFx0b246IHRoaXMsXG5cdFx0XHRcdFx0YXM6IGFzLFxuXHRcdFx0XHR9O1xuXHRcdFx0XHQoYmUuYmFjayA9IHRhZy5sYXN0IHx8IHRhZykudG8gPSBiZTtcblx0XHRcdFx0cmV0dXJuIHRhZy5sYXN0ID0gYmU7XG5cdFx0XHR9XG5cdFx0XHRpZigodGFnID0gdGFnLnRvKSAmJiB1ICE9PSBhcmcpeyB0YWcubmV4dChhcmcpIH1cblx0XHRcdHJldHVybiB0YWc7XG5cdFx0fTtcblx0fSkoVVNFLCAnLi9vbnRvJyk7XG5cblx0O1VTRShmdW5jdGlvbihtb2R1bGUpe1xuXHRcdC8vIFZhbGlkIHZhbHVlcyBhcmUgYSBzdWJzZXQgb2YgSlNPTjogbnVsbCwgYmluYXJ5LCBudW1iZXIgKCFJbmZpbml0eSksIHRleHQsXG5cdFx0Ly8gb3IgYSBzb3VsIHJlbGF0aW9uLiBBcnJheXMgbmVlZCBzcGVjaWFsIGFsZ29yaXRobXMgdG8gaGFuZGxlIGNvbmN1cnJlbmN5LFxuXHRcdC8vIHNvIHRoZXkgYXJlIG5vdCBzdXBwb3J0ZWQgZGlyZWN0bHkuIFVzZSBhbiBleHRlbnNpb24gdGhhdCBzdXBwb3J0cyB0aGVtIGlmXG5cdFx0Ly8gbmVlZGVkIGJ1dCByZXNlYXJjaCB0aGVpciBwcm9ibGVtcyBmaXJzdC5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2KSB7XG5cdFx0ICAvLyBcImRlbGV0ZXNcIiwgbnVsbGluZyBvdXQga2V5cy5cblx0XHQgIHJldHVybiB2ID09PSBudWxsIHx8XG5cdFx0XHRcInN0cmluZ1wiID09PSB0eXBlb2YgdiB8fFxuXHRcdFx0XCJib29sZWFuXCIgPT09IHR5cGVvZiB2IHx8XG5cdFx0XHQvLyB3ZSB3YW50ICsvLSBJbmZpbml0eSB0byBiZSwgYnV0IEpTT04gZG9lcyBub3Qgc3VwcG9ydCBpdCwgc2FkIGZhY2UuXG5cdFx0XHQvLyBjYW4geW91IGd1ZXNzIHdoYXQgdiA9PT0gdiBjaGVja3MgZm9yPyA7KVxuXHRcdFx0KFwibnVtYmVyXCIgPT09IHR5cGVvZiB2ICYmIHYgIT0gSW5maW5pdHkgJiYgdiAhPSAtSW5maW5pdHkgJiYgdiA9PT0gdikgfHxcblx0XHRcdCghIXYgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgdltcIiNcIl0gJiYgT2JqZWN0LmtleXModikubGVuZ3RoID09PSAxICYmIHZbXCIjXCJdKTtcblx0XHR9XG5cdH0pKFVTRSwgJy4vdmFsaWQnKTtcblxuXHQ7VVNFKGZ1bmN0aW9uKG1vZHVsZSl7XG5cdFx0VVNFKCcuL3NoaW0nKTtcblx0XHRmdW5jdGlvbiBTdGF0ZSgpe1xuXHRcdFx0dmFyIHQgPSArbmV3IERhdGU7XG5cdFx0XHRpZihsYXN0IDwgdCl7XG5cdFx0XHRcdHJldHVybiBOID0gMCwgbGFzdCA9IHQgKyBTdGF0ZS5kcmlmdDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBsYXN0ID0gdCArICgoTiArPSAxKSAvIEQpICsgU3RhdGUuZHJpZnQ7XG5cdFx0fVxuXHRcdFN0YXRlLmRyaWZ0ID0gMDtcblx0XHR2YXIgTkkgPSAtSW5maW5pdHksIE4gPSAwLCBEID0gOTk5LCBsYXN0ID0gTkksIHU7IC8vIFdBUk5JTkchIEluIHRoZSBmdXR1cmUsIG9uIG1hY2hpbmVzIHRoYXQgYXJlIEQgdGltZXMgZmFzdGVyIHRoYW4gMjAxNkFEIG1hY2hpbmVzLCB5b3Ugd2lsbCB3YW50IHRvIGluY3JlYXNlIEQgYnkgYW5vdGhlciBzZXZlcmFsIG9yZGVycyBvZiBtYWduaXR1ZGUgc28gdGhlIHByb2Nlc3Npbmcgc3BlZWQgbmV2ZXIgb3V0IHBhY2VzIHRoZSBkZWNpbWFsIHJlc29sdXRpb24gKGluY3JlYXNpbmcgYW4gaW50ZWdlciBlZmZlY3RzIHRoZSBzdGF0ZSBhY2N1cmFjeSkuXG5cdFx0U3RhdGUuaXMgPSBmdW5jdGlvbihuLCBrLCBvKXsgLy8gY29udmVuaWVuY2UgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzdGF0ZSBvbiBhIGtleSBvbiBhIG5vZGUgYW5kIHJldHVybiBpdC5cblx0XHRcdHZhciB0bXAgPSAoayAmJiBuICYmIG4uXyAmJiBuLl9bJz4nXSkgfHwgbztcblx0XHRcdGlmKCF0bXApeyByZXR1cm4gfVxuXHRcdFx0cmV0dXJuICgnbnVtYmVyJyA9PSB0eXBlb2YgKHRtcCA9IHRtcFtrXSkpPyB0bXAgOiBOSTtcblx0XHR9XG5cdFx0U3RhdGUuaWZ5ID0gZnVuY3Rpb24obiwgaywgcywgdiwgc291bCl7IC8vIHB1dCBhIGtleSdzIHN0YXRlIG9uIGEgbm9kZS5cblx0XHRcdChuID0gbiB8fCB7fSkuXyA9IG4uXyB8fCB7fTsgLy8gc2FmZXR5IGNoZWNrIG9yIGluaXQuXG5cdFx0XHRpZihzb3VsKXsgbi5fWycjJ10gPSBzb3VsIH0gLy8gc2V0IGEgc291bCBpZiBzcGVjaWZpZWQuXG5cdFx0XHR2YXIgdG1wID0gbi5fWyc+J10gfHwgKG4uX1snPiddID0ge30pOyAvLyBncmFiIHRoZSBzdGF0ZXMgZGF0YS5cblx0XHRcdGlmKHUgIT09IGsgJiYgayAhPT0gJ18nKXtcblx0XHRcdFx0aWYoJ251bWJlcicgPT0gdHlwZW9mIHMpeyB0bXBba10gPSBzIH0gLy8gYWRkIHRoZSB2YWxpZCBzdGF0ZS5cblx0XHRcdFx0aWYodSAhPT0gdil7IG5ba10gPSB2IH0gLy8gTm90ZTogTm90IGl0cyBqb2IgdG8gY2hlY2sgZm9yIHZhbGlkIHZhbHVlcyFcblx0XHRcdH1cblx0XHRcdHJldHVybiBuO1xuXHRcdH1cblx0XHRtb2R1bGUuZXhwb3J0cyA9IFN0YXRlO1xuXHR9KShVU0UsICcuL3N0YXRlJyk7XG5cblx0O1VTRShmdW5jdGlvbihtb2R1bGUpe1xuXHRcdFVTRSgnLi9zaGltJyk7XG5cdFx0ZnVuY3Rpb24gRHVwKG9wdCl7XG5cdFx0XHR2YXIgZHVwID0ge3M6e319LCBzID0gZHVwLnM7XG5cdFx0XHRvcHQgPSBvcHQgfHwge21heDogOTk5LCBhZ2U6IDEwMDAgKiA5fTsvLyovIDEwMDAgKiA5ICogM307XG5cdFx0XHRkdXAuY2hlY2sgPSBmdW5jdGlvbihpZCl7XG5cdFx0XHRcdGlmKCFzW2lkXSl7IHJldHVybiBmYWxzZSB9XG5cdFx0XHRcdHJldHVybiBkdChpZCk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgZHQgPSBkdXAudHJhY2sgPSBmdW5jdGlvbihpZCl7XG5cdFx0XHRcdHZhciBpdCA9IHNbaWRdIHx8IChzW2lkXSA9IHt9KTtcblx0XHRcdFx0aXQud2FzID0gZHVwLm5vdyA9ICtuZXcgRGF0ZTtcblx0XHRcdFx0aWYoIWR1cC50byl7IGR1cC50byA9IHNldFRpbWVvdXQoZHVwLmRyb3AsIG9wdC5hZ2UgKyA5KSB9XG5cdFx0XHRcdHJldHVybiBpdDtcblx0XHRcdH1cblx0XHRcdGR1cC5kcm9wID0gZnVuY3Rpb24oYWdlKXtcblx0XHRcdFx0ZHVwLnRvID0gbnVsbDtcblx0XHRcdFx0ZHVwLm5vdyA9ICtuZXcgRGF0ZTtcblx0XHRcdFx0dmFyIGwgPSBPYmplY3Qua2V5cyhzKTtcblx0XHRcdFx0Y29uc29sZS5TVEFUICYmIGNvbnNvbGUuU1RBVChkdXAubm93LCArbmV3IERhdGUgLSBkdXAubm93LCAnZHVwIGRyb3Aga2V5cycpOyAvLyBwcmV2IH4yMCUgQ1BVIDclIFJBTSAzMDBNQiAvLyBub3cgfjI1JSBDUFUgNyUgUkFNIDUwME1CXG5cdFx0XHRcdHNldFRpbWVvdXQuZWFjaChsLCBmdW5jdGlvbihpZCl7IHZhciBpdCA9IHNbaWRdOyAvLyBUT0RPOiAua2V5cyggaXMgc2xvdz9cblx0XHRcdFx0XHRpZihpdCAmJiAoYWdlIHx8IG9wdC5hZ2UpID4gKGR1cC5ub3cgLSBpdC53YXMpKXsgcmV0dXJuIH1cblx0XHRcdFx0XHRkZWxldGUgc1tpZF07XG5cdFx0XHRcdH0sMCw5OSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZHVwO1xuXHRcdH1cblx0XHRtb2R1bGUuZXhwb3J0cyA9IER1cDtcblx0fSkoVVNFLCAnLi9kdXAnKTtcblxuXHQ7VVNFKGZ1bmN0aW9uKG1vZHVsZSl7XG5cdFx0Ly8gcmVxdWVzdCAvIHJlc3BvbnNlIG1vZHVsZSwgZm9yIGFza2luZyBhbmQgYWNraW5nIG1lc3NhZ2VzLlxuXHRcdFVTRSgnLi9vbnRvJyk7IC8vIGRlcGVuZHMgdXBvbiBvbnRvIVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXNrKGNiLCBhcyl7XG5cdFx0XHRpZighdGhpcy5vbil7IHJldHVybiB9XG5cdFx0XHR2YXIgbGFjayA9ICh0aGlzLm9wdHx8e30pLmxhY2sgfHwgOTAwMDtcblx0XHRcdGlmKCEoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgY2IpKXtcblx0XHRcdFx0aWYoIWNiKXsgcmV0dXJuIH1cblx0XHRcdFx0dmFyIGlkID0gY2JbJyMnXSB8fCBjYiwgdG1wID0gKHRoaXMudGFnfHwnJylbaWRdO1xuXHRcdFx0XHRpZighdG1wKXsgcmV0dXJuIH1cblx0XHRcdFx0aWYoYXMpe1xuXHRcdFx0XHRcdHRtcCA9IHRoaXMub24oaWQsIGFzKTtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQodG1wLmVycik7XG5cdFx0XHRcdFx0dG1wLmVyciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXsgdG1wLm9mZigpIH0sIGxhY2spO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGlkID0gKGFzICYmIGFzWycjJ10pIHx8IHJhbmRvbSg5KTtcblx0XHRcdGlmKCFjYil7IHJldHVybiBpZCB9XG5cdFx0XHR2YXIgdG8gPSB0aGlzLm9uKGlkLCBjYiwgYXMpO1xuXHRcdFx0dG8uZXJyID0gdG8uZXJyIHx8IHNldFRpbWVvdXQoZnVuY3Rpb24oKXsgdG8ub2ZmKCk7XG5cdFx0XHRcdHRvLm5leHQoe2VycjogXCJFcnJvcjogTm8gQUNLIHlldC5cIiwgbGFjazogdHJ1ZX0pO1xuXHRcdFx0fSwgbGFjayk7XG5cdFx0XHRyZXR1cm4gaWQ7XG5cdFx0fVxuXHRcdHZhciByYW5kb20gPSBTdHJpbmcucmFuZG9tIHx8IGZ1bmN0aW9uKCl7IHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKSB9XG5cdH0pKFVTRSwgJy4vYXNrJyk7XG5cblx0O1VTRShmdW5jdGlvbihtb2R1bGUpe1xuXG5cdFx0ZnVuY3Rpb24gR3VuKG8pe1xuXHRcdFx0aWYobyBpbnN0YW5jZW9mIEd1bil7IHJldHVybiAodGhpcy5fID0geyQ6IHRoaXN9KS4kIH1cblx0XHRcdGlmKCEodGhpcyBpbnN0YW5jZW9mIEd1bikpeyByZXR1cm4gbmV3IEd1bihvKSB9XG5cdFx0XHRyZXR1cm4gR3VuLmNyZWF0ZSh0aGlzLl8gPSB7JDogdGhpcywgb3B0OiBvfSk7XG5cdFx0fVxuXG5cdFx0R3VuLmlzID0gZnVuY3Rpb24oJCl7IHJldHVybiAoJCBpbnN0YW5jZW9mIEd1bikgfHwgKCQgJiYgJC5fICYmICgkID09PSAkLl8uJCkpIHx8IGZhbHNlIH1cblxuXHRcdEd1bi52ZXJzaW9uID0gMC4yMDIwO1xuXG5cdFx0R3VuLmNoYWluID0gR3VuLnByb3RvdHlwZTtcblx0XHRHdW4uY2hhaW4udG9KU09OID0gZnVuY3Rpb24oKXt9O1xuXG5cdFx0VVNFKCcuL3NoaW0nKTtcblx0XHRHdW4udmFsaWQgPSBVU0UoJy4vdmFsaWQnKTtcblx0XHRHdW4uc3RhdGUgPSBVU0UoJy4vc3RhdGUnKTtcblx0XHRHdW4ub24gPSBVU0UoJy4vb250bycpO1xuXHRcdEd1bi5kdXAgPSBVU0UoJy4vZHVwJyk7XG5cdFx0R3VuLmFzayA9IFVTRSgnLi9hc2snKTtcblxuXHRcdDsoZnVuY3Rpb24oKXtcblx0XHRcdEd1bi5jcmVhdGUgPSBmdW5jdGlvbihhdCl7XG5cdFx0XHRcdGF0LnJvb3QgPSBhdC5yb290IHx8IGF0O1xuXHRcdFx0XHRhdC5ncmFwaCA9IGF0LmdyYXBoIHx8IHt9O1xuXHRcdFx0XHRhdC5vbiA9IGF0Lm9uIHx8IEd1bi5vbjtcblx0XHRcdFx0YXQuYXNrID0gYXQuYXNrIHx8IEd1bi5hc2s7XG5cdFx0XHRcdGF0LmR1cCA9IGF0LmR1cCB8fCBHdW4uZHVwKCk7XG5cdFx0XHRcdHZhciBndW4gPSBhdC4kLm9wdChhdC5vcHQpO1xuXHRcdFx0XHRpZighYXQub25jZSl7XG5cdFx0XHRcdFx0YXQub24oJ2luJywgdW5pdmVyc2UsIGF0KTtcblx0XHRcdFx0XHRhdC5vbignb3V0JywgdW5pdmVyc2UsIGF0KTtcblx0XHRcdFx0XHRhdC5vbigncHV0JywgbWFwLCBhdCk7XG5cdFx0XHRcdFx0R3VuLm9uKCdjcmVhdGUnLCBhdCk7XG5cdFx0XHRcdFx0YXQub24oJ2NyZWF0ZScsIGF0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhdC5vbmNlID0gMTtcblx0XHRcdFx0cmV0dXJuIGd1bjtcblx0XHRcdH1cblx0XHRcdGZ1bmN0aW9uIHVuaXZlcnNlKG1zZyl7XG5cdFx0XHRcdC8vIFRPRE86IEJVRyEgbXNnLm91dCA9IG51bGwgYmVpbmcgc2V0IVxuXHRcdFx0XHQvL2lmKCFGKXsgdmFyIGV2ZSA9IHRoaXM7IHNldFRpbWVvdXQoZnVuY3Rpb24oKXsgdW5pdmVyc2UuY2FsbChldmUsIG1zZywxKSB9LE1hdGgucmFuZG9tKCkgKiAxMDApO3JldHVybjsgfSAvLyBBREQgRiBUTyBQQVJBTVMhXG5cdFx0XHRcdGlmKCFtc2cpeyByZXR1cm4gfVxuXHRcdFx0XHRpZihtc2cub3V0ID09PSB1bml2ZXJzZSl7IHRoaXMudG8ubmV4dChtc2cpOyByZXR1cm4gfVxuXHRcdFx0XHR2YXIgZXZlID0gdGhpcywgYXMgPSBldmUuYXMsIGF0ID0gYXMuYXQgfHwgYXMsIGd1biA9IGF0LiQsIGR1cCA9IGF0LmR1cCwgdG1wLCBEQkcgPSBtc2cuREJHO1xuXHRcdFx0XHQodG1wID0gbXNnWycjJ10pIHx8ICh0bXAgPSBtc2dbJyMnXSA9IHRleHRfcmFuZCg5KSk7XG5cdFx0XHRcdGlmKGR1cC5jaGVjayh0bXApKXsgcmV0dXJuIH0gZHVwLnRyYWNrKHRtcCk7XG5cdFx0XHRcdHRtcCA9IG1zZy5fOyBtc2cuXyA9ICgnZnVuY3Rpb24nID09IHR5cGVvZiB0bXApPyB0bXAgOiBmdW5jdGlvbigpe307XG5cdFx0XHRcdChtc2cuJCAmJiAobXNnLiQgPT09IChtc2cuJC5ffHwnJykuJCkpIHx8IChtc2cuJCA9IGd1bik7XG5cdFx0XHRcdGlmKG1zZ1snQCddICYmICFtc2cucHV0KXsgYWNrKG1zZykgfVxuXHRcdFx0XHRpZighYXQuYXNrKG1zZ1snQCddLCBtc2cpKXsgLy8gaXMgdGhpcyBtYWNoaW5lIGxpc3RlbmluZyBmb3IgYW4gYWNrP1xuXHRcdFx0XHRcdERCRyAmJiAoREJHLnUgPSArbmV3IERhdGUpO1xuXHRcdFx0XHRcdGlmKG1zZy5wdXQpeyBwdXQobXNnKTsgcmV0dXJuIH0gZWxzZVxuXHRcdFx0XHRcdGlmKG1zZy5nZXQpeyBHdW4ub24uZ2V0KG1zZywgZ3VuKSB9XG5cdFx0XHRcdH1cblx0XHRcdFx0REJHICYmIChEQkcudWMgPSArbmV3IERhdGUpO1xuXHRcdFx0XHRldmUudG8ubmV4dChtc2cpO1xuXHRcdFx0XHREQkcgJiYgKERCRy51YSA9ICtuZXcgRGF0ZSk7XG5cdFx0XHRcdGlmKG1zZy5udHMgfHwgbXNnLk5UUyl7IHJldHVybiB9IC8vIFRPRE86IFRoaXMgc2hvdWxkbid0IGJlIGluIGNvcmUsIGJ1dCBmYXN0IHdheSB0byBwcmV2ZW50IE5UUyBzcHJlYWQuIERlbGV0ZSB0aGlzIGxpbmUgYWZ0ZXIgYWxsIHBlZXJzIGhhdmUgdXBncmFkZWQgdG8gbmV3ZXIgdmVyc2lvbnMuXG5cdFx0XHRcdG1zZy5vdXQgPSB1bml2ZXJzZTsgYXQub24oJ291dCcsIG1zZyk7XG5cdFx0XHRcdERCRyAmJiAoREJHLnVlID0gK25ldyBEYXRlKTtcblx0XHRcdH1cblx0XHRcdGZ1bmN0aW9uIHB1dChtc2cpe1xuXHRcdFx0XHRpZighbXNnKXsgcmV0dXJuIH1cblx0XHRcdFx0dmFyIGN0eCA9IG1zZy5ffHwnJywgcm9vdCA9IGN0eC5yb290ID0gKChjdHguJCA9IG1zZy4kfHwnJykuX3x8JycpLnJvb3Q7XG5cdFx0XHRcdGlmKG1zZ1snQCddICYmIGN0eC5mYWl0aCAmJiAhY3R4Lm1pc3MpeyAvLyBUT0RPOiBBWEUgbWF5IHNwbGl0L3JvdXRlIGJhc2VkIG9uICdwdXQnIHdoYXQgc2hvdWxkIHdlIGRvIGhlcmU/IERldGVjdCBAIGluIEFYRT8gSSB0aGluayB3ZSBkb24ndCBoYXZlIHRvIHdvcnJ5LCBhcyBEQU0gd2lsbCByb3V0ZSBpdCBvbiBALlxuXHRcdFx0XHRcdG1zZy5vdXQgPSB1bml2ZXJzZTtcblx0XHRcdFx0XHRyb290Lm9uKCdvdXQnLCBtc2cpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjdHgubGF0Y2ggPSByb290LmhhdGNoOyBjdHgubWF0Y2ggPSByb290LmhhdGNoID0gW107XG5cdFx0XHRcdHZhciBwdXQgPSBtc2cucHV0O1xuXHRcdFx0XHR2YXIgREJHID0gY3R4LkRCRyA9IG1zZy5EQkcsIFMgPSArbmV3IERhdGU7IENUID0gQ1QgfHwgUztcblx0XHRcdFx0aWYocHV0WycjJ10gJiYgcHV0WycuJ10peyAvKnJvb3QgJiYgcm9vdC5vbigncHV0JywgbXNnKTsqLyByZXR1cm4gfSAvLyBUT0RPOiBCVUchIFRoaXMgbmVlZHMgdG8gY2FsbCBIQU0gaW5zdGVhZC5cblx0XHRcdFx0REJHICYmIChEQkcucCA9IFMpO1xuXHRcdFx0XHRjdHhbJyMnXSA9IG1zZ1snIyddO1xuXHRcdFx0XHRjdHgubXNnID0gbXNnO1xuXHRcdFx0XHRjdHguYWxsID0gMDtcblx0XHRcdFx0Y3R4LnN0dW4gPSAxO1xuXHRcdFx0XHR2YXIgbmwgPSBPYmplY3Qua2V5cyhwdXQpOy8vLnNvcnQoKTsgLy8gVE9ETzogVGhpcyBpcyB1bmJvdW5kZWQgb3BlcmF0aW9uLCBsYXJnZSBncmFwaHMgd2lsbCBiZSBzbG93ZXIuIFdyaXRlIG91ciBvd24gQ1BVIHNjaGVkdWxlZCBzb3J0PyBPciBzb21laG93IGRvIGl0IGluIGJlbG93PyBLZXlzIGl0c2VsZiBpcyBub3QgTygxKSBlaXRoZXIsIGNyZWF0ZSBFUzUgc2hpbSBvdmVyID93ZWFrIG1hcD8gb3IgY3VzdG9tIHdoaWNoIGlzIGNvbnN0YW50LlxuXHRcdFx0XHRjb25zb2xlLlNUQVQgJiYgY29uc29sZS5TVEFUKFMsICgoREJHfHxjdHgpLnBrID0gK25ldyBEYXRlKSAtIFMsICdwdXQgc29ydCcpO1xuXHRcdFx0XHR2YXIgbmkgPSAwLCBuaiwga2wsIHNvdWwsIG5vZGUsIHN0YXRlcywgZXJyLCB0bXA7XG5cdFx0XHRcdChmdW5jdGlvbiBwb3Aobyl7XG5cdFx0XHRcdFx0aWYobmogIT0gbmkpeyBuaiA9IG5pO1xuXHRcdFx0XHRcdFx0aWYoIShzb3VsID0gbmxbbmldKSl7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuU1RBVCAmJiBjb25zb2xlLlNUQVQoUywgKChEQkd8fGN0eCkucGQgPSArbmV3IERhdGUpIC0gUywgJ3B1dCcpO1xuXHRcdFx0XHRcdFx0XHRmaXJlKGN0eCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKCEobm9kZSA9IHB1dFtzb3VsXSkpeyBlcnIgPSBFUlIrY3V0KHNvdWwpK1wibm8gbm9kZS5cIiB9IGVsc2Vcblx0XHRcdFx0XHRcdGlmKCEodG1wID0gbm9kZS5fKSl7IGVyciA9IEVSUitjdXQoc291bCkrXCJubyBtZXRhLlwiIH0gZWxzZVxuXHRcdFx0XHRcdFx0aWYoc291bCAhPT0gdG1wWycjJ10peyBlcnIgPSBFUlIrY3V0KHNvdWwpK1wic291bCBub3Qgc2FtZS5cIiB9IGVsc2Vcblx0XHRcdFx0XHRcdGlmKCEoc3RhdGVzID0gdG1wWyc+J10pKXsgZXJyID0gRVJSK2N1dChzb3VsKStcIm5vIHN0YXRlLlwiIH1cblx0XHRcdFx0XHRcdGtsID0gT2JqZWN0LmtleXMobm9kZXx8e30pOyAvLyBUT0RPOiAua2V5cyggaXMgc2xvd1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihlcnIpe1xuXHRcdFx0XHRcdFx0bXNnLmVyciA9IGN0eC5lcnIgPSBlcnI7IC8vIGludmFsaWQgZGF0YSBzaG91bGQgZXJyb3IgYW5kIHN0dW4gdGhlIG1lc3NhZ2UuXG5cdFx0XHRcdFx0XHRmaXJlKGN0eCk7XG5cdFx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKFwiaGFuZGxlIGVycm9yIVwiLCBlcnIpIC8vIGhhbmRsZSFcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIGkgPSAwLCBrZXk7IG8gPSBvIHx8IDA7XG5cdFx0XHRcdFx0d2hpbGUobysrIDwgOSAmJiAoa2V5ID0ga2xbaSsrXSkpe1xuXHRcdFx0XHRcdFx0aWYoJ18nID09PSBrZXkpeyBjb250aW51ZSB9XG5cdFx0XHRcdFx0XHR2YXIgdmFsID0gbm9kZVtrZXldLCBzdGF0ZSA9IHN0YXRlc1trZXldO1xuXHRcdFx0XHRcdFx0aWYodSA9PT0gc3RhdGUpeyBlcnIgPSBFUlIrY3V0KGtleSkrXCJvblwiK2N1dChzb3VsKStcIm5vIHN0YXRlLlwiOyBicmVhayB9XG5cdFx0XHRcdFx0XHRpZighdmFsaWQodmFsKSl7IGVyciA9IEVSUitjdXQoa2V5KStcIm9uXCIrY3V0KHNvdWwpK1wiYmFkIFwiKyh0eXBlb2YgdmFsKStjdXQodmFsKTsgYnJlYWsgfVxuXHRcdFx0XHRcdFx0Ly9jdHguYWxsKys7IC8vY3R4LmFja1tzb3VsK2tleV0gPSAnJztcblx0XHRcdFx0XHRcdGhhbSh2YWwsIGtleSwgc291bCwgc3RhdGUsIG1zZyk7XG5cdFx0XHRcdFx0XHQrK0M7IC8vIGNvdXJ0ZXN5IGNvdW50O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZigoa2wgPSBrbC5zbGljZShpKSkubGVuZ3RoKXsgdHVybihwb3ApOyByZXR1cm4gfVxuXHRcdFx0XHRcdCsrbmk7IGtsID0gbnVsbDsgcG9wKG8pO1xuXHRcdFx0XHR9KCkpO1xuXHRcdFx0fSBHdW4ub24ucHV0ID0gcHV0O1xuXHRcdFx0Ly8gVE9ETzogTUFSSyEhISBjbG9jayBiZWxvdywgcmVjb25uZWN0IHN5bmMsIFNFQSBjZXJ0aWZ5IHdpcmUgbWVyZ2UsIFVzZXIuYXV0aCB0YWtpbmcgbXVsdGlwbGUgdGltZXMsIC8vIG1zZyBwdXQsIHB1dCwgc2F5IGFjaywgaGVhciBsb29wLi4uXG5cdFx0XHQvLyBXQVNJUyBCVUchIGxvY2FsIHBlZXIgbm90IGFjay4gLm9mZiBvdGhlciBwZW9wbGU6IC5vcGVuXG5cdFx0XHRmdW5jdGlvbiBoYW0odmFsLCBrZXksIHNvdWwsIHN0YXRlLCBtc2cpe1xuXHRcdFx0XHR2YXIgY3R4ID0gbXNnLl98fCcnLCByb290ID0gY3R4LnJvb3QsIGdyYXBoID0gcm9vdC5ncmFwaCwgbG90LCB0bXA7XG5cdFx0XHRcdHZhciB2ZXJ0ZXggPSBncmFwaFtzb3VsXSB8fCBlbXB0eSwgd2FzID0gc3RhdGVfaXModmVydGV4LCBrZXksIDEpLCBrbm93biA9IHZlcnRleFtrZXldO1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIERCRyA9IGN0eC5EQkc7IGlmKHRtcCA9IGNvbnNvbGUuU1RBVCl7IGlmKCFncmFwaFtzb3VsXSB8fCAha25vd24peyB0bXAuaGFzID0gKHRtcC5oYXMgfHwgMCkgKyAxIH0gfVxuXG5cdFx0XHRcdHZhciBub3cgPSBTdGF0ZSgpLCB1O1xuXHRcdFx0XHRpZihzdGF0ZSA+IG5vdyl7XG5cdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpeyBoYW0odmFsLCBrZXksIHNvdWwsIHN0YXRlLCBtc2cpIH0sICh0bXAgPSBzdGF0ZSAtIG5vdykgPiBNRD8gTUQgOiB0bXApOyAvLyBNYXggRGVmZXIgMzJiaXQuIDooXG5cdFx0XHRcdFx0Y29uc29sZS5TVEFUICYmIGNvbnNvbGUuU1RBVCgoKERCR3x8Y3R4KS5IZiA9ICtuZXcgRGF0ZSksIHRtcCwgJ2Z1dHVyZScpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihzdGF0ZSA8IHdhcyl7IC8qb2xkOyovIGlmKCFjdHgubWlzcyl7IHJldHVybiB9IH0gLy8gYnV0IHNvbWUgY2hhaW5zIGhhdmUgYSBjYWNoZSBtaXNzIHRoYXQgbmVlZCB0byByZS1maXJlLiAvLyBUT0RPOiBJbXByb3ZlIGluIGZ1dHVyZS4gLy8gZm9yIEFYRSB0aGlzIHdvdWxkIHJlZHVjZSByZWJyb2FkY2FzdCwgYnV0IEdVTiBkb2VzIGl0IG9uIG1lc3NhZ2UgZm9yd2FyZGluZy5cblx0XHRcdFx0aWYoIWN0eC5mYWl0aCl7IC8vIFRPRE86IEJVRz8gQ2FuIHRoaXMgYmUgdXNlZCBmb3IgY2FjaGUgbWlzcyBhcyB3ZWxsPyAvLyBZZXMgdGhpcyB3YXMgYSBidWcsIG5lZWQgdG8gY2hlY2sgY2FjaGUgbWlzcyBmb3IgUkFEIHRlc3RzLCBidXQgc2hvdWxkIHdlIGNhcmUgYWJvdXQgdGhlIGZhaXRoIGNoZWNrIG5vdz8gUHJvYmFibHkgbm90LlxuXHRcdFx0XHRcdGlmKHN0YXRlID09PSB3YXMgJiYgKHZhbCA9PT0ga25vd24gfHwgTCh2YWwpIDw9IEwoa25vd24pKSl7IC8qY29uc29sZS5sb2coXCJzYW1lXCIpOyovIC8qc2FtZTsqLyBpZighY3R4Lm1pc3MpeyByZXR1cm4gfSB9IC8vIHNhbWVcblx0XHRcdFx0fVxuXHRcdFx0XHRjdHguc3R1bisrOyAvLyBUT0RPOiAnZm9yZ2V0JyBmZWF0dXJlIGluIFNFQSB0aWVkIHRvIHRoaXMsIGJhZCBhcHByb2FjaCwgYnV0IGhhY2tlZCBpbiBmb3Igbm93LiBBbnkgY2hhbmdlcyBoZXJlIG11c3QgdXBkYXRlIHRoZXJlLlxuXHRcdFx0XHR2YXIgYWlkID0gbXNnWycjJ10rY3R4LmFsbCsrLCBpZCA9IHt0b1N0cmluZzogZnVuY3Rpb24oKXsgcmV0dXJuIGFpZCB9LCBfOiBjdHh9OyBpZC50b0pTT04gPSBpZC50b1N0cmluZzsgLy8gdGhpcyAqdHJpY2sqIG1ha2VzIGl0IGNvbXBhdGlibGUgYmV0d2VlbiBvbGQgJiBuZXcgdmVyc2lvbnMuXG5cdFx0XHRcdERCRyAmJiAoREJHLnBoID0gREJHLnBoIHx8ICtuZXcgRGF0ZSk7XG5cdFx0XHRcdHJvb3Qub24oJ3B1dCcsIHsnIyc6IGlkLCAnQCc6IG1zZ1snQCddLCBwdXQ6IHsnIyc6IHNvdWwsICcuJzoga2V5LCAnOic6IHZhbCwgJz4nOiBzdGF0ZX0sIF86IGN0eH0pO1xuXHRcdFx0fVxuXHRcdFx0ZnVuY3Rpb24gbWFwKG1zZyl7XG5cdFx0XHRcdHZhciBEQkc7IGlmKERCRyA9IChtc2cuX3x8JycpLkRCRyl7IERCRy5wYSA9ICtuZXcgRGF0ZTsgREJHLnBtID0gREJHLnBtIHx8ICtuZXcgRGF0ZX1cbiAgICAgIFx0dmFyIGV2ZSA9IHRoaXMsIHJvb3QgPSBldmUuYXMsIGdyYXBoID0gcm9vdC5ncmFwaCwgY3R4ID0gbXNnLl8sIHB1dCA9IG1zZy5wdXQsIHNvdWwgPSBwdXRbJyMnXSwga2V5ID0gcHV0WycuJ10sIHZhbCA9IHB1dFsnOiddLCBzdGF0ZSA9IHB1dFsnPiddLCBpZCA9IG1zZ1snIyddLCB0bXA7XG4gICAgICBcdGlmKCh0bXAgPSBjdHgubXNnKSAmJiAodG1wID0gdG1wLnB1dCkgJiYgKHRtcCA9IHRtcFtzb3VsXSkpeyBzdGF0ZV9pZnkodG1wLCBrZXksIHN0YXRlLCB2YWwsIHNvdWwpIH0gLy8gbmVjZXNzYXJ5ISBvciBlbHNlIG91dCBtZXNzYWdlcyBkbyBub3QgZ2V0IFNFQSB0cmFuc2Zvcm1zLlxuXHRcdFx0XHRncmFwaFtzb3VsXSA9IHN0YXRlX2lmeShncmFwaFtzb3VsXSwga2V5LCBzdGF0ZSwgdmFsLCBzb3VsKTtcblx0XHRcdFx0aWYodG1wID0gKHJvb3QubmV4dHx8JycpW3NvdWxdKXsgdG1wLm9uKCdpbicsIG1zZykgfVxuXHRcdFx0XHRmaXJlKGN0eCk7XG5cdFx0XHRcdGV2ZS50by5uZXh0KG1zZyk7XG5cdFx0XHR9XG5cdFx0XHRmdW5jdGlvbiBmaXJlKGN0eCwgbXNnKXsgdmFyIHJvb3Q7XG5cdFx0XHRcdGlmKGN0eC5zdG9wKXsgcmV0dXJuIH1cblx0XHRcdFx0aWYoIWN0eC5lcnIgJiYgMCA8IC0tY3R4LnN0dW4peyByZXR1cm4gfSAvLyBUT0RPOiAnZm9yZ2V0JyBmZWF0dXJlIGluIFNFQSB0aWVkIHRvIHRoaXMsIGJhZCBhcHByb2FjaCwgYnV0IGhhY2tlZCBpbiBmb3Igbm93LiBBbnkgY2hhbmdlcyBoZXJlIG11c3QgdXBkYXRlIHRoZXJlLlxuXHRcdFx0XHRjdHguc3RvcCA9IDE7XG5cdFx0XHRcdGlmKCEocm9vdCA9IGN0eC5yb290KSl7IHJldHVybiB9XG5cdFx0XHRcdHZhciB0bXAgPSBjdHgubWF0Y2g7IHRtcC5lbmQgPSAxO1xuXHRcdFx0XHRpZih0bXAgPT09IHJvb3QuaGF0Y2gpeyBpZighKHRtcCA9IGN0eC5sYXRjaCkgfHwgdG1wLmVuZCl7IGRlbGV0ZSByb290LmhhdGNoIH0gZWxzZSB7IHJvb3QuaGF0Y2ggPSB0bXAgfSB9XG5cdFx0XHRcdGN0eC5oYXRjaCAmJiBjdHguaGF0Y2goKTsgLy8gVE9ETzogcmVuYW1lL3Jld29yayBob3cgcHV0ICYgdGhpcyBpbnRlcmFjdC5cblx0XHRcdFx0c2V0VGltZW91dC5lYWNoKGN0eC5tYXRjaCwgZnVuY3Rpb24oY2Ipe2NiICYmIGNiKCl9KTsgXG5cdFx0XHRcdGlmKCEobXNnID0gY3R4Lm1zZykgfHwgY3R4LmVyciB8fCBtc2cuZXJyKXsgcmV0dXJuIH1cblx0XHRcdFx0bXNnLm91dCA9IHVuaXZlcnNlO1xuXHRcdFx0XHRjdHgucm9vdC5vbignb3V0JywgbXNnKTtcblxuXHRcdFx0XHRDRigpOyAvLyBjb3VydGVzeSBjaGVjaztcblx0XHRcdH1cblx0XHRcdGZ1bmN0aW9uIGFjayhtc2cpeyAvLyBhZ2dyZWdhdGUgQUNLcy5cblx0XHRcdFx0dmFyIGlkID0gbXNnWydAJ10gfHwgJycsIGN0eDtcblx0XHRcdFx0aWYoIShjdHggPSBpZC5fKSl7IHJldHVybiB9XG5cdFx0XHRcdGN0eC5hY2tzID0gKGN0eC5hY2tzfHwwKSArIDE7XG5cdFx0XHRcdGlmKGN0eC5lcnIgPSBtc2cuZXJyKXtcblx0XHRcdFx0XHRtc2dbJ0AnXSA9IGN0eFsnIyddO1xuXHRcdFx0XHRcdGZpcmUoY3R4KTsgLy8gVE9ETzogQlVHPyBIb3cgaXQgc2tpcHMvc3RvcHMgcHJvcGFnYXRpb24gb2YgbXNnIGlmIGFueSAxIGl0ZW0gaXMgZXJyb3IsIHRoaXMgd291bGQgYXNzdW1lIGEgd2hvbGUgYmF0Y2gvcmVzeW5jIGhhcyBzYW1lIG1hbGljaW91cyBpbnRlbnQuXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIWN0eC5zdG9wICYmICFjdHguY3JhY2speyBjdHguY3JhY2sgPSBjdHgubWF0Y2ggJiYgY3R4Lm1hdGNoLnB1c2goZnVuY3Rpb24oKXtiYWNrKGN0eCl9KSB9IC8vIGhhbmRsZSBzeW5jaHJvbm91cyBhY2tzXG5cdFx0XHRcdGJhY2soY3R4KTtcblx0XHRcdH1cblx0XHRcdGZ1bmN0aW9uIGJhY2soY3R4KXtcblx0XHRcdFx0aWYoIWN0eCB8fCAhY3R4LnJvb3QpeyByZXR1cm4gfVxuXHRcdFx0XHRpZihjdHguc3R1biB8fCBjdHguYWNrcyAhPT0gY3R4LmFsbCl7IHJldHVybiB9XG5cdFx0XHRcdGN0eC5yb290Lm9uKCdpbicsIHsnQCc6IGN0eFsnIyddLCBlcnI6IGN0eC5lcnIsIG9rOiBjdHguZXJyPyB1IDogeycnOjF9fSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBFUlIgPSBcIkVycm9yOiBJbnZhbGlkIGdyYXBoIVwiO1xuXHRcdFx0dmFyIGN1dCA9IGZ1bmN0aW9uKHMpeyByZXR1cm4gXCIgJ1wiKygnJytzKS5zbGljZSgwLDkpK1wiLi4uJyBcIiB9XG5cdFx0XHR2YXIgTCA9IEpTT04uc3RyaW5naWZ5LCBNRCA9IDIxNDc0ODM2NDcsIFN0YXRlID0gR3VuLnN0YXRlO1xuXHRcdFx0dmFyIEMgPSAwLCBDVCwgQ0YgPSBmdW5jdGlvbigpe2lmKEM+OTk5ICYmIChDLy0oQ1QgLSAoQ1QgPSArbmV3IERhdGUpKT4xKSl7R3VuLndpbmRvdyAmJiBjb25zb2xlLmxvZyhcIldhcm5pbmc6IFlvdSdyZSBzeW5jaW5nIDFLKyByZWNvcmRzIGEgc2Vjb25kLCBmYXN0ZXIgdGhhbiBET00gY2FuIHVwZGF0ZSAtIGNvbnNpZGVyIGxpbWl0aW5nIHF1ZXJ5LlwiKTtDRj1mdW5jdGlvbigpe0M9MH19fTtcblxuXHRcdH0oKSk7XG5cblx0XHQ7KGZ1bmN0aW9uKCl7XG5cdFx0XHRHdW4ub24uZ2V0ID0gZnVuY3Rpb24obXNnLCBndW4pe1xuXHRcdFx0XHR2YXIgcm9vdCA9IGd1bi5fLCBnZXQgPSBtc2cuZ2V0LCBzb3VsID0gZ2V0WycjJ10sIG5vZGUgPSByb290LmdyYXBoW3NvdWxdLCBoYXMgPSBnZXRbJy4nXTtcblx0XHRcdFx0dmFyIG5leHQgPSByb290Lm5leHQgfHwgKHJvb3QubmV4dCA9IHt9KSwgYXQgPSBuZXh0W3NvdWxdO1xuXHRcdFx0XHQvLyBxdWV1ZSBjb25jdXJyZW50IEdFVHM/XG5cdFx0XHRcdC8vIFRPRE86IGNvbnNpZGVyIHRhZ2dpbmcgb3JpZ2luYWwgbWVzc2FnZSBpbnRvIGR1cCBmb3IgREFNLlxuXHRcdFx0XHQvLyBUT0RPOiBeIGFib3ZlPyBJbiBjaGF0IGFwcCwgMTIgbWVzc2FnZXMgcmVzdWx0ZWQgaW4gc2FtZSBwZWVyIGFza2luZyBmb3IgYCN1c2VyLnB1YmAgMTIgdGltZXMuIChzYW1lIHdpdGggI3VzZXIgR0VUIHRvbywgeWlwZXMhKSAvLyBEQU0gbm90ZTogVGhpcyBhbHNvIHJlc3VsdGVkIGluIDEyIHJlcGxpZXMgZnJvbSAxIHBlZXIgd2hpY2ggYWxsIGhhZCBzYW1lICMjaGFzaCBidXQgbm9uZSBvZiB0aGVtIGRlZHVwZWQgYmVjYXVzZSBlYWNoIGdldCB3YXMgZGlmZmVyZW50LlxuXHRcdFx0XHQvLyBUT0RPOiBNb3ZpbmcgcXVpY2sgaGFja3MgZml4aW5nIHRoZXNlIHRoaW5ncyB0byBheGUgZm9yIG5vdy5cblx0XHRcdFx0Ly8gVE9ETzogYSBsb3Qgb2YgR0VUICNmb28gdGhlbiBHRVQgI2Zvby5cIlwiIGhhcHBlbmluZywgd2h5P1xuXHRcdFx0XHQvLyBUT0RPOiBEQU0ncyAjIyBoYXNoIGNoZWNrLCBvbiBzYW1lIGdldCBBQ0ssIHByb2R1Y2luZyBtdWx0aXBsZSByZXBsaWVzIHN0aWxsLCBtYXliZSBKU09OIHZzIFlTT04/XG5cdFx0XHRcdC8vIFRNUCBub3RlIGZvciBub3c6IHZpTVpxMXNsRyB3YXMgY2hhdCBMRVggcXVlcnkgIy5cblx0XHRcdFx0LyppZihndW4gIT09ICh0bXAgPSBtc2cuJCkgJiYgKHRtcCA9ICh0bXB8fCcnKS5fKSl7XG5cdFx0XHRcdFx0aWYodG1wLlEpeyB0bXAuUVttc2dbJyMnXV0gPSAnJzsgcmV0dXJuIH0gLy8gY2hhaW4gZG9lcyBub3QgbmVlZCB0byBhc2sgZm9yIGl0IGFnYWluLlxuXHRcdFx0XHRcdHRtcC5RID0ge307XG5cdFx0XHRcdH0qL1xuXHRcdFx0XHQvKmlmKHUgPT09IGhhcyl7XG5cdFx0XHRcdFx0aWYoYXQuUSl7XG5cdFx0XHRcdFx0XHQvL2F0LlFbbXNnWycjJ11dID0gJyc7XG5cdFx0XHRcdFx0XHQvL3JldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YXQuUSA9IHt9O1xuXHRcdFx0XHR9Ki9cblx0XHRcdFx0dmFyIGN0eCA9IG1zZy5ffHx7fSwgREJHID0gY3R4LkRCRyA9IG1zZy5EQkc7XG5cdFx0XHRcdERCRyAmJiAoREJHLmcgPSArbmV3IERhdGUpO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKFwiR0VUOlwiLCBnZXQsIG5vZGUsIGhhcyk7XG5cdFx0XHRcdGlmKCFub2RlKXsgcmV0dXJuIHJvb3Qub24oJ2dldCcsIG1zZykgfVxuXHRcdFx0XHRpZihoYXMpe1xuXHRcdFx0XHRcdGlmKCdzdHJpbmcnICE9IHR5cGVvZiBoYXMgfHwgdSA9PT0gbm9kZVtoYXNdKXsgcmV0dXJuIHJvb3Qub24oJ2dldCcsIG1zZykgfVxuXHRcdFx0XHRcdG5vZGUgPSBzdGF0ZV9pZnkoe30sIGhhcywgc3RhdGVfaXMobm9kZSwgaGFzKSwgbm9kZVtoYXNdLCBzb3VsKTtcblx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEga2V5IGluLW1lbW9yeSwgZG8gd2UgcmVhbGx5IG5lZWQgdG8gZmV0Y2g/XG5cdFx0XHRcdFx0Ly8gTWF5YmUuLi4gaW4gY2FzZSB0aGUgaW4tbWVtb3J5IGtleSB3ZSBoYXZlIGlzIGEgbG9jYWwgd3JpdGVcblx0XHRcdFx0XHQvLyB3ZSBzdGlsbCBuZWVkIHRvIHRyaWdnZXIgYSBwdWxsL21lcmdlIGZyb20gcGVlcnMuXG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9HdW4ud2luZG93PyBHdW4ub2JqLmNvcHkobm9kZSkgOiBub2RlOyAvLyBITlBFUkY6IElmICFicm93c2VyIGJ1bXAgUGVyZm9ybWFuY2U/IElzIHRoaXMgdG9vIGRhbmdlcm91cyB0byByZWZlcmVuY2Ugcm9vdCBncmFwaD8gQ29weSAvIHNoYWxsb3cgY29weSB0b28gZXhwZW5zaXZlIGZvciBiaWcgbm9kZXMuIEd1bi5vYmoudG8obm9kZSk7IC8vIDEgbGF5ZXIgZGVlcCBjb3B5IC8vIEd1bi5vYmouY29weShub2RlKTsgLy8gdG9vIHNsb3cgb24gYmlnIG5vZGVzXG5cdFx0XHRcdG5vZGUgJiYgYWNrKG1zZywgbm9kZSk7XG5cdFx0XHRcdHJvb3Qub24oJ2dldCcsIG1zZyk7IC8vIHNlbmQgR0VUIHRvIHN0b3JhZ2UgYWRhcHRlcnMuXG5cdFx0XHR9XG5cdFx0XHRmdW5jdGlvbiBhY2sobXNnLCBub2RlKXtcblx0XHRcdFx0dmFyIFMgPSArbmV3IERhdGUsIGN0eCA9IG1zZy5ffHx7fSwgREJHID0gY3R4LkRCRyA9IG1zZy5EQkc7XG5cdFx0XHRcdHZhciB0byA9IG1zZ1snIyddLCBpZCA9IHRleHRfcmFuZCg5KSwga2V5cyA9IE9iamVjdC5rZXlzKG5vZGV8fCcnKS5zb3J0KCksIHNvdWwgPSAoKG5vZGV8fCcnKS5ffHwnJylbJyMnXSwga2wgPSBrZXlzLmxlbmd0aCwgaiA9IDAsIHJvb3QgPSBtc2cuJC5fLnJvb3QsIEYgPSAobm9kZSA9PT0gcm9vdC5ncmFwaFtzb3VsXSk7XG5cdFx0XHRcdGNvbnNvbGUuU1RBVCAmJiBjb25zb2xlLlNUQVQoUywgKChEQkd8fGN0eCkuZ2sgPSArbmV3IERhdGUpIC0gUywgJ2dvdCBrZXlzJyk7XG5cdFx0XHRcdC8vIFBFUkY6IENvbnNpZGVyIGNvbW1lbnRpbmcgdGhpcyBvdXQgdG8gZm9yY2UgZGlzay1vbmx5IHJlYWRzIGZvciBwZXJmIHRlc3Rpbmc/IC8vIFRPRE86IC5rZXlzKCBpcyBzbG93XG5cdFx0XHRcdG5vZGUgJiYgKGZ1bmN0aW9uIGdvKCl7XG5cdFx0XHRcdFx0UyA9ICtuZXcgRGF0ZTtcblx0XHRcdFx0XHR2YXIgaSA9IDAsIGssIHB1dCA9IHt9LCB0bXA7XG5cdFx0XHRcdFx0d2hpbGUoaSA8IDkgJiYgKGsgPSBrZXlzW2krK10pKXtcblx0XHRcdFx0XHRcdHN0YXRlX2lmeShwdXQsIGssIHN0YXRlX2lzKG5vZGUsIGspLCBub2RlW2tdLCBzb3VsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0a2V5cyA9IGtleXMuc2xpY2UoaSk7XG5cdFx0XHRcdFx0KHRtcCA9IHt9KVtzb3VsXSA9IHB1dDsgcHV0ID0gdG1wO1xuXHRcdFx0XHRcdHZhciBmYWl0aDsgaWYoRil7IGZhaXRoID0gZnVuY3Rpb24oKXt9OyBmYWl0aC5yYW0gPSBmYWl0aC5mYWl0aCA9IHRydWU7IH0gLy8gSE5QRVJGOiBXZSdyZSB0ZXN0aW5nIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50IGJ5IHNraXBwaW5nIGdvaW5nIHRocm91Z2ggc2VjdXJpdHkgYWdhaW4sIGJ1dCB0aGlzIHNob3VsZCBiZSBhdWRpdGVkLlxuXHRcdFx0XHRcdHRtcCA9IGtleXMubGVuZ3RoO1xuXHRcdFx0XHRcdGNvbnNvbGUuU1RBVCAmJiBjb25zb2xlLlNUQVQoUywgLShTIC0gKFMgPSArbmV3IERhdGUpKSwgJ2dvdCBjb3BpZWQgc29tZScpO1xuXHRcdFx0XHRcdERCRyAmJiAoREJHLmdhID0gK25ldyBEYXRlKTtcblx0XHRcdFx0XHRyb290Lm9uKCdpbicsIHsnQCc6IHRvLCAnIyc6IGlkLCBwdXQ6IHB1dCwgJyUnOiAodG1wPyAoaWQgPSB0ZXh0X3JhbmQoOSkpIDogdSksICQ6IHJvb3QuJCwgXzogZmFpdGgsIERCRzogREJHfSk7XG5cdFx0XHRcdFx0Y29uc29sZS5TVEFUICYmIGNvbnNvbGUuU1RBVChTLCArbmV3IERhdGUgLSBTLCAnZ290IGluJyk7XG5cdFx0XHRcdFx0aWYoIXRtcCl7IHJldHVybiB9XG5cdFx0XHRcdFx0c2V0VGltZW91dC50dXJuKGdvKTtcblx0XHRcdFx0fSgpKTtcblx0XHRcdFx0aWYoIW5vZGUpeyByb290Lm9uKCdpbicsIHsnQCc6IG1zZ1snIyddfSkgfSAvLyBUT0RPOiBJIGRvbid0IHRoaW5rIEkgbGlrZSB0aGlzLCB0aGUgZGVmYXVsdCBsUyBhZGFwdGVyIHVzZXMgdGhpcyBidXQgXCJub3QgZm91bmRcIiBpcyBhIHNlbnNpdGl2ZSBpc3N1ZSwgc28gc2hvdWxkIHByb2JhYmx5IGJlIGhhbmRsZWQgbW9yZSBjYXJlZnVsbHkvaW5kaXZpZHVhbGx5LlxuXHRcdFx0fSBHdW4ub24uZ2V0LmFjayA9IGFjaztcblx0XHR9KCkpO1xuXG5cdFx0OyhmdW5jdGlvbigpe1xuXHRcdFx0R3VuLmNoYWluLm9wdCA9IGZ1bmN0aW9uKG9wdCl7XG5cdFx0XHRcdG9wdCA9IG9wdCB8fCB7fTtcblx0XHRcdFx0dmFyIGd1biA9IHRoaXMsIGF0ID0gZ3VuLl8sIHRtcCA9IG9wdC5wZWVycyB8fCBvcHQ7XG5cdFx0XHRcdGlmKCFPYmplY3QucGxhaW4ob3B0KSl7IG9wdCA9IHt9IH1cblx0XHRcdFx0aWYoIU9iamVjdC5wbGFpbihhdC5vcHQpKXsgYXQub3B0ID0gb3B0IH1cblx0XHRcdFx0aWYoJ3N0cmluZycgPT0gdHlwZW9mIHRtcCl7IHRtcCA9IFt0bXBdIH1cblx0XHRcdFx0aWYoIU9iamVjdC5wbGFpbihhdC5vcHQucGVlcnMpKXsgYXQub3B0LnBlZXJzID0ge319XG5cdFx0XHRcdGlmKHRtcCBpbnN0YW5jZW9mIEFycmF5KXtcblx0XHRcdFx0XHRvcHQucGVlcnMgPSB7fTtcblx0XHRcdFx0XHR0bXAuZm9yRWFjaChmdW5jdGlvbih1cmwpe1xuXHRcdFx0XHRcdFx0dmFyIHAgPSB7fTsgcC5pZCA9IHAudXJsID0gdXJsO1xuXHRcdFx0XHRcdFx0b3B0LnBlZXJzW3VybF0gPSBhdC5vcHQucGVlcnNbdXJsXSA9IGF0Lm9wdC5wZWVyc1t1cmxdIHx8IHA7XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fVxuXHRcdFx0XHRvYmpfZWFjaChvcHQsIGZ1bmN0aW9uIGVhY2goayl7IHZhciB2ID0gdGhpc1trXTtcblx0XHRcdFx0XHRpZigodGhpcyAmJiB0aGlzLmhhc093blByb3BlcnR5KGspKSB8fCAnc3RyaW5nJyA9PSB0eXBlb2YgdiB8fCBPYmplY3QuZW1wdHkodikpeyB0aGlzW2tdID0gdjsgcmV0dXJuIH1cblx0XHRcdFx0XHRpZih2ICYmIHYuY29uc3RydWN0b3IgIT09IE9iamVjdCAmJiAhKHYgaW5zdGFuY2VvZiBBcnJheSkpeyByZXR1cm4gfVxuXHRcdFx0XHRcdG9ial9lYWNoKHYsIGVhY2gpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0YXQub3B0LmZyb20gPSBvcHQ7XG5cdFx0XHRcdEd1bi5vbignb3B0JywgYXQpO1xuXHRcdFx0XHRhdC5vcHQudXVpZCA9IGF0Lm9wdC51dWlkIHx8IGZ1bmN0aW9uIHV1aWQobCl7IHJldHVybiBHdW4uc3RhdGUoKS50b1N0cmluZygzNikucmVwbGFjZSgnLicsJycpICsgU3RyaW5nLnJhbmRvbShsfHwxMikgfVxuXHRcdFx0XHRyZXR1cm4gZ3VuO1xuXHRcdFx0fVxuXHRcdH0oKSk7XG5cblx0XHR2YXIgb2JqX2VhY2ggPSBmdW5jdGlvbihvLGYpeyBPYmplY3Qua2V5cyhvKS5mb3JFYWNoKGYsbykgfSwgdGV4dF9yYW5kID0gU3RyaW5nLnJhbmRvbSwgdHVybiA9IHNldFRpbWVvdXQudHVybiwgdmFsaWQgPSBHdW4udmFsaWQsIHN0YXRlX2lzID0gR3VuLnN0YXRlLmlzLCBzdGF0ZV9pZnkgPSBHdW4uc3RhdGUuaWZ5LCB1LCBlbXB0eSA9IHt9LCBDO1xuXG5cdFx0R3VuLmxvZyA9IGZ1bmN0aW9uKCl7IHJldHVybiAoIUd1bi5sb2cub2ZmICYmIEMubG9nLmFwcGx5KEMsIGFyZ3VtZW50cykpLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbignICcpIH07XG5cdFx0R3VuLmxvZy5vbmNlID0gZnVuY3Rpb24odyxzLG8peyByZXR1cm4gKG8gPSBHdW4ubG9nLm9uY2UpW3ddID0gb1t3XSB8fCAwLCBvW3ddKysgfHwgR3VuLmxvZyhzKSB9O1xuXG5cdFx0aWYodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIil7ICh3aW5kb3cuR1VOID0gd2luZG93Lkd1biA9IEd1bikud2luZG93ID0gd2luZG93IH1cblx0XHR0cnl7IGlmKHR5cGVvZiBNT0RVTEUgIT09IFwidW5kZWZpbmVkXCIpeyBNT0RVTEUuZXhwb3J0cyA9IEd1biB9IH1jYXRjaChlKXt9XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBHdW47XG5cdFx0XG5cdFx0KEd1bi53aW5kb3d8fHt9KS5jb25zb2xlID0gKEd1bi53aW5kb3d8fHt9KS5jb25zb2xlIHx8IHtsb2c6IGZ1bmN0aW9uKCl7fX07XG5cdFx0KEMgPSBjb25zb2xlKS5vbmx5ID0gZnVuY3Rpb24oaSwgcyl7IHJldHVybiAoQy5vbmx5LmkgJiYgaSA9PT0gQy5vbmx5LmkgJiYgQy5vbmx5LmkrKykgJiYgKEMubG9nLmFwcGx5KEMsIGFyZ3VtZW50cykgfHwgcykgfTtcblxuXHRcdDtcIlBsZWFzZSBkbyBub3QgcmVtb3ZlIHdlbGNvbWUgbG9nIHVubGVzcyB5b3UgYXJlIHBheWluZyBmb3IgYSBtb250aGx5IHNwb25zb3JzaGlwLCB0aGFua3MhXCI7XG5cdFx0R3VuLmxvZy5vbmNlKFwid2VsY29tZVwiLCBcIkhlbGxvIHdvbmRlcmZ1bCBwZXJzb24hIDopIFRoYW5rcyBmb3IgdXNpbmcgR1VOLCBwbGVhc2UgYXNrIGZvciBoZWxwIG9uIGh0dHA6Ly9jaGF0Lmd1bi5lY28gaWYgYW55dGhpbmcgdGFrZXMgeW91IGxvbmdlciB0aGFuIDVtaW4gdG8gZmlndXJlIG91dCFcIik7XG5cdH0pKFVTRSwgJy4vcm9vdCcpO1xuXG5cdDtVU0UoZnVuY3Rpb24obW9kdWxlKXtcblx0XHR2YXIgR3VuID0gVVNFKCcuL3Jvb3QnKTtcblx0XHRHdW4uY2hhaW4uYmFjayA9IGZ1bmN0aW9uKG4sIG9wdCl7IHZhciB0bXA7XG5cdFx0XHRuID0gbiB8fCAxO1xuXHRcdFx0aWYoLTEgPT09IG4gfHwgSW5maW5pdHkgPT09IG4pe1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fLnJvb3QuJDtcblx0XHRcdH0gZWxzZVxuXHRcdFx0aWYoMSA9PT0gbil7XG5cdFx0XHRcdHJldHVybiAodGhpcy5fLmJhY2sgfHwgdGhpcy5fKS4kO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGd1biA9IHRoaXMsIGF0ID0gZ3VuLl87XG5cdFx0XHRpZih0eXBlb2YgbiA9PT0gJ3N0cmluZycpe1xuXHRcdFx0XHRuID0gbi5zcGxpdCgnLicpO1xuXHRcdFx0fVxuXHRcdFx0aWYobiBpbnN0YW5jZW9mIEFycmF5KXtcblx0XHRcdFx0dmFyIGkgPSAwLCBsID0gbi5sZW5ndGgsIHRtcCA9IGF0O1xuXHRcdFx0XHRmb3IoaTsgaSA8IGw7IGkrKyl7XG5cdFx0XHRcdFx0dG1wID0gKHRtcHx8ZW1wdHkpW25baV1dO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHUgIT09IHRtcCl7XG5cdFx0XHRcdFx0cmV0dXJuIG9wdD8gZ3VuIDogdG1wO1xuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0aWYoKHRtcCA9IGF0LmJhY2spKXtcblx0XHRcdFx0XHRyZXR1cm4gdG1wLiQuYmFjayhuLCBvcHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmKCdmdW5jdGlvbicgPT0gdHlwZW9mIG4pe1xuXHRcdFx0XHR2YXIgeWVzLCB0bXAgPSB7YmFjazogYXR9O1xuXHRcdFx0XHR3aGlsZSgodG1wID0gdG1wLmJhY2spXG5cdFx0XHRcdCYmIHUgPT09ICh5ZXMgPSBuKHRtcCwgb3B0KSkpe31cblx0XHRcdFx0cmV0dXJuIHllcztcblx0XHRcdH1cblx0XHRcdGlmKCdudW1iZXInID09IHR5cGVvZiBuKXtcblx0XHRcdFx0cmV0dXJuIChhdC5iYWNrIHx8IGF0KS4kLmJhY2sobiAtIDEpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdHZhciBlbXB0eSA9IHt9LCB1O1xuXHR9KShVU0UsICcuL2JhY2snKTtcblxuXHQ7VVNFKGZ1bmN0aW9uKG1vZHVsZSl7XG5cdFx0Ly8gV0FSTklORzogR1VOIGlzIHZlcnkgc2ltcGxlLCBidXQgdGhlIEphdmFTY3JpcHQgY2hhaW5pbmcgQVBJIGFyb3VuZCBHVU5cblx0XHQvLyBpcyBjb21wbGljYXRlZCBhbmQgd2FzIGV4dHJlbWVseSBoYXJkIHRvIGJ1aWxkLiBJZiB5b3UgcG9ydCBHVU4gdG8gYW5vdGhlclxuXHRcdC8vIGxhbmd1YWdlLCBjb25zaWRlciBpbXBsZW1lbnRpbmcgYW4gZWFzaWVyIEFQSSB0byBidWlsZC5cblx0XHR2YXIgR3VuID0gVVNFKCcuL3Jvb3QnKTtcblx0XHRHdW4uY2hhaW4uY2hhaW4gPSBmdW5jdGlvbihzdWIpe1xuXHRcdFx0dmFyIGd1biA9IHRoaXMsIGF0ID0gZ3VuLl8sIGNoYWluID0gbmV3IChzdWIgfHwgZ3VuKS5jb25zdHJ1Y3RvcihndW4pLCBjYXQgPSBjaGFpbi5fLCByb290O1xuXHRcdFx0Y2F0LnJvb3QgPSByb290ID0gYXQucm9vdDtcblx0XHRcdGNhdC5pZCA9ICsrcm9vdC5vbmNlO1xuXHRcdFx0Y2F0LmJhY2sgPSBndW4uXztcblx0XHRcdGNhdC5vbiA9IEd1bi5vbjtcblx0XHRcdGNhdC5vbignaW4nLCBHdW4ub24uaW4sIGNhdCk7IC8vIEZvciAnaW4nIGlmIEkgYWRkIG15IG93biBsaXN0ZW5lcnMgdG8gZWFjaCB0aGVuIEkgTVVTVCBkbyBpdCBiZWZvcmUgaW4gZ2V0cyBjYWxsZWQuIElmIEkgbGlzdGVuIGdsb2JhbGx5IGZvciBhbGwgaW5jb21pbmcgZGF0YSBpbnN0ZWFkIHRob3VnaCwgcmVnYXJkbGVzcyBvZiBpbmRpdmlkdWFsIGxpc3RlbmVycywgSSBjYW4gdHJhbnNmb3JtIHRoZSBkYXRhIHRoZXJlIGFuZCB0aGVuIGFzIHdlbGwuXG5cdFx0XHRjYXQub24oJ291dCcsIEd1bi5vbi5vdXQsIGNhdCk7IC8vIEhvd2V2ZXIgZm9yIG91dHB1dCwgdGhlcmUgaXNuJ3QgcmVhbGx5IHRoZSBnbG9iYWwgb3B0aW9uLiBJIG11c3QgbGlzdGVuIGJ5IGFkZGluZyBteSBvd24gbGlzdGVuZXIgaW5kaXZpZHVhbGx5IEJFRk9SRSB0aGlzIG9uZSBpcyBldmVyIGNhbGxlZC5cblx0XHRcdHJldHVybiBjaGFpbjtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvdXRwdXQobXNnKXtcblx0XHRcdHZhciBwdXQsIGdldCwgYXQgPSB0aGlzLmFzLCBiYWNrID0gYXQuYmFjaywgcm9vdCA9IGF0LnJvb3QsIHRtcDtcblx0XHRcdGlmKCFtc2cuJCl7IG1zZy4kID0gYXQuJCB9XG5cdFx0XHR0aGlzLnRvLm5leHQobXNnKTtcblx0XHRcdGlmKGF0LmVycil7IGF0Lm9uKCdpbicsIHtwdXQ6IGF0LnB1dCA9IHUsICQ6IGF0LiR9KTsgcmV0dXJuIH1cblx0XHRcdGlmKGdldCA9IG1zZy5nZXQpe1xuXHRcdFx0XHQvKmlmKHUgIT09IGF0LnB1dCl7XG5cdFx0XHRcdFx0YXQub24oJ2luJywgYXQpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fSovXG5cdFx0XHRcdGlmKHJvb3QucGFzcyl7IHJvb3QucGFzc1thdC5pZF0gPSBhdDsgfSAvLyB3aWxsIHRoaXMgbWFrZSBmb3IgYnVnZ3kgYmVoYXZpb3IgZWxzZXdoZXJlP1xuXHRcdFx0XHRpZihhdC5sZXgpeyBPYmplY3Qua2V5cyhhdC5sZXgpLmZvckVhY2goZnVuY3Rpb24oayl7IHRtcFtrXSA9IGF0LmxleFtrXSB9LCB0bXAgPSBtc2cuZ2V0ID0gbXNnLmdldCB8fCB7fSkgfVxuXHRcdFx0XHRpZihnZXRbJyMnXSB8fCBhdC5zb3VsKXtcblx0XHRcdFx0XHRnZXRbJyMnXSA9IGdldFsnIyddIHx8IGF0LnNvdWw7XG5cdFx0XHRcdFx0bXNnWycjJ10gfHwgKG1zZ1snIyddID0gdGV4dF9yYW5kKDkpKTsgLy8gQTMxMjAgP1xuXHRcdFx0XHRcdGJhY2sgPSAocm9vdC4kLmdldChnZXRbJyMnXSkuXyk7XG5cdFx0XHRcdFx0aWYoIShnZXQgPSBnZXRbJy4nXSkpeyAvLyBzb3VsXG5cdFx0XHRcdFx0XHR0bXAgPSBiYWNrLmFzayAmJiBiYWNrLmFza1snJ107IC8vIGNoZWNrIGlmIHdlIGhhdmUgYWxyZWFkeSBhc2tlZCBmb3IgdGhlIGZ1bGwgbm9kZVxuXHRcdFx0XHRcdFx0KGJhY2suYXNrIHx8IChiYWNrLmFzayA9IHt9KSlbJyddID0gYmFjazsgLy8gYWRkIGEgZmxhZyB0aGF0IHdlIGFyZSBub3cuXG5cdFx0XHRcdFx0XHRpZih1ICE9PSBiYWNrLnB1dCl7IC8vIGlmIHdlIGFscmVhZHkgaGF2ZSBkYXRhLFxuXHRcdFx0XHRcdFx0XHRiYWNrLm9uKCdpbicsIGJhY2spOyAvLyBzZW5kIHdoYXQgaXMgY2FjaGVkIGRvd24gdGhlIGNoYWluXG5cdFx0XHRcdFx0XHRcdGlmKHRtcCl7IHJldHVybiB9IC8vIGFuZCBkb24ndCBhc2sgZm9yIGl0IGFnYWluLlxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bXNnLiQgPSBiYWNrLiQ7XG5cdFx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0aWYob2JqX2hhcyhiYWNrLnB1dCwgZ2V0KSl7IC8vIFRPRE86IHN1cHBvcnQgI0xFWCAhXG5cdFx0XHRcdFx0XHR0bXAgPSBiYWNrLmFzayAmJiBiYWNrLmFza1tnZXRdO1xuXHRcdFx0XHRcdFx0KGJhY2suYXNrIHx8IChiYWNrLmFzayA9IHt9KSlbZ2V0XSA9IGJhY2suJC5nZXQoZ2V0KS5fO1xuXHRcdFx0XHRcdFx0YmFjay5vbignaW4nLCB7Z2V0OiBnZXQsIHB1dDogeycjJzogYmFjay5zb3VsLCAnLic6IGdldCwgJzonOiBiYWNrLnB1dFtnZXRdLCAnPic6IHN0YXRlX2lzKHJvb3QuZ3JhcGhbYmFjay5zb3VsXSwgZ2V0KX19KTtcblx0XHRcdFx0XHRcdGlmKHRtcCl7IHJldHVybiB9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0LypwdXQgPSAoYmFjay4kLmdldChnZXQpLl8pO1xuXHRcdFx0XHRcdFx0aWYoISh0bXAgPSBwdXQuYWNrKSl7IHB1dC5hY2sgPSAtMSB9XG5cdFx0XHRcdFx0XHRiYWNrLm9uKCdpbicsIHtcblx0XHRcdFx0XHRcdFx0JDogYmFjay4kLFxuXHRcdFx0XHRcdFx0XHRwdXQ6IEd1bi5zdGF0ZS5pZnkoe30sIGdldCwgR3VuLnN0YXRlKGJhY2sucHV0LCBnZXQpLCBiYWNrLnB1dFtnZXRdKSxcblx0XHRcdFx0XHRcdFx0Z2V0OiBiYWNrLmdldFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRpZih0bXApeyByZXR1cm4gfVxuXHRcdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdGlmKCdzdHJpbmcnICE9IHR5cGVvZiBnZXQpe1xuXHRcdFx0XHRcdFx0dmFyIHB1dCA9IHt9LCBtZXRhID0gKGJhY2sucHV0fHx7fSkuXztcblx0XHRcdFx0XHRcdEd1bi5vYmoubWFwKGJhY2sucHV0LCBmdW5jdGlvbih2LGspe1xuXHRcdFx0XHRcdFx0XHRpZighR3VuLnRleHQubWF0Y2goaywgZ2V0KSl7IHJldHVybiB9XG5cdFx0XHRcdFx0XHRcdHB1dFtrXSA9IHY7XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0aWYoIUd1bi5vYmouZW1wdHkocHV0KSl7XG5cdFx0XHRcdFx0XHRcdHB1dC5fID0gbWV0YTtcblx0XHRcdFx0XHRcdFx0YmFjay5vbignaW4nLCB7JDogYmFjay4kLCBwdXQ6IHB1dCwgZ2V0OiBiYWNrLmdldH0pXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZih0bXAgPSBhdC5sZXgpe1xuXHRcdFx0XHRcdFx0XHR0bXAgPSAodG1wLl8pIHx8ICh0bXAuXyA9IGZ1bmN0aW9uKCl7fSk7XG5cdFx0XHRcdFx0XHRcdGlmKGJhY2suYWNrIDwgdG1wLmFzayl7IHRtcC5hc2sgPSBiYWNrLmFjayB9XG5cdFx0XHRcdFx0XHRcdGlmKHRtcC5hc2speyByZXR1cm4gfVxuXHRcdFx0XHRcdFx0XHR0bXAuYXNrID0gMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ki9cblx0XHRcdFx0XHRyb290LmFzayhhY2ssIG1zZyk7IC8vIEEzMTIwID9cblx0XHRcdFx0XHRyZXR1cm4gcm9vdC5vbignaW4nLCBtc2cpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vaWYocm9vdC5ub3cpeyByb290Lm5vd1thdC5pZF0gPSByb290Lm5vd1thdC5pZF0gfHwgdHJ1ZTsgYXQucGFzcyA9IHt9IH1cblx0XHRcdFx0aWYoZ2V0WycuJ10pe1xuXHRcdFx0XHRcdGlmKGF0LmdldCl7XG5cdFx0XHRcdFx0XHRtc2cgPSB7Z2V0OiB7Jy4nOiBhdC5nZXR9LCAkOiBhdC4kfTtcblx0XHRcdFx0XHRcdChiYWNrLmFzayB8fCAoYmFjay5hc2sgPSB7fSkpW2F0LmdldF0gPSBtc2cuJC5fOyAvLyBUT0RPOiBQRVJGT1JNQU5DRT8gTW9yZSBlbGVnYW50IHdheT9cblx0XHRcdFx0XHRcdHJldHVybiBiYWNrLm9uKCdvdXQnLCBtc2cpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtc2cgPSB7Z2V0OiBhdC5sZXg/IG1zZy5nZXQgOiB7fSwgJDogYXQuJH07XG5cdFx0XHRcdFx0cmV0dXJuIGJhY2sub24oJ291dCcsIG1zZyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0KGF0LmFzayB8fCAoYXQuYXNrID0ge30pKVsnJ10gPSBhdDtcdCAvL2F0LmFjayA9IGF0LmFjayB8fCAtMTtcblx0XHRcdFx0aWYoYXQuZ2V0KXtcblx0XHRcdFx0XHRnZXRbJy4nXSA9IGF0LmdldDtcblx0XHRcdFx0XHQoYmFjay5hc2sgfHwgKGJhY2suYXNrID0ge30pKVthdC5nZXRdID0gbXNnLiQuXzsgLy8gVE9ETzogUEVSRk9STUFOQ0U/IE1vcmUgZWxlZ2FudCB3YXk/XG5cdFx0XHRcdFx0cmV0dXJuIGJhY2sub24oJ291dCcsIG1zZyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBiYWNrLm9uKCdvdXQnLCBtc2cpO1xuXHRcdH07IEd1bi5vbi5vdXQgPSBvdXRwdXQ7XG5cblx0XHRmdW5jdGlvbiBpbnB1dChtc2csIGNhdCl7IGNhdCA9IGNhdCB8fCB0aGlzLmFzOyAvLyBUT0RPOiBWOCBtYXkgbm90IGJlIGFibGUgdG8gb3B0aW1pemUgZnVuY3Rpb25zIHdpdGggZGlmZmVyZW50IHBhcmFtZXRlciBjYWxscywgc28gdHJ5IHRvIGRvIGJlbmNobWFyayB0byBzZWUgaWYgdGhlcmUgaXMgYW55IGFjdHVhbCBkaWZmZXJlbmNlLlxuXHRcdFx0dmFyIHJvb3QgPSBjYXQucm9vdCwgZ3VuID0gbXNnLiQgfHwgKG1zZy4kID0gY2F0LiQpLCBhdCA9IChndW58fCcnKS5fIHx8IGVtcHR5LCB0bXAgPSBtc2cucHV0fHwnJywgc291bCA9IHRtcFsnIyddLCBrZXkgPSB0bXBbJy4nXSwgY2hhbmdlID0gKHUgIT09IHRtcFsnPSddKT8gdG1wWyc9J10gOiB0bXBbJzonXSwgc3RhdGUgPSB0bXBbJz4nXSB8fCAtSW5maW5pdHksIHNhdDsgLy8gZXZlID0gZXZlbnQsIGF0ID0gZGF0YSBhdCwgY2F0ID0gY2hhaW4gYXQsIHNhdCA9IHN1YiBhdCAoY2hpbGRyZW4gY2hhaW5zKS5cblx0XHRcdGlmKHUgIT09IG1zZy5wdXQgJiYgKHUgPT09IHRtcFsnIyddIHx8IHUgPT09IHRtcFsnLiddIHx8ICh1ID09PSB0bXBbJzonXSAmJiB1ID09PSB0bXBbJz0nXSkgfHwgdSA9PT0gdG1wWyc+J10pKXsgLy8gY29udmVydCBmcm9tIG9sZCBmb3JtYXRcblx0XHRcdFx0aWYoIXZhbGlkKHRtcCkpe1xuXHRcdFx0XHRcdGlmKCEoc291bCA9ICgodG1wfHwnJykuX3x8JycpWycjJ10pKXsgY29uc29sZS5sb2coXCJjaGFpbiBub3QgeWV0IHN1cHBvcnRlZCBmb3JcIiwgdG1wLCAnLi4uJywgbXNnLCBjYXQpOyByZXR1cm47IH1cblx0XHRcdFx0XHRndW4gPSBjYXQucm9vdC4kLmdldChzb3VsKTtcblx0XHRcdFx0XHRyZXR1cm4gc2V0VGltZW91dC5lYWNoKE9iamVjdC5rZXlzKHRtcCkuc29ydCgpLCBmdW5jdGlvbihrKXsgLy8gVE9ETzogLmtleXMoIGlzIHNsb3cgLy8gQlVHPyA/U29tZSByZS1pbiBsb2dpYyBtYXkgZGVwZW5kIG9uIHRoaXMgYmVpbmcgc3luYz9cblx0XHRcdFx0XHRcdGlmKCdfJyA9PSBrIHx8IHUgPT09IChzdGF0ZSA9IHN0YXRlX2lzKHRtcCwgaykpKXsgcmV0dXJuIH1cblx0XHRcdFx0XHRcdGNhdC5vbignaW4nLCB7JDogZ3VuLCBwdXQ6IHsnIyc6IHNvdWwsICcuJzogaywgJz0nOiB0bXBba10sICc+Jzogc3RhdGV9LCBWSUE6IG1zZ30pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhdC5vbignaW4nLCB7JDogYXQuYmFjay4kLCBwdXQ6IHsnIyc6IHNvdWwgPSBhdC5iYWNrLnNvdWwsICcuJzoga2V5ID0gYXQuaGFzIHx8IGF0LmdldCwgJz0nOiB0bXAsICc+Jzogc3RhdGVfaXMoYXQuYmFjay5wdXQsIGtleSl9LCB2aWE6IG1zZ30pOyAvLyBUT0RPOiBUaGlzIGNvdWxkIGJlIGJ1Z2d5ISBJdCBhc3N1bWVzL2FwcHJveGVzIGRhdGEsIG90aGVyIHN0dWZmIGNvdWxkIGhhdmUgY29ycnVwdGVkIGl0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZigobXNnLnNlZW58fCcnKVtjYXQuaWRdKXsgcmV0dXJuIH0gKG1zZy5zZWVuIHx8IChtc2cuc2VlbiA9IGZ1bmN0aW9uKCl7fSkpW2NhdC5pZF0gPSBjYXQ7IC8vIGhlbHAgc3RvcCBzb21lIGluZmluaXRlIGxvb3BzXG5cblx0XHRcdGlmKGNhdCAhPT0gYXQpeyAvLyBkb24ndCB3b3JyeSBhYm91dCB0aGlzIHdoZW4gZmlyc3QgdW5kZXJzdGFuZGluZyB0aGUgY29kZSwgaXQgaGFuZGxlcyBjaGFuZ2luZyBjb250ZXh0cyBvbiBhIG1lc3NhZ2UuIEEgc291bCBjaGFpbiB3aWxsIG5ldmVyIGhhdmUgYSBkaWZmZXJlbnQgY29udGV4dC5cblx0XHRcdFx0T2JqZWN0LmtleXMobXNnKS5mb3JFYWNoKGZ1bmN0aW9uKGspeyB0bXBba10gPSBtc2dba10gfSwgdG1wID0ge30pOyAvLyBtYWtlIGNvcHkgb2YgbWVzc2FnZVxuXHRcdFx0XHR0bXAuZ2V0ID0gY2F0LmdldCB8fCB0bXAuZ2V0O1xuXHRcdFx0XHRpZighY2F0LnNvdWwgJiYgIWNhdC5oYXMpeyAvLyBpZiB3ZSBkbyBub3QgcmVjb2duaXplIHRoZSBjaGFpbiB0eXBlXG5cdFx0XHRcdFx0dG1wLiQkJCA9IHRtcC4kJCQgfHwgY2F0LiQ7IC8vIG1ha2UgYSByZWZlcmVuY2UgdG8gd2hlcmV2ZXIgaXQgY2FtZSBmcm9tLlxuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0aWYoYXQuc291bCl7IC8vIGEgaGFzIChwcm9wZXJ0eSkgY2hhaW4gd2lsbCBoYXZlIGEgZGlmZmVyZW50IGNvbnRleHQgc29tZXRpbWVzIGlmIGl0IGlzIGxpbmtlZCAodG8gYSBzb3VsIGNoYWluKS4gQW55dGhpbmcgdGhhdCBpcyBub3QgYSBzb3VsIG9yIGhhcyBjaGFpbiwgd2lsbCBhbHdheXMgaGF2ZSBkaWZmZXJlbnQgY29udGV4dHMuXG5cdFx0XHRcdFx0dG1wLiQgPSBjYXQuJDtcblx0XHRcdFx0XHR0bXAuJCQgPSB0bXAuJCQgfHwgYXQuJDtcblx0XHRcdFx0fVxuXHRcdFx0XHRtc2cgPSB0bXA7IC8vIHVzZSB0aGUgbWVzc2FnZSB3aXRoIHRoZSBuZXcgY29udGV4dCBpbnN0ZWFkO1xuXHRcdFx0fVxuXHRcdFx0dW5saW5rKG1zZywgY2F0KTtcblxuXHRcdFx0aWYoKChjYXQuc291bC8qICYmIChjYXQuYXNrfHwnJylbJyddKi8pIHx8IG1zZy4kJCkgJiYgc3RhdGUgPj0gc3RhdGVfaXMocm9vdC5ncmFwaFtzb3VsXSwga2V5KSl7IC8vIFRoZSByb290IGhhcyBhbiBpbi1tZW1vcnkgY2FjaGUgb2YgdGhlIGdyYXBoLCBidXQgaWYgb3VyIHBlZXIgaGFzIGFza2VkIGZvciB0aGUgZGF0YSB0aGVuIHdlIHdhbnQgYSBwZXIgZGVkdXBsaWNhdGVkIGNoYWluIGNvcHkgb2YgdGhlIGRhdGEgdGhhdCBtaWdodCBoYXZlIGxvY2FsIGVkaXRzIG9uIGl0LlxuXHRcdFx0XHQodG1wID0gcm9vdC4kLmdldChzb3VsKS5fKS5wdXQgPSBzdGF0ZV9pZnkodG1wLnB1dCwga2V5LCBzdGF0ZSwgY2hhbmdlLCBzb3VsKTtcblx0XHRcdH1cblx0XHRcdGlmKCFhdC5zb3VsIC8qJiYgKGF0LmFza3x8JycpWycnXSovICYmIHN0YXRlID49IHN0YXRlX2lzKHJvb3QuZ3JhcGhbc291bF0sIGtleSkgJiYgKHNhdCA9IChyb290LiQuZ2V0KHNvdWwpLl8ubmV4dHx8JycpW2tleV0pKXsgLy8gU2FtZSBhcyBhYm92ZSBoZXJlLCBidXQgZm9yIG90aGVyIHR5cGVzIG9mIGNoYWlucy4gLy8gVE9ETzogSW1wcm92ZSBwZXJmIGJ5IHByZXZlbnRpbmcgZWNob2VzIHJlY2FjaGluZy5cblx0XHRcdFx0c2F0LnB1dCA9IGNoYW5nZTsgLy8gdXBkYXRlIGNhY2hlXG5cdFx0XHRcdGlmKCdzdHJpbmcnID09IHR5cGVvZiAodG1wID0gdmFsaWQoY2hhbmdlKSkpe1xuXHRcdFx0XHRcdHNhdC5wdXQgPSByb290LiQuZ2V0KHRtcCkuXy5wdXQgfHwgY2hhbmdlOyAvLyBzaGFyZSBzYW1lIGNhY2hlIGFzIHdoYXQgd2UncmUgbGlua2VkIHRvLlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMudG8gJiYgdGhpcy50by5uZXh0KG1zZyk7IC8vIDFzdCBBUEkgam9iIGlzIHRvIGNhbGwgYWxsIGNoYWluIGxpc3RlbmVycy5cblx0XHRcdC8vIFRPRE86IE1ha2UgaW5wdXQgbW9yZSByZXVzYWJsZSBieSBvbmx5IGRvaW5nIHRoZXNlIChzb21lPykgY2FsbHMgaWYgd2UgYXJlIGEgY2hhaW4gd2UgcmVjb2duaXplPyBUaGlzIG1lYW5zIGVhY2ggaW5wdXQgbGlzdGVuZXIgd291bGQgYmUgcmVzcG9uc2libGUgZm9yIHdoZW4gbGlzdGVuZXJzIG5lZWQgdG8gYmUgY2FsbGVkLCB3aGljaCBtYWtlcyBzZW5zZSwgYXMgdGhleSBtaWdodCB3YW50IHRvIGZpbHRlci5cblx0XHRcdGNhdC5hbnkgJiYgc2V0VGltZW91dC5lYWNoKE9iamVjdC5rZXlzKGNhdC5hbnkpLCBmdW5jdGlvbihhbnkpeyAoYW55ID0gY2F0LmFueVthbnldKSAmJiBhbnkobXNnKSB9LDAsOTkpOyAvLyAxc3QgQVBJIGpvYiBpcyB0byBjYWxsIGFsbCBjaGFpbiBsaXN0ZW5lcnMuIC8vIFRPRE86IC5rZXlzKCBpcyBzbG93IC8vIEJVRzogU29tZSByZS1pbiBsb2dpYyBtYXkgZGVwZW5kIG9uIHRoaXMgYmVpbmcgc3luYy5cblx0XHRcdGNhdC5lY2hvICYmIHNldFRpbWVvdXQuZWFjaChPYmplY3Qua2V5cyhjYXQuZWNobyksIGZ1bmN0aW9uKGxhdCl7IChsYXQgPSBjYXQuZWNob1tsYXRdKSAmJiBsYXQub24oJ2luJywgbXNnKSB9LDAsOTkpOyAvLyAmIGxpbmtlZCBhdCBjaGFpbnMgLy8gVE9ETzogLmtleXMoIGlzIHNsb3cgLy8gQlVHOiBTb21lIHJlLWluIGxvZ2ljIG1heSBkZXBlbmQgb24gdGhpcyBiZWluZyBzeW5jLlxuXG5cdFx0XHRpZigoKG1zZy4kJHx8JycpLl98fGF0KS5zb3VsKXsgLy8gY29tbWVudHMgYXJlIGxpbmVhciwgYnV0IHRoaXMgbGluZSBvZiBjb2RlIGlzIG5vbi1saW5lYXIsIHNvIGlmIEkgd2VyZSB0byBjb21tZW50IHdoYXQgaXQgZG9lcywgeW91J2QgaGF2ZSB0byByZWFkIDQyIG90aGVyIGNvbW1lbnRzIGZpcnN0Li4uIGJ1dCB5b3UgY2FuJ3QgcmVhZCBhbnkgb2YgdGhvc2UgY29tbWVudHMgdW50aWwgeW91IGZpcnN0IHJlYWQgdGhpcyBjb21tZW50LiBXaGF0IT8gLy8gc2hvdWxkbid0IHRoaXMgbWF0Y2ggbGluaydzIGNoZWNrP1xuXHRcdFx0XHQvLyBpcyB0aGVyZSBjYXNlcyB3aGVyZSBpdCBpcyBhICQkIHRoYXQgd2UgZG8gTk9UIHdhbnQgdG8gZG8gdGhlIGZvbGxvd2luZz8gXG5cdFx0XHRcdGlmKChzYXQgPSBjYXQubmV4dCkgJiYgKHNhdCA9IHNhdFtrZXldKSl7IC8vIFRPRE86IHBvc3NpYmxlIHRyaWNrPyBNYXliZSBoYXZlIGBpb25tYXBgIGNvZGUgc2V0IGEgc2F0PyAvLyBUT0RPOiBNYXliZSB3ZSBzaG91bGQgZG8gYGNhdC5hc2tgIGluc3RlYWQ/IEkgZ3Vlc3MgZG9lcyBub3QgbWF0dGVyLlxuXHRcdFx0XHRcdHRtcCA9IHt9OyBPYmplY3Qua2V5cyhtc2cpLmZvckVhY2goZnVuY3Rpb24oayl7IHRtcFtrXSA9IG1zZ1trXSB9KTtcblx0XHRcdFx0XHR0bXAuJCA9IChtc2cuJCR8fG1zZy4kKS5nZXQodG1wLmdldCA9IGtleSk7IGRlbGV0ZSB0bXAuJCQ7IGRlbGV0ZSB0bXAuJCQkO1xuXHRcdFx0XHRcdHNhdC5vbignaW4nLCB0bXApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGxpbmsobXNnLCBjYXQpO1xuXHRcdH07IEd1bi5vbi5pbiA9IGlucHV0O1xuXG5cdFx0ZnVuY3Rpb24gbGluayhtc2csIGNhdCl7IGNhdCA9IGNhdCB8fCB0aGlzLmFzIHx8IG1zZy4kLl87XG5cdFx0XHRpZihtc2cuJCQgJiYgdGhpcyAhPT0gR3VuLm9uKXsgcmV0dXJuIH0gLy8gJCQgbWVhbnMgd2UgY2FtZSBmcm9tIGEgbGluaywgc28gd2UgYXJlIGF0IHRoZSB3cm9uZyBsZXZlbCwgdGh1cyBpZ25vcmUgaXQgdW5sZXNzIG92ZXJydWxlZCBtYW51YWxseSBieSBiZWluZyBjYWxsZWQgZGlyZWN0bHkuXG5cdFx0XHRpZighbXNnLnB1dCB8fCBjYXQuc291bCl7IHJldHVybiB9IC8vIEJ1dCB5b3UgY2Fubm90IG92ZXJydWxlIGJlaW5nIGxpbmtlZCB0byBub3RoaW5nLCBvciB0cnlpbmcgdG8gbGluayBhIHNvdWwgY2hhaW4gLSB0aGF0IG11c3QgbmV2ZXIgaGFwcGVuLlxuXHRcdFx0dmFyIHB1dCA9IG1zZy5wdXR8fCcnLCBsaW5rID0gcHV0Wyc9J118fHB1dFsnOiddLCB0bXA7XG5cdFx0XHR2YXIgcm9vdCA9IGNhdC5yb290LCB0YXQgPSByb290LiQuZ2V0KHB1dFsnIyddKS5nZXQocHV0WycuJ10pLl87XG5cdFx0XHRpZignc3RyaW5nJyAhPSB0eXBlb2YgKGxpbmsgPSB2YWxpZChsaW5rKSkpe1xuXHRcdFx0XHRpZih0aGlzID09PSBHdW4ub24peyAodGF0LmVjaG8gfHwgKHRhdC5lY2hvID0ge30pKVtjYXQuaWRdID0gY2F0IH0gLy8gYWxsb3cgc29tZSBjaGFpbiB0byBleHBsaWNpdGx5IGZvcmNlIGxpbmtpbmcgdG8gc2ltcGxlIGRhdGEuXG5cdFx0XHRcdHJldHVybjsgLy8gYnkgZGVmYXVsdCBkbyBub3QgbGluayB0byBkYXRhIHRoYXQgaXMgbm90IGEgbGluay5cblx0XHRcdH1cblx0XHRcdGlmKCh0YXQuZWNobyB8fCAodGF0LmVjaG8gPSB7fSkpW2NhdC5pZF0gLy8gd2UndmUgYWxyZWFkeSBsaW5rZWQgb3Vyc2VsdmVzIHNvIHdlIGRvIG5vdCBuZWVkIHRvIGRvIGl0IGFnYWluLiBFeGNlcHQuLi4gKGFubm95aW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMpXG5cdFx0XHRcdCYmICEocm9vdC5wYXNzfHwnJylbY2F0LmlkXSl7IHJldHVybiB9IC8vIGlmIGEgbmV3IGV2ZW50IGxpc3RlbmVyIHdhcyBhZGRlZCwgd2UgbmVlZCB0byBtYWtlIGEgcGFzcyB0aHJvdWdoIGZvciBpdC4gVGhlIHBhc3Mgd2lsbCBiZSBvbiB0aGUgY2hhaW4sIG5vdCBhbHdheXMgdGhlIGNoYWluIHBhc3NlZCBkb3duLiBcblx0XHRcdGlmKHRtcCA9IHJvb3QucGFzcyl7IGlmKHRtcFtsaW5rK2NhdC5pZF0peyByZXR1cm4gfSB0bXBbbGluaytjYXQuaWRdID0gMSB9IC8vIEJ1dCB0aGUgYWJvdmUgZWRnZSBjYXNlIG1heSBcInBhc3MgdGhyb3VnaFwiIG9uIGEgY2lyY3VsYXIgZ3JhcGggY2F1c2luZyBpbmZpbml0ZSBwYXNzZXMsIHNvIHdlIGhhY2tpbHkgYWRkIGEgdGVtcG9yYXJ5IGNoZWNrIGZvciB0aGF0LlxuXG5cdFx0XHQodGF0LmVjaG98fCh0YXQuZWNobz17fSkpW2NhdC5pZF0gPSBjYXQ7IC8vIHNldCBvdXJzZWxmIHVwIGZvciB0aGUgZWNobyEgLy8gVE9ETzogQlVHPyBFY2hvIHRvIHNlbGYgbm8gbG9uZ2VyIGNhdXNlcyBwcm9ibGVtcz8gQ29uZmlybS5cblxuXHRcdFx0aWYoY2F0Lmhhcyl7IGNhdC5saW5rID0gbGluayB9XG5cdFx0XHR2YXIgc2F0ID0gcm9vdC4kLmdldCh0YXQubGluayA9IGxpbmspLl87IC8vIGdyYWIgd2hhdCB3ZSdyZSBsaW5raW5nIHRvLlxuXHRcdFx0KHNhdC5lY2hvIHx8IChzYXQuZWNobyA9IHt9KSlbdGF0LmlkXSA9IHRhdDsgLy8gbGluayBpdC5cblx0XHRcdHZhciB0bXAgPSBjYXQuYXNrfHwnJzsgLy8gYXNrIHRoZSBjaGFpbiBmb3Igd2hhdCBuZWVkcyB0byBiZSBsb2FkZWQgbmV4dCFcblx0XHRcdGlmKHRtcFsnJ10gfHwgY2F0LmxleCl7IC8vIHdlIG1pZ2h0IG5lZWQgdG8gbG9hZCB0aGUgd2hvbGUgdGhpbmcgLy8gVE9ETzogY2F0LmxleCBwcm9iYWJseSBoYXMgZWRnZSBjYXNlIGJ1Z3MgdG8gaXQsIG5lZWQgbW9yZSB0ZXN0IGNvdmVyYWdlLlxuXHRcdFx0XHRzYXQub24oJ291dCcsIHtnZXQ6IHsnIyc6IGxpbmt9fSk7XG5cdFx0XHR9XG5cdFx0XHRzZXRUaW1lb3V0LmVhY2goT2JqZWN0LmtleXModG1wKSwgZnVuY3Rpb24oZ2V0LCBzYXQpeyAvLyBpZiBzdWIgY2hhaW5zIGFyZSBhc2tpbmcgZm9yIGRhdGEuIC8vIFRPRE86IC5rZXlzKCBpcyBzbG93IC8vIEJVRz8gP1NvbWUgcmUtaW4gbG9naWMgbWF5IGRlcGVuZCBvbiB0aGlzIGJlaW5nIHN5bmM/XG5cdFx0XHRcdGlmKCFnZXQgfHwgIShzYXQgPSB0bXBbZ2V0XSkpeyByZXR1cm4gfVxuXHRcdFx0XHRzYXQub24oJ291dCcsIHtnZXQ6IHsnIyc6IGxpbmssICcuJzogZ2V0fX0pOyAvLyBnbyBnZXQgaXQuXG5cdFx0XHR9LDAsOTkpO1xuXHRcdH07IEd1bi5vbi5saW5rID0gbGluaztcblxuXHRcdGZ1bmN0aW9uIHVubGluayhtc2csIGNhdCl7IC8vIHVnaCwgc28gbXVjaCBjb2RlIGZvciBzZWVtaW5nbHkgZWRnZSBjYXNlIGJlaGF2aW9yLlxuXHRcdFx0dmFyIHB1dCA9IG1zZy5wdXR8fCcnLCBjaGFuZ2UgPSAodSAhPT0gcHV0Wyc9J10pPyBwdXRbJz0nXSA6IHB1dFsnOiddLCByb290ID0gY2F0LnJvb3QsIGxpbmssIHRtcDtcblx0XHRcdGlmKHUgPT09IGNoYW5nZSl7IC8vIDFzdCBlZGdlIGNhc2U6IElmIHdlIGhhdmUgYSBicmFuZCBuZXcgZGF0YWJhc2UsIG5vIGRhdGEgd2lsbCBiZSBmb3VuZC5cblx0XHRcdFx0Ly8gVE9ETzogQlVHISBiZWNhdXNlIGVtcHR5aW5nIGNhY2hlIGNvdWxkIGJlIGFzeW5jIGZyb20gYmVsb3csIG1ha2Ugc3VyZSB3ZSBhcmUgbm90IGVtcHR5aW5nIGEgbmV3ZXIgY2FjaGUuIFNvIG1heWJlIHBhc3MgYW4gQXN5bmMgSUQgdG8gY2hlY2sgYWdhaW5zdD9cblx0XHRcdFx0Ly8gVE9ETzogQlVHISBXaGF0IGlmIHRoaXMgaXMgYSBtYXA/IC8vIFdhcm5pbmchIENsZWFyaW5nIHRoaW5ncyBvdXQgbmVlZHMgdG8gYmUgcm9idXN0IGFnYWluc3Qgc3luYy9hc3luYyBvcHMsIG9yIGVsc2UgeW91J2xsIHNlZSBgbWFwIHZhbCBnZXQgcHV0YCB0ZXN0IGNhdGFzdHJvcGhpY2FsbHkgZmFpbCBiZWNhdXNlIG1hcCBhdHRlbXB0cyB0byBsaW5rIHdoZW4gcGFyZW50IGdyYXBoIGlzIHN0cmVhbWVkIGJlZm9yZSBjaGlsZCB2YWx1ZSBnZXRzIHNldC4gTmVlZCB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gbGFjayBhY2tzIGFuZCBmb3JjZSBjbGVhcmluZy5cblx0XHRcdFx0aWYoY2F0LnNvdWwgJiYgdSAhPT0gY2F0LnB1dCl7IHJldHVybiB9IC8vIGRhdGEgbWF5IG5vdCBiZSBmb3VuZCBvbiBhIHNvdWwsIGJ1dCBpZiBhIHNvdWwgYWxyZWFkeSBoYXMgZGF0YSwgdGhlbiBub3RoaW5nIGNhbiBjbGVhciB0aGUgc291bCBhcyBhIHdob2xlLlxuXHRcdFx0XHQvL2lmKCFjYXQuaGFzKXsgcmV0dXJuIH1cblx0XHRcdFx0dG1wID0gKG1zZy4kJHx8bXNnLiR8fCcnKS5ffHwnJztcblx0XHRcdFx0aWYobXNnWydAJ10gJiYgKHUgIT09IHRtcC5wdXQgfHwgdSAhPT0gY2F0LnB1dCkpeyByZXR1cm4gfSAvLyBhIFwibm90IGZvdW5kXCIgZnJvbSBvdGhlciBwZWVycyBzaG91bGQgbm90IGNsZWFyIG91dCBkYXRhIGlmIHdlIGhhdmUgYWxyZWFkeSBmb3VuZCBpdC5cblx0XHRcdFx0Ly9pZihjYXQuaGFzICYmIHUgPT09IGNhdC5wdXQgJiYgIShyb290LnBhc3N8fCcnKVtjYXQuaWRdKXsgcmV0dXJuIH0gLy8gaWYgd2UgYXJlIGFscmVhZHkgdW5saW5rZWQsIGRvIG5vdCBjYWxsIGFnYWluLCB1bmxlc3MgZWRnZSBjYXNlLiAvLyBUT0RPOiBCVUchIFRoaXMgbGluZSBzaG91bGQgYmUgZGVsZXRlZCBmb3IgXCJ1bmxpbmsgZGVlcGx5IG5lc3RlZFwiLlxuXHRcdFx0XHRpZihsaW5rID0gY2F0LmxpbmsgfHwgbXNnLmxpbmtlZCl7XG5cdFx0XHRcdFx0ZGVsZXRlIChyb290LiQuZ2V0KGxpbmspLl8uZWNob3x8JycpW2NhdC5pZF07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoY2F0Lmhhcyl7IC8vIFRPRE86IEVtcHR5IG91dCBsaW5rcywgbWFwcywgZWNob3MsIGFja3MvYXNrcywgZXRjLj9cblx0XHRcdFx0XHRjYXQubGluayA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0LnB1dCA9IHU7IC8vIGVtcHR5IG91dCB0aGUgY2FjaGUgaWYsIGZvciBleGFtcGxlLCBhbGljZSdzIGNhcidzIGNvbG9yIG5vIGxvbmdlciBleGlzdHMgKHJlbGF0aXZlIHRvIGFsaWNlKSBpZiBhbGljZSBubyBsb25nZXIgaGFzIGEgY2FyLlxuXHRcdFx0XHQvLyBUT0RPOiBCVUchIEZvciBtYXBzLCBwcm94eSB0aGlzIHNvIHRoZSBpbmRpdmlkdWFsIHN1YiBpcyB0cmlnZ2VyZWQsIG5vdCBhbGwgc3Vicy5cblx0XHRcdFx0c2V0VGltZW91dC5lYWNoKE9iamVjdC5rZXlzKGNhdC5uZXh0fHwnJyksIGZ1bmN0aW9uKGdldCwgc2F0KXsgLy8gZW1wdHkgb3V0IGFsbCBzdWIgY2hhaW5zLiAvLyBUT0RPOiAua2V5cyggaXMgc2xvdyAvLyBCVUc/ID9Tb21lIHJlLWluIGxvZ2ljIG1heSBkZXBlbmQgb24gdGhpcyBiZWluZyBzeW5jPyAvLyBUT0RPOiBCVUc/IFRoaXMgd2lsbCB0cmlnZ2VyIGRlZXBlciBwdXQgZmlyc3QsIGRvZXMgcHV0IGxvZ2ljIGRlcGVuZCBvbiBuZXN0ZWQgb3JkZXI/IC8vIFRPRE86IEJVRyEgRm9yIG1hcCwgdGhpcyBuZWVkcyB0byBiZSB0aGUgaXNvbGF0ZWQgY2hpbGQsIG5vdCBhbGwgb2YgdGhlbS5cblx0XHRcdFx0XHRpZighKHNhdCA9IGNhdC5uZXh0W2dldF0pKXsgcmV0dXJuIH1cblx0XHRcdFx0XHQvL2lmKGNhdC5oYXMgJiYgdSA9PT0gc2F0LnB1dCAmJiAhKHJvb3QucGFzc3x8JycpW3NhdC5pZF0peyByZXR1cm4gfSAvLyBpZiB3ZSBhcmUgYWxyZWFkeSB1bmxpbmtlZCwgZG8gbm90IGNhbGwgYWdhaW4sIHVubGVzcyBlZGdlIGNhc2UuIC8vIFRPRE86IEJVRyEgVGhpcyBsaW5lIHNob3VsZCBiZSBkZWxldGVkIGZvciBcInVubGluayBkZWVwbHkgbmVzdGVkXCIuXG5cdFx0XHRcdFx0aWYobGluayl7IGRlbGV0ZSAocm9vdC4kLmdldChsaW5rKS5nZXQoZ2V0KS5fLmVjaG98fCcnKVtzYXQuaWRdIH1cblx0XHRcdFx0XHRzYXQub24oJ2luJywge2dldDogZ2V0LCBwdXQ6IHUsICQ6IHNhdC4kfSk7IC8vIFRPRE86IEJVRz8gQWRkIHJlY3Vyc2l2ZSBzZWVuIGNoZWNrP1xuXHRcdFx0XHR9LDAsOTkpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZihjYXQuc291bCl7IHJldHVybiB9IC8vIGEgc291bCBjYW5ub3QgdW5saW5rIGl0c2VsZi5cblx0XHRcdGlmKG1zZy4kJCl7IHJldHVybiB9IC8vIGEgbGlua2VkIGNoYWluIGRvZXMgbm90IGRvIHRoZSB1bmxpbmtpbmcsIHRoZSBzdWIgY2hhaW4gZG9lcy4gLy8gVE9ETzogQlVHPyBXaWxsIHRoaXMgY2FuY2VsIG1hcHM/XG5cdFx0XHRsaW5rID0gdmFsaWQoY2hhbmdlKTsgLy8gbmVlZCB0byB1bmxpbmsgYW55dGltZSB3ZSBhcmUgbm90IHRoZSBzYW1lIGxpbmssIHRob3VnaCBvbmx5IGRvIHRoaXMgb25jZSBwZXIgdW5saW5rIChhbmQgbm90IG9uIGluaXQpLlxuXHRcdFx0dG1wID0gbXNnLiQuX3x8Jyc7XG5cdFx0XHRpZihsaW5rID09PSB0bXAubGluayB8fCAoY2F0LmhhcyAmJiAhdG1wLmxpbmspKXtcblx0XHRcdFx0aWYoKHJvb3QucGFzc3x8JycpW2NhdC5pZF0gJiYgJ3N0cmluZycgIT09IHR5cGVvZiBsaW5rKXtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZGVsZXRlICh0bXAuZWNob3x8JycpW2NhdC5pZF07XG5cdFx0XHR1bmxpbmsoe2dldDogY2F0LmdldCwgcHV0OiB1LCAkOiBtc2cuJCwgbGlua2VkOiBtc2cubGlua2VkID0gbXNnLmxpbmtlZCB8fCB0bXAubGlua30sIGNhdCk7IC8vIHVubGluayBvdXIgc3ViIGNoYWlucy5cblx0XHR9OyBHdW4ub24udW5saW5rID0gdW5saW5rO1xuXG5cdFx0ZnVuY3Rpb24gYWNrKG1zZywgZXYpe1xuXHRcdFx0Ly9pZighbXNnWyclJ10gJiYgKHRoaXN8fCcnKS5vZmYpeyB0aGlzLm9mZigpIH0gLy8gZG8gTk9UIG1lbW9yeSBsZWFrLCB0dXJuIG9mZiBsaXN0ZW5lcnMhIE5vdyBoYW5kbGVkIGJ5IC5hc2sgaXRzZWxmXG5cdFx0XHQvLyBtYW5oYXR0YW46XG5cdFx0XHR2YXIgYXMgPSB0aGlzLmFzLCBhdCA9IGFzLiQuXywgcm9vdCA9IGF0LnJvb3QsIGdldCA9IGFzLmdldHx8JycsIHRtcCA9IChtc2cucHV0fHwnJylbZ2V0WycjJ11dfHwnJztcblx0XHRcdGlmKCFtc2cucHV0IHx8ICgnc3RyaW5nJyA9PSB0eXBlb2YgZ2V0WycuJ10gJiYgdSA9PT0gdG1wW2dldFsnLiddXSkpe1xuXHRcdFx0XHRpZih1ICE9PSBhdC5wdXQpeyByZXR1cm4gfVxuXHRcdFx0XHRpZighYXQuc291bCAmJiAhYXQuaGFzKXsgcmV0dXJuIH0gLy8gVE9ETzogQlVHPyBGb3Igbm93LCBvbmx5IGNvcmUtY2hhaW5zIHdpbGwgaGFuZGxlIG5vdC1mb3VuZHMsIGJlY2F1c2UgYnVncyBjcmVlcCBpbiBpZiBub24tY29yZSBjaGFpbnMgYXJlIHVzZWQgYXMgJCBidXQgd2UgY2FuIHJldmlzaXQgdGhpcyBsYXRlciBmb3IgbW9yZSBwb3dlcmZ1bCBleHRlbnNpb25zLlxuXHRcdFx0XHRhdC5hY2sgPSAoYXQuYWNrIHx8IDApICsgMTtcblx0XHRcdFx0YXQub24oJ2luJywge1xuXHRcdFx0XHRcdGdldDogYXQuZ2V0LFxuXHRcdFx0XHRcdHB1dDogYXQucHV0ID0gdSxcblx0XHRcdFx0XHQkOiBhdC4kLFxuXHRcdFx0XHRcdCdAJzogbXNnWydAJ11cblx0XHRcdFx0fSk7XG5cdFx0XHRcdC8qKHRtcCA9IGF0LlEpICYmIHNldFRpbWVvdXQuZWFjaChPYmplY3Qua2V5cyh0bXApLCBmdW5jdGlvbihpZCl7IC8vIFRPRE86IFRlbXBvcmFyeSB0ZXN0aW5nLCBub3QgaW50ZWdyYXRlZCBvciBiZWluZyB1c2VkLCBwcm9iYWJseSBkZWxldGUuXG5cdFx0XHRcdFx0T2JqZWN0LmtleXMobXNnKS5mb3JFYWNoKGZ1bmN0aW9uKGspeyB0bXBba10gPSBtc2dba10gfSwgdG1wID0ge30pOyB0bXBbJ0AnXSA9IGlkOyAvLyBjb3B5IG1lc3NhZ2Vcblx0XHRcdFx0XHRyb290Lm9uKCdpbicsIHRtcCk7XG5cdFx0XHRcdH0pOyBkZWxldGUgYXQuUTsqL1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQobXNnLl98fHt9KS5taXNzID0gMTtcblx0XHRcdEd1bi5vbi5wdXQobXNnKTtcblx0XHRcdHJldHVybjsgLy8gZW9tXG5cdFx0fVxuXG5cdFx0dmFyIGVtcHR5ID0ge30sIHUsIHRleHRfcmFuZCA9IFN0cmluZy5yYW5kb20sIHZhbGlkID0gR3VuLnZhbGlkLCBvYmpfaGFzID0gZnVuY3Rpb24obywgayl7IHJldHVybiBvICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSB9LCBzdGF0ZSA9IEd1bi5zdGF0ZSwgc3RhdGVfaXMgPSBzdGF0ZS5pcywgc3RhdGVfaWZ5ID0gc3RhdGUuaWZ5O1xuXHR9KShVU0UsICcuL2NoYWluJyk7XG5cblx0O1VTRShmdW5jdGlvbihtb2R1bGUpe1xuXHRcdHZhciBHdW4gPSBVU0UoJy4vcm9vdCcpO1xuXHRcdEd1bi5jaGFpbi5nZXQgPSBmdW5jdGlvbihrZXksIGNiLCBhcyl7XG5cdFx0XHR2YXIgZ3VuLCB0bXA7XG5cdFx0XHRpZih0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyl7XG5cdFx0XHRcdGlmKGtleS5sZW5ndGggPT0gMCkge1x0XG5cdFx0XHRcdFx0KGd1biA9IHRoaXMuY2hhaW4oKSkuXy5lcnIgPSB7ZXJyOiBHdW4ubG9nKCcwIGxlbmd0aCBrZXkhJywga2V5KX07XG5cdFx0XHRcdFx0aWYoY2IpeyBjYi5jYWxsKGd1biwgZ3VuLl8uZXJyKSB9XG5cdFx0XHRcdFx0cmV0dXJuIGd1bjtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgYmFjayA9IHRoaXMsIGNhdCA9IGJhY2suXztcblx0XHRcdFx0dmFyIG5leHQgPSBjYXQubmV4dCB8fCBlbXB0eTtcblx0XHRcdFx0aWYoIShndW4gPSBuZXh0W2tleV0pKXtcblx0XHRcdFx0XHRndW4gPSBrZXkgJiYgY2FjaGUoa2V5LCBiYWNrKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRndW4gPSBndW4gJiYgZ3VuLiQ7XG5cdFx0XHR9IGVsc2Vcblx0XHRcdGlmKCdmdW5jdGlvbicgPT0gdHlwZW9mIGtleSl7XG5cdFx0XHRcdGlmKHRydWUgPT09IGNiKXsgcmV0dXJuIHNvdWwodGhpcywga2V5LCBjYiwgYXMpLCB0aGlzIH1cblx0XHRcdFx0Z3VuID0gdGhpcztcblx0XHRcdFx0dmFyIGNhdCA9IGd1bi5fLCBvcHQgPSBjYiB8fCB7fSwgcm9vdCA9IGNhdC5yb290LCBpZDtcblx0XHRcdFx0b3B0LmF0ID0gY2F0O1xuXHRcdFx0XHRvcHQub2sgPSBrZXk7XG5cdFx0XHRcdHZhciB3YWl0ID0ge307IC8vIGNhbiB3ZSBhc3NpZ24gdGhpcyB0byB0aGUgYXQgaW5zdGVhZCwgbGlrZSBpbiBvbmNlP1xuXHRcdFx0XHQvL3ZhciBwYXRoID0gW107IGNhdC4kLmJhY2soYXQgPT4geyBhdC5nZXQgJiYgcGF0aC5wdXNoKGF0LmdldC5zbGljZSgwLDkpKX0pOyBwYXRoID0gcGF0aC5yZXZlcnNlKCkuam9pbignLicpO1xuXHRcdFx0XHRmdW5jdGlvbiBhbnkobXNnLCBldmUsIGYpe1xuXHRcdFx0XHRcdGlmKGFueS5zdHVuKXsgcmV0dXJuIH1cblx0XHRcdFx0XHRpZigodG1wID0gcm9vdC5wYXNzKSAmJiAhdG1wW2lkXSl7IHJldHVybiB9XG5cdFx0XHRcdFx0dmFyIGF0ID0gbXNnLiQuXywgc2F0ID0gKG1zZy4kJHx8JycpLl8sIGRhdGEgPSAoc2F0fHxhdCkucHV0LCBvZGQgPSAoIWF0LmhhcyAmJiAhYXQuc291bCksIHRlc3QgPSB7fSwgbGluaywgdG1wO1xuXHRcdFx0XHRcdGlmKG9kZCB8fCB1ID09PSBkYXRhKXsgLy8gaGFuZGxlcyBub24tY29yZVxuXHRcdFx0XHRcdFx0ZGF0YSA9ICh1ID09PSAoKHRtcCA9IG1zZy5wdXQpfHwnJylbJz0nXSk/ICh1ID09PSAodG1wfHwnJylbJzonXSk/IHRtcCA6IHRtcFsnOiddIDogdG1wWyc9J107XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKGxpbmsgPSAoJ3N0cmluZycgPT0gdHlwZW9mICh0bXAgPSBHdW4udmFsaWQoZGF0YSkpKSl7XG5cdFx0XHRcdFx0XHRkYXRhID0gKHUgPT09ICh0bXAgPSByb290LiQuZ2V0KHRtcCkuXy5wdXQpKT8gb3B0Lm5vdD8gdSA6IGRhdGEgOiB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKG9wdC5ub3QgJiYgdSA9PT0gZGF0YSl7IHJldHVybiB9XG5cdFx0XHRcdFx0aWYodSA9PT0gb3B0LnN0dW4pe1xuXHRcdFx0XHRcdFx0aWYoKHRtcCA9IHJvb3Quc3R1bikgJiYgdG1wLm9uKXtcblx0XHRcdFx0XHRcdFx0Y2F0LiQuYmFjayhmdW5jdGlvbihhKXsgLy8gb3VyIGNoYWluIHN0dW5uZWQ/XG5cdFx0XHRcdFx0XHRcdFx0dG1wLm9uKCcnK2EuaWQsIHRlc3QgPSB7fSk7XG5cdFx0XHRcdFx0XHRcdFx0aWYoKHRlc3QucnVuIHx8IDApIDwgYW55LmlkKXsgcmV0dXJuIHRlc3QgfSAvLyBpZiB0aGVyZSBpcyBhbiBlYXJsaWVyIHN0dW4gb24gZ2FwbGVzcyBwYXJlbnRzL3NlbGYuXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHQhdGVzdC5ydW4gJiYgdG1wLm9uKCcnK2F0LmlkLCB0ZXN0ID0ge30pOyAvLyB0aGlzIG5vZGUgc3R1bm5lZD9cblx0XHRcdFx0XHRcdFx0IXRlc3QucnVuICYmIHNhdCAmJiB0bXAub24oJycrc2F0LmlkLCB0ZXN0ID0ge30pOyAvLyBsaW5rZWQgbm9kZSBzdHVubmVkP1xuXHRcdFx0XHRcdFx0XHRpZihhbnkuaWQgPiB0ZXN0LnJ1bil7XG5cdFx0XHRcdFx0XHRcdFx0aWYoIXRlc3Quc3R1biB8fCB0ZXN0LnN0dW4uZW5kKXtcblx0XHRcdFx0XHRcdFx0XHRcdHRlc3Quc3R1biA9IHRtcC5vbignc3R1bicpO1xuXHRcdFx0XHRcdFx0XHRcdFx0dGVzdC5zdHVuID0gdGVzdC5zdHVuICYmIHRlc3Quc3R1bi5sYXN0O1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZih0ZXN0LnN0dW4gJiYgIXRlc3Quc3R1bi5lbmQpe1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly9pZihvZGQgJiYgdSA9PT0gZGF0YSl7IHJldHVybiB9XG5cdFx0XHRcdFx0XHRcdFx0XHQvL2lmKHUgPT09IG1zZy5wdXQpeyByZXR1cm4gfSAvLyBcIm5vdCBmb3VuZFwiIGFja3Mgd2lsbCBiZSBmb3VuZCBpZiB0aGVyZSBpcyBzdHVuLCBzbyBpZ25vcmUgdGhlc2UuXG5cdFx0XHRcdFx0XHRcdFx0XHQodGVzdC5zdHVuLmFkZCB8fCAodGVzdC5zdHVuLmFkZCA9IHt9KSlbaWRdID0gZnVuY3Rpb24oKXsgYW55KG1zZyxldmUsMSkgfSAvLyBhZGQgb3Vyc2VsZiB0byB0aGUgc3R1biBjYWxsYmFjayBsaXN0IHRoYXQgaXMgY2FsbGVkIGF0IGVuZCBvZiB0aGUgd3JpdGUuXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZigvKm9kZCAmJiovIHUgPT09IGRhdGEpeyBmID0gMCB9IC8vIGlmIGRhdGEgbm90IGZvdW5kLCBrZWVwIHdhaXRpbmcvdHJ5aW5nLlxuXHRcdFx0XHRcdFx0LyppZihmICYmIHUgPT09IGRhdGEpe1xuXHRcdFx0XHRcdFx0XHRjYXQub24oJ291dCcsIG9wdC5vdXQpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9Ki9cblx0XHRcdFx0XHRcdGlmKCh0bXAgPSByb290LmhhdGNoKSAmJiAhdG1wLmVuZCAmJiB1ID09PSBvcHQuaGF0Y2ggJiYgIWYpeyAvLyBxdWljayBoYWNrISAvLyBXaGF0J3MgZ29pbmcgb24gaGVyZT8gQmVjYXVzZSBkYXRhIGlzIHN0cmVhbWVkLCB3ZSBnZXQgdGhpbmdzIG9uZSBieSBvbmUsIGJ1dCBhIGxvdCBvZiBkZXZlbG9wZXJzIHdvdWxkIHJhdGhlciBnZXQgYSBjYWxsYmFjayBhZnRlciBlYWNoIGJhdGNoIGluc3RlYWQsIHNvIHRoaXMgZG9lcyB0aGF0IGJ5IGNyZWF0aW5nIGEgd2FpdCBsaXN0IHBlciBjaGFpbiBpZCB0aGF0IGlzIHRoZW4gY2FsbGVkIGF0IHRoZSBlbmQgb2YgdGhlIGJhdGNoIGJ5IHRoZSBoYXRjaCBjb2RlIGluIHRoZSByb290IHB1dCBsaXN0ZW5lci5cblx0XHRcdFx0XHRcdFx0aWYod2FpdFthdC4kLl8uaWRdKXsgcmV0dXJuIH0gd2FpdFthdC4kLl8uaWRdID0gMTtcblx0XHRcdFx0XHRcdFx0dG1wLnB1c2goZnVuY3Rpb24oKXthbnkobXNnLGV2ZSwxKX0pO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9OyB3YWl0ID0ge307IC8vIGVuZCBxdWljayBoYWNrLlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBjYWxsOlxuXHRcdFx0XHRcdGlmKHJvb3QucGFzcyl7IGlmKHJvb3QucGFzc1tpZCthdC5pZF0peyByZXR1cm4gfSByb290LnBhc3NbaWQrYXQuaWRdID0gMSB9XG5cdFx0XHRcdFx0aWYob3B0Lm9uKXsgb3B0Lm9rLmNhbGwoYXQuJCwgZGF0YSwgYXQuZ2V0LCBtc2csIGV2ZSB8fCBhbnkpOyByZXR1cm4gfSAvLyBUT0RPOiBBbHNvIGNvbnNpZGVyIGJyZWFraW5nIGB0aGlzYCBzaW5jZSBhIGxvdCBvZiBwZW9wbGUgZG8gYD0+YCB0aGVzZSBkYXlzIGFuZCBgLmNhbGwoYCBoYXMgc2xvd2VyIHBlcmZvcm1hbmNlLlxuXHRcdFx0XHRcdGlmKG9wdC52MjAyMCl7IG9wdC5vayhtc2csIGV2ZSB8fCBhbnkpOyByZXR1cm4gfVxuXHRcdFx0XHRcdE9iamVjdC5rZXlzKG1zZykuZm9yRWFjaChmdW5jdGlvbihrKXsgdG1wW2tdID0gbXNnW2tdIH0sIHRtcCA9IHt9KTsgbXNnID0gdG1wOyBtc2cucHV0ID0gZGF0YTsgLy8gMjAxOSBDT01QQVRJQklMSVRZISBUT0RPOiBHRVQgUklEIE9GIFRISVMhXG5cdFx0XHRcdFx0b3B0Lm9rLmNhbGwob3B0LmFzLCBtc2csIGV2ZSB8fCBhbnkpOyAvLyBpcyB0aGlzIHRoZSByaWdodFxuXHRcdFx0XHR9O1xuXHRcdFx0XHRhbnkuYXQgPSBjYXQ7XG5cdFx0XHRcdC8vKGNhdC5hbnl8fChjYXQuYW55PWZ1bmN0aW9uKG1zZyl7IHNldFRpbWVvdXQuZWFjaChPYmplY3Qua2V5cyhjYXQuYW55fHwnJyksIGZ1bmN0aW9uKGFjdCl7IChhY3QgPSBjYXQuYW55W2FjdF0pICYmIGFjdChtc2cpIH0sMCw5OSkgfSkpW2lkID0gU3RyaW5nLnJhbmRvbSg3KV0gPSBhbnk7IC8vIG1heWJlIHN3aXRjaCB0byB0aGlzIGluIGZ1dHVyZT9cblx0XHRcdFx0KGNhdC5hbnl8fChjYXQuYW55PXt9KSlbaWQgPSBTdHJpbmcucmFuZG9tKDcpXSA9IGFueTtcblx0XHRcdFx0YW55Lm9mZiA9IGZ1bmN0aW9uKCl7IGFueS5zdHVuID0gMTsgaWYoIWNhdC5hbnkpeyByZXR1cm4gfSBkZWxldGUgY2F0LmFueVtpZF0gfVxuXHRcdFx0XHRhbnkucmlkID0gcmlkOyAvLyBsb2dpYyBmcm9tIG9sZCB2ZXJzaW9uLCBjYW4gd2UgY2xlYW4gaXQgdXAgbm93P1xuXHRcdFx0XHRhbnkuaWQgPSBvcHQucnVuIHx8ICsrcm9vdC5vbmNlOyAvLyB1c2VkIGluIGNhbGxiYWNrIHRvIGNoZWNrIGlmIHdlIGFyZSBlYXJsaWVyIHRoYW4gYSB3cml0ZS4gLy8gd2lsbCB0aGlzIGV2ZXIgY2F1c2UgYW4gaW50ZWdlciBvdmVyZmxvdz9cblx0XHRcdFx0dG1wID0gcm9vdC5wYXNzOyAocm9vdC5wYXNzID0ge30pW2lkXSA9IDE7IC8vIEV4cGxhbmF0aW9uOiB0ZXN0IHRyYWRlLW9mZnMgd2FudCB0byBwcmV2ZW50IHJlY3Vyc2lvbiBzbyB3ZSBhZGQvcmVtb3ZlIHBhc3MgZmxhZyBhcyBpdCBnZXRzIGZ1bGZpbGxlZCB0byBub3QgcmVwZWF0LCBob3dldmVyIG1hcCBtYXAgbmVlZHMgbWFueSBwYXNzIGZsYWdzIC0gaG93IGRvIHdlIHJlY29uY2lsZT9cblx0XHRcdFx0b3B0Lm91dCA9IG9wdC5vdXQgfHwge2dldDoge319O1xuXHRcdFx0XHRjYXQub24oJ291dCcsIG9wdC5vdXQpO1xuXHRcdFx0XHRyb290LnBhc3MgPSB0bXA7XG5cdFx0XHRcdHJldHVybiBndW47XG5cdFx0XHR9IGVsc2Vcblx0XHRcdGlmKCdudW1iZXInID09IHR5cGVvZiBrZXkpe1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXQoJycra2V5LCBjYiwgYXMpO1xuXHRcdFx0fSBlbHNlXG5cdFx0XHRpZignc3RyaW5nJyA9PSB0eXBlb2YgKHRtcCA9IHZhbGlkKGtleSkpKXtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0KHRtcCwgY2IsIGFzKTtcblx0XHRcdH0gZWxzZVxuXHRcdFx0aWYodG1wID0gdGhpcy5nZXQubmV4dCl7XG5cdFx0XHRcdGd1biA9IHRtcCh0aGlzLCBrZXkpO1xuXHRcdFx0fVxuXHRcdFx0aWYoIWd1bil7XG5cdFx0XHRcdChndW4gPSB0aGlzLmNoYWluKCkpLl8uZXJyID0ge2VycjogR3VuLmxvZygnSW52YWxpZCBnZXQgcmVxdWVzdCEnLCBrZXkpfTsgLy8gQ0xFQU4gVVBcblx0XHRcdFx0aWYoY2IpeyBjYi5jYWxsKGd1biwgZ3VuLl8uZXJyKSB9XG5cdFx0XHRcdHJldHVybiBndW47XG5cdFx0XHR9XG5cdFx0XHRpZihjYiAmJiAnZnVuY3Rpb24nID09IHR5cGVvZiBjYil7XG5cdFx0XHRcdGd1bi5nZXQoY2IsIGFzKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBndW47XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGNhY2hlKGtleSwgYmFjayl7XG5cdFx0XHR2YXIgY2F0ID0gYmFjay5fLCBuZXh0ID0gY2F0Lm5leHQsIGd1biA9IGJhY2suY2hhaW4oKSwgYXQgPSBndW4uXztcblx0XHRcdGlmKCFuZXh0KXsgbmV4dCA9IGNhdC5uZXh0ID0ge30gfVxuXHRcdFx0bmV4dFthdC5nZXQgPSBrZXldID0gYXQ7XG5cdFx0XHRpZihiYWNrID09PSBjYXQucm9vdC4kKXtcblx0XHRcdFx0YXQuc291bCA9IGtleTtcblx0XHRcdH0gZWxzZVxuXHRcdFx0aWYoY2F0LnNvdWwgfHwgY2F0Lmhhcyl7XG5cdFx0XHRcdGF0LmhhcyA9IGtleTtcblx0XHRcdFx0Ly9pZihvYmpfaGFzKGNhdC5wdXQsIGtleSkpe1xuXHRcdFx0XHRcdC8vYXQucHV0ID0gY2F0LnB1dFtrZXldO1xuXHRcdFx0XHQvL31cblx0XHRcdH1cblx0XHRcdHJldHVybiBhdDtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gc291bChndW4sIGNiLCBvcHQsIGFzKXtcblx0XHRcdHZhciBjYXQgPSBndW4uXywgYWNrcyA9IDAsIHRtcDtcblx0XHRcdGlmKHRtcCA9IGNhdC5zb3VsIHx8IGNhdC5saW5rKXsgcmV0dXJuIGNiKHRtcCwgYXMsIGNhdCkgfVxuXHRcdFx0aWYoY2F0LmphbSl7IHJldHVybiBjYXQuamFtLnB1c2goW2NiLCBhc10pIH1cblx0XHRcdGNhdC5qYW0gPSBbW2NiLGFzXV07XG5cdFx0XHRndW4uZ2V0KGZ1bmN0aW9uIGdvKG1zZywgZXZlKXtcblx0XHRcdFx0aWYodSA9PT0gbXNnLnB1dCAmJiAhY2F0LnJvb3Qub3B0LnN1cGVyICYmICh0bXAgPSBPYmplY3Qua2V5cyhjYXQucm9vdC5vcHQucGVlcnMpLmxlbmd0aCkgJiYgKythY2tzIDw9IHRtcCl7IC8vIFRPRE86IHN1cGVyIHNob3VsZCBub3QgYmUgaW4gY29yZSBjb2RlLCBicmluZyBBWEUgdXAgaW50byBjb3JlIGluc3RlYWQgdG8gZml4PyAvLyBUT0RPOiAua2V5cyggaXMgc2xvd1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRldmUucmlkKG1zZyk7XG5cdFx0XHRcdHZhciBhdCA9ICgoYXQgPSBtc2cuJCkgJiYgYXQuXykgfHwge30sIGkgPSAwLCBhcztcblx0XHRcdFx0dG1wID0gY2F0LmphbTsgZGVsZXRlIGNhdC5qYW07IC8vIHRtcCA9IGNhdC5qYW0uc3BsaWNlKDAsIDEwMCk7XG5cdFx0XHRcdC8vaWYodG1wLmxlbmd0aCl7IHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKXsgZ28obXNnLCBldmUpIH0pIH1cblx0XHRcdFx0d2hpbGUoYXMgPSB0bXBbaSsrXSl7IC8vR3VuLm9iai5tYXAodG1wLCBmdW5jdGlvbihhcywgY2Ipe1xuXHRcdFx0XHRcdHZhciBjYiA9IGFzWzBdLCBpZDsgYXMgPSBhc1sxXTtcblx0XHRcdFx0XHRjYiAmJiBjYihpZCA9IGF0LmxpbmsgfHwgYXQuc291bCB8fCBHdW4udmFsaWQobXNnLnB1dCkgfHwgKChtc2cucHV0fHx7fSkuX3x8e30pWycjJ10sIGFzLCBtc2csIGV2ZSk7XG5cdFx0XHRcdH0gLy8pO1xuXHRcdFx0fSwge291dDoge2dldDogeycuJzp0cnVlfX19KTtcblx0XHRcdHJldHVybiBndW47XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIHJpZChhdCl7XG5cdFx0XHR2YXIgY2F0ID0gdGhpcy5hdCB8fCB0aGlzLm9uO1xuXHRcdFx0aWYoIWF0IHx8IGNhdC5zb3VsIHx8IGNhdC5oYXMpeyByZXR1cm4gdGhpcy5vZmYoKSB9XG5cdFx0XHRpZighKGF0ID0gKGF0ID0gKGF0ID0gYXQuJCB8fCBhdCkuXyB8fCBhdCkuaWQpKXsgcmV0dXJuIH1cblx0XHRcdHZhciBtYXAgPSBjYXQubWFwLCB0bXAsIHNlZW47XG5cdFx0XHQvL2lmKCFtYXAgfHwgISh0bXAgPSBtYXBbYXRdKSB8fCAhKHRtcCA9IHRtcC5hdCkpeyByZXR1cm4gfVxuXHRcdFx0aWYodG1wID0gKHNlZW4gPSB0aGlzLnNlZW4gfHwgKHRoaXMuc2VlbiA9IHt9KSlbYXRdKXsgcmV0dXJuIHRydWUgfVxuXHRcdFx0c2VlblthdF0gPSB0cnVlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdFx0Ly90bXAuZWNob1tjYXQuaWRdID0ge307IC8vIFRPRE86IFdhcm5pbmc6IFRoaXMgdW5zdWJzY3JpYmVzIEFMTCBvZiB0aGlzIGNoYWluJ3MgbGlzdGVuZXJzIGZyb20gdGhpcyBsaW5rLCBub3QganVzdCB0aGUgb25lIGNhbGxiYWNrIGV2ZW50LlxuXHRcdFx0Ly9vYmouZGVsKG1hcCwgYXQpOyAvLyBUT0RPOiBXYXJuaW5nOiBUaGlzIHVuc3Vic2NyaWJlcyBBTEwgb2YgdGhpcyBjaGFpbidzIGxpc3RlbmVycyBmcm9tIHRoaXMgbGluaywgbm90IGp1c3QgdGhlIG9uZSBjYWxsYmFjayBldmVudC5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIGVtcHR5ID0ge30sIHZhbGlkID0gR3VuLnZhbGlkLCB1O1xuXHR9KShVU0UsICcuL2dldCcpO1xuXG5cdDtVU0UoZnVuY3Rpb24obW9kdWxlKXtcblx0XHR2YXIgR3VuID0gVVNFKCcuL3Jvb3QnKTtcblx0XHRHdW4uY2hhaW4ucHV0ID0gZnVuY3Rpb24oZGF0YSwgY2IsIGFzKXsgLy8gSSByZXdyb3RlIGl0IDopXG5cdFx0XHR2YXIgZ3VuID0gdGhpcywgYXQgPSBndW4uXywgcm9vdCA9IGF0LnJvb3Q7XG5cdFx0XHRhcyA9IGFzIHx8IHt9O1xuXHRcdFx0YXMucm9vdCA9IGF0LnJvb3Q7XG5cdFx0XHRhcy5ydW4gfHwgKGFzLnJ1biA9IHJvb3Qub25jZSk7XG5cdFx0XHRzdHVuKGFzLCBhdC5pZCk7IC8vIHNldCBhIGZsYWcgZm9yIHJlYWRzIHRvIGNoZWNrIGlmIHRoaXMgY2hhaW4gaXMgd3JpdGluZy5cblx0XHRcdGFzLmFjayA9IGFzLmFjayB8fCBjYjtcblx0XHRcdGFzLnZpYSA9IGFzLnZpYSB8fCBndW47XG5cdFx0XHRhcy5kYXRhID0gYXMuZGF0YSB8fCBkYXRhO1xuXHRcdFx0YXMuc291bCB8fCAoYXMuc291bCA9IGF0LnNvdWwgfHwgKCdzdHJpbmcnID09IHR5cGVvZiBjYiAmJiBjYikpO1xuXHRcdFx0dmFyIHMgPSBhcy5zdGF0ZSA9IGFzLnN0YXRlIHx8IEd1bi5zdGF0ZSgpO1xuXHRcdFx0aWYoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSl7IGRhdGEoZnVuY3Rpb24oZCl7IGFzLmRhdGEgPSBkOyBndW4ucHV0KHUsdSxhcykgfSk7IHJldHVybiBndW4gfVxuXHRcdFx0aWYoIWFzLnNvdWwpeyByZXR1cm4gZ2V0KGFzKSwgZ3VuIH1cblx0XHRcdGFzLiQgPSByb290LiQuZ2V0KGFzLnNvdWwpOyAvLyBUT0RPOiBUaGlzIG1heSBub3QgYWxsb3cgdXNlciBjaGFpbmluZyBhbmQgc2ltaWxhcj9cblx0XHRcdGFzLnRvZG8gPSBbe2l0OiBhcy5kYXRhLCByZWY6IGFzLiR9XTtcblx0XHRcdGFzLnR1cm4gPSBhcy50dXJuIHx8IHR1cm47XG5cdFx0XHRhcy5yYW4gPSBhcy5yYW4gfHwgcmFuO1xuXHRcdFx0Ly92YXIgcGF0aCA9IFtdOyBhcy52aWEuYmFjayhhdCA9PiB7IGF0LmdldCAmJiBwYXRoLnB1c2goYXQuZ2V0LnNsaWNlKDAsOSkpIH0pOyBwYXRoID0gcGF0aC5yZXZlcnNlKCkuam9pbignLicpO1xuXHRcdFx0Ly8gVE9ETzogUGVyZiEgV2Ugb25seSBuZWVkIHRvIHN0dW4gY2hhaW5zIHRoYXQgYXJlIGJlaW5nIG1vZGlmaWVkLCBub3QgbmVjZXNzYXJpbHkgd3JpdHRlbiB0by5cblx0XHRcdChmdW5jdGlvbiB3YWxrKCl7XG5cdFx0XHRcdHZhciB0byA9IGFzLnRvZG8sIGF0ID0gdG8ucG9wKCksIGQgPSBhdC5pdCwgY2lkID0gYXQucmVmICYmIGF0LnJlZi5fLmlkLCB2LCBrLCBjYXQsIHRtcCwgZztcblx0XHRcdFx0c3R1bihhcywgYXQucmVmKTtcblx0XHRcdFx0aWYodG1wID0gYXQudG9kbyl7XG5cdFx0XHRcdFx0ayA9IHRtcC5wb3AoKTsgZCA9IGRba107XG5cdFx0XHRcdFx0aWYodG1wLmxlbmd0aCl7IHRvLnB1c2goYXQpIH1cblx0XHRcdFx0fVxuXHRcdFx0XHRrICYmICh0by5wYXRoIHx8ICh0by5wYXRoID0gW10pKS5wdXNoKGspO1xuXHRcdFx0XHRpZighKHYgPSB2YWxpZChkKSkgJiYgIShnID0gR3VuLmlzKGQpKSl7XG5cdFx0XHRcdFx0aWYoIU9iamVjdC5wbGFpbihkKSl7IHJhbi5lcnIoYXMsIFwiSW52YWxpZCBkYXRhOiBcIisgY2hlY2soZCkgK1wiIGF0IFwiICsgKGFzLnZpYS5iYWNrKGZ1bmN0aW9uKGF0KXthdC5nZXQgJiYgdG1wLnB1c2goYXQuZ2V0KX0sIHRtcCA9IFtdKSB8fCB0bXAuam9pbignLicpKSsnLicrKHRvLnBhdGh8fFtdKS5qb2luKCcuJykpOyByZXR1cm4gfVxuXHRcdFx0XHRcdHZhciBzZWVuID0gYXMuc2VlbiB8fCAoYXMuc2VlbiA9IFtdKSwgaSA9IHNlZW4ubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlKGktLSl7IGlmKGQgPT09ICh0bXAgPSBzZWVuW2ldKS5pdCl7IHYgPSBkID0gdG1wLmxpbms7IGJyZWFrIH0gfVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGsgJiYgdil7IGF0Lm5vZGUgPSBzdGF0ZV9pZnkoYXQubm9kZSwgaywgcywgZCkgfSAvLyBoYW5kbGUgc291bCBsYXRlci5cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aWYoIWFzLnNlZW4peyByYW4uZXJyKGFzLCBcIkRhdGEgYXQgcm9vdCBvZiBncmFwaCBtdXN0IGJlIGEgbm9kZSAoYW4gb2JqZWN0KS5cIik7IHJldHVybiB9XG5cdFx0XHRcdFx0YXMuc2Vlbi5wdXNoKGNhdCA9IHtpdDogZCwgbGluazoge30sIHRvZG86IGc/IFtdIDogT2JqZWN0LmtleXMoZCkuc29ydCgpLnJldmVyc2UoKSwgcGF0aDogKHRvLnBhdGh8fFtdKS5zbGljZSgpLCB1cDogYXR9KTsgLy8gQW55IHBlcmYgcmVhc29ucyB0byBDUFUgc2NoZWR1bGUgdGhpcyAua2V5cyggP1xuXHRcdFx0XHRcdGF0Lm5vZGUgPSBzdGF0ZV9pZnkoYXQubm9kZSwgaywgcywgY2F0LmxpbmspO1xuXHRcdFx0XHRcdCFnICYmIGNhdC50b2RvLmxlbmd0aCAmJiB0by5wdXNoKGNhdCk7XG5cdFx0XHRcdFx0Ly8gLS0tLS0tLS0tLS0tLS0tXG5cdFx0XHRcdFx0dmFyIGlkID0gYXMuc2Vlbi5sZW5ndGg7XG5cdFx0XHRcdFx0KGFzLndhaXQgfHwgKGFzLndhaXQgPSB7fSkpW2lkXSA9ICcnO1xuXHRcdFx0XHRcdHRtcCA9IChjYXQucmVmID0gKGc/IGQgOiBrPyBhdC5yZWYuZ2V0KGspIDogYXQucmVmKSkuXztcblx0XHRcdFx0XHQodG1wID0gKGQgJiYgKGQuX3x8JycpWycjJ10pIHx8IHRtcC5zb3VsIHx8IHRtcC5saW5rKT8gcmVzb2x2ZSh7c291bDogdG1wfSkgOiBjYXQucmVmLmdldChyZXNvbHZlLCB7cnVuOiBhcy5ydW4sIC8qaGF0Y2g6IDAsKi8gdjIwMjA6MSwgb3V0OntnZXQ6eycuJzonICd9fX0pOyAvLyBUT0RPOiBCVUchIFRoaXMgc2hvdWxkIGJlIHJlc29sdmUgT05MWSBzb3VsIHRvIHByZXZlbnQgZnVsbCBkYXRhIGZyb20gYmVpbmcgbG9hZGVkLiAvLyBGaXhlZCBub3c/XG5cdFx0XHRcdFx0Ly9zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7IGlmKEYpeyByZXR1cm4gfSBjb25zb2xlLmxvZyhcIkkgSEFWRSBOT1QgQkVFTiBDQUxMRUQhXCIsIHBhdGgsIGlkLCBjYXQucmVmLl8uaWQsIGspIH0sIDkwMDApOyB2YXIgRjsgLy8gTUFLRSBTVVJFIFRPIEFERCBGID0gMSBiZWxvdyFcblx0XHRcdFx0XHRmdW5jdGlvbiByZXNvbHZlKG1zZywgZXZlKXtcblx0XHRcdFx0XHRcdHZhciBlbmQgPSBjYXQubGlua1snIyddO1xuXHRcdFx0XHRcdFx0aWYoZXZlKXsgZXZlLm9mZigpOyBldmUucmlkKG1zZykgfSAvLyBUT0RPOiBUb28gZWFybHkhIENoZWNrIGFsbCBwZWVycyBhY2sgbm90IGZvdW5kLlxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogQlVHIG1heWJlPyBNYWtlIHN1cmUgdGhpcyBkb2VzIG5vdCBwaWNrIHVwIGEgbGluayBjaGFuZ2Ugd2lwZSwgdGhhdCBpdCB1c2VzIHRoZSBjaGFuZ2lnbiBsaW5rIGluc3RlYWQuXG5cdFx0XHRcdFx0XHR2YXIgc291bCA9IGVuZCB8fCBtc2cuc291bCB8fCAodG1wID0gKG1zZy4kJHx8bXNnLiQpLl98fCcnKS5zb3VsIHx8IHRtcC5saW5rIHx8ICgodG1wID0gdG1wLnB1dHx8JycpLl98fCcnKVsnIyddIHx8IHRtcFsnIyddIHx8ICgoKHRtcCA9IG1zZy5wdXR8fCcnKSAmJiBtc2cuJCQpPyB0bXBbJyMnXSA6ICh0bXBbJz0nXXx8dG1wWyc6J118fCcnKVsnIyddKTtcblx0XHRcdFx0XHRcdCFlbmQgJiYgc3R1bihhcywgbXNnLiQpO1xuXHRcdFx0XHRcdFx0aWYoIXNvdWwgJiYgIWF0LmxpbmtbJyMnXSl7IC8vIGNoZWNrIHNvdWwgbGluayBhYm92ZSB1c1xuXHRcdFx0XHRcdFx0XHQoYXQud2FpdCB8fCAoYXQud2FpdCA9IFtdKSkucHVzaChmdW5jdGlvbigpeyByZXNvbHZlKG1zZywgZXZlKSB9KSAvLyB3YWl0XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKCFzb3VsKXtcblx0XHRcdFx0XHRcdFx0c291bCA9IFtdO1xuXHRcdFx0XHRcdFx0XHQobXNnLiQkfHxtc2cuJCkuYmFjayhmdW5jdGlvbihhdCl7XG5cdFx0XHRcdFx0XHRcdFx0aWYodG1wID0gYXQuc291bCB8fCBhdC5saW5rKXsgcmV0dXJuIHNvdWwucHVzaCh0bXApIH1cblx0XHRcdFx0XHRcdFx0XHRzb3VsLnB1c2goYXQuZ2V0KTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdHNvdWwgPSBzb3VsLnJldmVyc2UoKS5qb2luKCcvJyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjYXQubGlua1snIyddID0gc291bDtcblx0XHRcdFx0XHRcdCFnICYmICgoKGFzLmdyYXBoIHx8IChhcy5ncmFwaCA9IHt9KSlbc291bF0gPSAoY2F0Lm5vZGUgfHwgKGNhdC5ub2RlID0ge186e319KSkpLl9bJyMnXSA9IHNvdWwpO1xuXHRcdFx0XHRcdFx0ZGVsZXRlIGFzLndhaXRbaWRdO1xuXHRcdFx0XHRcdFx0Y2F0LndhaXQgJiYgc2V0VGltZW91dC5lYWNoKGNhdC53YWl0LCBmdW5jdGlvbihjYil7IGNiICYmIGNiKCkgfSk7XG5cdFx0XHRcdFx0XHRhcy5yYW4oYXMpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0Ly8gLS0tLS0tLS0tLS0tLS0tXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIXRvLmxlbmd0aCl7IHJldHVybiBhcy5yYW4oYXMpIH1cblx0XHRcdFx0YXMudHVybih3YWxrKTtcblx0XHRcdH0oKSk7XG5cdFx0XHRyZXR1cm4gZ3VuO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHN0dW4oYXMsIGlkKXtcblx0XHRcdGlmKCFpZCl7IHJldHVybiB9IGlkID0gKGlkLl98fCcnKS5pZHx8aWQ7XG5cdFx0XHR2YXIgcnVuID0gYXMucm9vdC5zdHVuIHx8IChhcy5yb290LnN0dW4gPSB7b246IEd1bi5vbn0pLCB0ZXN0ID0ge30sIHRtcDtcblx0XHRcdGFzLnN0dW4gfHwgKGFzLnN0dW4gPSBydW4ub24oJ3N0dW4nLCBmdW5jdGlvbigpeyB9KSk7XG5cdFx0XHRpZih0bXAgPSBydW4ub24oJycraWQpKXsgdG1wLnRoZS5sYXN0Lm5leHQodGVzdCkgfVxuXHRcdFx0aWYodGVzdC5ydW4gPj0gYXMucnVuKXsgcmV0dXJuIH1cblx0XHRcdHJ1bi5vbignJytpZCwgZnVuY3Rpb24odGVzdCl7XG5cdFx0XHRcdGlmKGFzLnN0dW4uZW5kKXtcblx0XHRcdFx0XHR0aGlzLm9mZigpO1xuXHRcdFx0XHRcdHRoaXMudG8ubmV4dCh0ZXN0KTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGVzdC5ydW4gPSB0ZXN0LnJ1biB8fCBhcy5ydW47XG5cdFx0XHRcdHRlc3Quc3R1biA9IHRlc3Quc3R1biB8fCBhcy5zdHVuOyByZXR1cm47XG5cdFx0XHRcdGlmKHRoaXMudG8udG8pe1xuXHRcdFx0XHRcdHRoaXMudGhlLmxhc3QubmV4dCh0ZXN0KTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGVzdC5zdHVuID0gYXMuc3R1bjtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJhbihhcyl7XG5cdFx0XHRpZihhcy5lcnIpeyByYW4uZW5kKGFzLnN0dW4sIGFzLnJvb3QpOyByZXR1cm4gfSAvLyBtb3ZlIGxvZyBoYW5kbGUgaGVyZS5cblx0XHRcdGlmKGFzLnRvZG8ubGVuZ3RoIHx8IGFzLmVuZCB8fCAhT2JqZWN0LmVtcHR5KGFzLndhaXQpKXsgcmV0dXJuIH0gYXMuZW5kID0gMTtcblx0XHRcdHZhciBjYXQgPSAoYXMuJC5iYWNrKC0xKS5fKSwgcm9vdCA9IGNhdC5yb290LCBhc2sgPSBjYXQuYXNrKGZ1bmN0aW9uKGFjayl7XG5cdFx0XHRcdHJvb3Qub24oJ2FjaycsIGFjayk7XG5cdFx0XHRcdGlmKGFjay5lcnIpeyBHdW4ubG9nKGFjaykgfVxuXHRcdFx0XHRpZigrK2Fja3MgPiAoYXMuYWNrcyB8fCAwKSl7IHRoaXMub2ZmKCkgfSAvLyBBZGp1c3RhYmxlIEFDS3MhIE9ubHkgMSBieSBkZWZhdWx0LlxuXHRcdFx0XHRpZighYXMuYWNrKXsgcmV0dXJuIH1cblx0XHRcdFx0YXMuYWNrKGFjaywgdGhpcyk7XG5cdFx0XHR9LCBhcy5vcHQpLCBhY2tzID0gMCwgc3R1biA9IGFzLnN0dW4sIHRtcDtcblx0XHRcdCh0bXAgPSBmdW5jdGlvbigpeyAvLyB0aGlzIGlzIG5vdCBvZmZpY2lhbCB5ZXQsIGJ1dCBxdWljayBzb2x1dGlvbiB0byBoYWNrIGluIGZvciBub3cuXG5cdFx0XHRcdGlmKCFzdHVuKXsgcmV0dXJuIH1cblx0XHRcdFx0cmFuLmVuZChzdHVuLCByb290KTtcblx0XHRcdFx0c2V0VGltZW91dC5lYWNoKE9iamVjdC5rZXlzKHN0dW4gPSBzdHVuLmFkZHx8JycpLCBmdW5jdGlvbihjYil7IGlmKGNiID0gc3R1bltjYl0pe2NiKCl9IH0pOyAvLyByZXN1bWUgdGhlIHN0dW5uZWQgcmVhZHMgLy8gQW55IHBlcmYgcmVhc29ucyB0byBDUFUgc2NoZWR1bGUgdGhpcyAua2V5cyggP1xuXHRcdFx0fSkuaGF0Y2ggPSB0bXA7IC8vIHRoaXMgaXMgbm90IG9mZmljaWFsIHlldCBeXG5cdFx0XHQvL2NvbnNvbGUubG9nKDEsIFwiUFVUXCIsIGFzLnJ1biwgYXMuZ3JhcGgpO1xuXHRcdFx0KGFzLnZpYS5fKS5vbignb3V0Jywge3B1dDogYXMub3V0ID0gYXMuZ3JhcGgsIG9wdDogYXMub3B0LCAnIyc6IGFzaywgXzogdG1wfSk7XG5cdFx0fTsgcmFuLmVuZCA9IGZ1bmN0aW9uKHN0dW4scm9vdCl7XG5cdFx0XHRzdHVuLmVuZCA9IG5vb3A7IC8vIGxpa2Ugd2l0aCB0aGUgZWFybGllciBpZCwgY2hlYXBlciB0byBtYWtlIHRoaXMgZmxhZyBhIGZ1bmN0aW9uIHNvIGJlbG93IGNhbGxiYWNrcyBkbyBub3QgaGF2ZSB0byBkbyBhbiBleHRyYSB0eXBlIGNoZWNrLlxuXHRcdFx0aWYoc3R1bi50aGUudG8gPT09IHN0dW4gJiYgc3R1biA9PT0gc3R1bi50aGUubGFzdCl7IGRlbGV0ZSByb290LnN0dW4gfVxuXHRcdFx0c3R1bi5vZmYoKTtcblx0XHR9OyByYW4uZXJyID0gZnVuY3Rpb24oYXMsIGVycil7XG5cdFx0XHQoYXMuYWNrfHxub29wKS5jYWxsKGFzLCBhcy5vdXQgPSB7IGVycjogYXMuZXJyID0gR3VuLmxvZyhlcnIpIH0pO1xuXHRcdFx0YXMucmFuKGFzKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXQoYXMpe1xuXHRcdFx0dmFyIGF0ID0gYXMudmlhLl8sIHRtcDtcblx0XHRcdGFzLnZpYSA9IGFzLnZpYS5iYWNrKGZ1bmN0aW9uKGF0KXtcblx0XHRcdFx0aWYoYXQuc291bCB8fCAhYXQuZ2V0KXsgcmV0dXJuIGF0LiQgfVxuXHRcdFx0XHR0bXAgPSBhcy5kYXRhOyAoYXMuZGF0YSA9IHt9KVthdC5nZXRdID0gdG1wO1xuXHRcdFx0fSk7XG5cdFx0XHRpZighYXMudmlhIHx8ICFhcy52aWEuXy5zb3VsKXtcblx0XHRcdFx0YXMudmlhID0gYXQucm9vdC4kLmdldCgoKGFzLmRhdGF8fCcnKS5ffHwnJylbJyMnXSB8fCBhdC4kLmJhY2soJ29wdC51dWlkJykoKSlcblx0XHRcdH1cblx0XHRcdGFzLnZpYS5wdXQoYXMuZGF0YSwgYXMuYWNrLCBhcyk7XG5cdFx0XHRcblxuXHRcdFx0cmV0dXJuO1xuXHRcdFx0aWYoYXQuZ2V0ICYmIGF0LmJhY2suc291bCl7XG5cdFx0XHRcdHRtcCA9IGFzLmRhdGE7XG5cdFx0XHRcdGFzLnZpYSA9IGF0LmJhY2suJDtcblx0XHRcdFx0KGFzLmRhdGEgPSB7fSlbYXQuZ2V0XSA9IHRtcDsgXG5cdFx0XHRcdGFzLnZpYS5wdXQoYXMuZGF0YSwgYXMuYWNrLCBhcyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZnVuY3Rpb24gY2hlY2soZCwgdG1wKXsgcmV0dXJuICgoZCAmJiAodG1wID0gZC5jb25zdHJ1Y3RvcikgJiYgdG1wLm5hbWUpIHx8IHR5cGVvZiBkKSB9XG5cblx0XHR2YXIgdSwgZW1wdHkgPSB7fSwgbm9vcCA9IGZ1bmN0aW9uKCl7fSwgdHVybiA9IHNldFRpbWVvdXQudHVybiwgdmFsaWQgPSBHdW4udmFsaWQsIHN0YXRlX2lmeSA9IEd1bi5zdGF0ZS5pZnk7XG5cdFx0dmFyIGlpZmUgPSBmdW5jdGlvbihmbixhcyl7Zm4uY2FsbChhc3x8ZW1wdHkpfVxuXHR9KShVU0UsICcuL3B1dCcpO1xuXG5cdDtVU0UoZnVuY3Rpb24obW9kdWxlKXtcblx0XHR2YXIgR3VuID0gVVNFKCcuL3Jvb3QnKTtcblx0XHRVU0UoJy4vY2hhaW4nKTtcblx0XHRVU0UoJy4vYmFjaycpO1xuXHRcdFVTRSgnLi9wdXQnKTtcblx0XHRVU0UoJy4vZ2V0Jyk7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBHdW47XG5cdH0pKFVTRSwgJy4vaW5kZXgnKTtcblxuXHQ7VVNFKGZ1bmN0aW9uKG1vZHVsZSl7XG5cdFx0dmFyIEd1biA9IFVTRSgnLi9pbmRleCcpO1xuXHRcdEd1bi5jaGFpbi5vbiA9IGZ1bmN0aW9uKHRhZywgYXJnLCBlYXMsIGFzKXsgLy8gZG9uJ3QgcmV3cml0ZSFcblx0XHRcdHZhciBndW4gPSB0aGlzLCBjYXQgPSBndW4uXywgcm9vdCA9IGNhdC5yb290LCBhY3QsIG9mZiwgaWQsIHRtcDtcblx0XHRcdGlmKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKXtcblx0XHRcdFx0aWYoIWFyZyl7IHJldHVybiBjYXQub24odGFnKSB9XG5cdFx0XHRcdGFjdCA9IGNhdC5vbih0YWcsIGFyZywgZWFzIHx8IGNhdCwgYXMpO1xuXHRcdFx0XHRpZihlYXMgJiYgZWFzLiQpe1xuXHRcdFx0XHRcdChlYXMuc3VicyB8fCAoZWFzLnN1YnMgPSBbXSkpLnB1c2goYWN0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZ3VuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG9wdCA9IGFyZztcblx0XHRcdChvcHQgPSAodHJ1ZSA9PT0gb3B0KT8ge2NoYW5nZTogdHJ1ZX0gOiBvcHQgfHwge30pLm5vdCA9IDE7IG9wdC5vbiA9IDE7XG5cdFx0XHQvL29wdC5hdCA9IGNhdDtcblx0XHRcdC8vb3B0Lm9rID0gdGFnO1xuXHRcdFx0Ly9vcHQubGFzdCA9IHt9O1xuXHRcdFx0dmFyIHdhaXQgPSB7fTsgLy8gY2FuIHdlIGFzc2lnbiB0aGlzIHRvIHRoZSBhdCBpbnN0ZWFkLCBsaWtlIGluIG9uY2U/XG5cdFx0XHRndW4uZ2V0KHRhZywgb3B0KTtcblx0XHRcdC8qZ3VuLmdldChmdW5jdGlvbiBvbihkYXRhLGtleSxtc2csZXZlKXsgdmFyICQgPSB0aGlzO1xuXHRcdFx0XHRpZih0bXAgPSByb290LmhhdGNoKXsgLy8gcXVpY2sgaGFjayFcblx0XHRcdFx0XHRpZih3YWl0WyQuXy5pZF0peyByZXR1cm4gfSB3YWl0WyQuXy5pZF0gPSAxO1xuXHRcdFx0XHRcdHRtcC5wdXNoKGZ1bmN0aW9uKCl7b24uY2FsbCgkLCBkYXRhLGtleSxtc2csZXZlKX0pO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fTsgd2FpdCA9IHt9OyAvLyBlbmQgcXVpY2sgaGFjay5cblx0XHRcdFx0dGFnLmNhbGwoJCwgZGF0YSxrZXksbXNnLGV2ZSk7XG5cdFx0XHR9LCBvcHQpOyAvLyBUT0RPOiBQRVJGISBFdmVudCBsaXN0ZW5lciBsZWFrISEhPyovXG5cdFx0XHQvKlxuXHRcdFx0ZnVuY3Rpb24gb25lKG1zZywgZXZlKXtcblx0XHRcdFx0aWYob25lLnN0dW4peyByZXR1cm4gfVxuXHRcdFx0XHR2YXIgYXQgPSBtc2cuJC5fLCBkYXRhID0gYXQucHV0LCB0bXA7XG5cdFx0XHRcdGlmKHRtcCA9IGF0LmxpbmspeyBkYXRhID0gcm9vdC4kLmdldCh0bXApLl8ucHV0IH1cblx0XHRcdFx0aWYob3B0Lm5vdD09PXUgJiYgdSA9PT0gZGF0YSl7IHJldHVybiB9XG5cdFx0XHRcdGlmKG9wdC5zdHVuPT09dSAmJiAodG1wID0gcm9vdC5zdHVuKSAmJiAodG1wID0gdG1wW2F0LmlkXSB8fCB0bXBbYXQuYmFjay5pZF0pICYmICF0bXAuZW5kKXsgLy8gUmVtZW1iZXIhIElmIHlvdSBwb3J0IHRoaXMgaW50byBgLmdldChjYmAgbWFrZSBzdXJlIHlvdSBhbGxvdyBzdHVuOjAgc2tpcCBvcHRpb24gZm9yIGAucHV0KGAuXG5cdFx0XHRcdFx0dG1wW2lkXSA9IGZ1bmN0aW9uKCl7b25lKG1zZyxldmUpfTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly90bXAgPSBvbmUud2FpdCB8fCAob25lLndhaXQgPSB7fSk7IGNvbnNvbGUubG9nKHRtcFthdC5pZF0gPT09ICcnKTsgaWYodG1wW2F0LmlkXSAhPT0gJycpeyB0bXBbYXQuaWRdID0gdG1wW2F0LmlkXSB8fCBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dG1wW2F0LmlkXT0nJztvbmUobXNnLGV2ZSl9LDEpOyByZXR1cm4gfSBkZWxldGUgdG1wW2F0LmlkXTtcblx0XHRcdFx0Ly8gY2FsbDpcblx0XHRcdFx0aWYob3B0LmFzKXtcblx0XHRcdFx0XHRvcHQub2suY2FsbChvcHQuYXMsIG1zZywgZXZlIHx8IG9uZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b3B0Lm9rLmNhbGwoYXQuJCwgZGF0YSwgbXNnLmdldCB8fCBhdC5nZXQsIG1zZywgZXZlIHx8IG9uZSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRvbmUuYXQgPSBjYXQ7XG5cdFx0XHQoY2F0LmFjdHx8KGNhdC5hY3Q9e30pKVtpZCA9IFN0cmluZy5yYW5kb20oNyldID0gb25lO1xuXHRcdFx0b25lLm9mZiA9IGZ1bmN0aW9uKCl7IG9uZS5zdHVuID0gMTsgaWYoIWNhdC5hY3QpeyByZXR1cm4gfSBkZWxldGUgY2F0LmFjdFtpZF0gfVxuXHRcdFx0Y2F0Lm9uKCdvdXQnLCB7Z2V0OiB7fX0pOyovXG5cdFx0XHRyZXR1cm4gZ3VuO1xuXHRcdH1cblx0XHQvLyBSdWxlczpcblx0XHQvLyAxLiBJZiBjYWNoZWQsIHNob3VsZCBiZSBmYXN0LCBidXQgbm90IHJlYWQgd2hpbGUgd3JpdGUuXG5cdFx0Ly8gMi4gU2hvdWxkIG5vdCByZXRyaWdnZXIgb3RoZXIgbGlzdGVuZXJzLCBzaG91bGQgZ2V0IHRyaWdnZXJlZCBldmVuIGlmIG5vdGhpbmcgZm91bmQuXG5cdFx0Ly8gMy4gSWYgdGhlIHNhbWUgY2FsbGJhY2sgcGFzc2VkIHRvIG1hbnkgZGlmZmVyZW50IG9uY2UgY2hhaW5zLCBlYWNoIHNob3VsZCByZXNvbHZlIC0gYW4gdW5zdWJzY3JpYmUgZnJvbSB0aGUgc2FtZSBjYWxsYmFjayBzaG91bGQgbm90IGVmZmVjdCB0aGUgc3RhdGUgb2YgdGhlIG90aGVyIHJlc29sdmluZyBjaGFpbnMsIGlmIHlvdSBkbyB3YW50IHRvIGNhbmNlbCB0aGVtIGFsbCBlYXJseSB5b3Ugc2hvdWxkIG11dGF0ZSB0aGUgY2FsbGJhY2sgaXRzZWxmIHdpdGggYSBmbGFnICYgY2hlY2sgZm9yIGl0IGF0IHRvcCBvZiBjYWxsYmFja1xuXHRcdEd1bi5jaGFpbi5vbmNlID0gZnVuY3Rpb24oY2IsIG9wdCl7IG9wdCA9IG9wdCB8fCB7fTsgLy8gYXZvaWQgcmV3cml0aW5nXG5cdFx0XHRpZighY2IpeyByZXR1cm4gbm9uZSh0aGlzLG9wdCkgfVxuXHRcdFx0dmFyIGd1biA9IHRoaXMsIGNhdCA9IGd1bi5fLCByb290ID0gY2F0LnJvb3QsIGRhdGEgPSBjYXQucHV0LCBpZCA9IFN0cmluZy5yYW5kb20oNyksIG9uZSwgdG1wO1xuXHRcdFx0Z3VuLmdldChmdW5jdGlvbihkYXRhLGtleSxtc2csZXZlKXtcblx0XHRcdFx0dmFyICQgPSB0aGlzLCBhdCA9ICQuXywgb25lID0gKGF0Lm9uZXx8KGF0Lm9uZT17fSkpO1xuXHRcdFx0XHRpZihldmUuc3R1bil7IHJldHVybiB9IGlmKCcnID09PSBvbmVbaWRdKXsgcmV0dXJuIH1cblx0XHRcdFx0aWYodHJ1ZSA9PT0gKHRtcCA9IEd1bi52YWxpZChkYXRhKSkpeyBvbmNlKCk7IHJldHVybiB9XG5cdFx0XHRcdGlmKCdzdHJpbmcnID09IHR5cGVvZiB0bXApeyByZXR1cm4gfSAvLyBUT0RPOiBCVUc/IFdpbGwgdGhpcyBhbHdheXMgbG9hZD9cblx0XHRcdFx0Y2xlYXJUaW1lb3V0KChjYXQub25lfHwnJylbaWRdKTsgLy8gY2xlYXIgXCJub3QgZm91bmRcIiBzaW5jZSB0aGV5IG9ubHkgZ2V0IHNldCBvbiBjYXQuXG5cdFx0XHRcdGNsZWFyVGltZW91dChvbmVbaWRdKTsgb25lW2lkXSA9IHNldFRpbWVvdXQob25jZSwgb3B0LndhaXR8fDk5KTsgLy8gVE9ETzogQnVnPyBUaGlzIGRvZXNuJ3QgaGFuZGxlIHBsdXJhbCBjaGFpbnMuXG5cdFx0XHRcdGZ1bmN0aW9uIG9uY2UoZil7XG5cdFx0XHRcdFx0aWYoIWF0LmhhcyAmJiAhYXQuc291bCl7IGF0ID0ge3B1dDogZGF0YSwgZ2V0OiBrZXl9IH0gLy8gaGFuZGxlcyBub24tY29yZSBtZXNzYWdlcy5cblx0XHRcdFx0XHRpZih1ID09PSAodG1wID0gYXQucHV0KSl7IHRtcCA9ICgobXNnLiQkfHwnJykuX3x8JycpLnB1dCB9XG5cdFx0XHRcdFx0aWYoJ3N0cmluZycgPT0gdHlwZW9mIEd1bi52YWxpZCh0bXApKXtcblx0XHRcdFx0XHRcdHRtcCA9IHJvb3QuJC5nZXQodG1wKS5fLnB1dDtcblx0XHRcdFx0XHRcdGlmKHRtcCA9PT0gdSAmJiAhZil7XG5cdFx0XHRcdFx0XHRcdG9uZVtpZF0gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7IG9uY2UoMSkgfSwgb3B0LndhaXR8fDk5KTsgLy8gVE9ETzogUXVpY2sgZml4LiBNYXliZSB1c2UgYWNrIGNvdW50IGZvciBtb3JlIHByZWRpY3RhYmxlIGNvbnRyb2w/XG5cdFx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKFwiQU5EIFZBTklTSEVEXCIsIGRhdGEpO1xuXHRcdFx0XHRcdGlmKGV2ZS5zdHVuKXsgcmV0dXJuIH0gaWYoJycgPT09IG9uZVtpZF0peyByZXR1cm4gfSBvbmVbaWRdID0gJyc7XG5cdFx0XHRcdFx0aWYoY2F0LnNvdWwgfHwgY2F0Lmhhcyl7IGV2ZS5vZmYoKSB9IC8vIFRPRE86IFBsdXJhbCBjaGFpbnM/IC8vIGVsc2UgeyA/Lm9mZigpIH0gLy8gYmV0dGVyIHRoYW4gb25lIGNoZWNrP1xuXHRcdFx0XHRcdGNiLmNhbGwoJCwgdG1wLCBhdC5nZXQpO1xuXHRcdFx0XHRcdGNsZWFyVGltZW91dChvbmVbaWRdKTsgLy8gY2xlYXIgXCJub3QgZm91bmRcIiBzaW5jZSB0aGV5IG9ubHkgZ2V0IHNldCBvbiBjYXQuIC8vIFRPRE86IFRoaXMgd2FzIGhhY2tpbHkgYWRkZWQsIGlzIGl0IG5lY2Vzc2FyeSBvciBpbXBvcnRhbnQ/IFByb2JhYmx5IG5vdCwgaW4gZnV0dXJlIHRyeSByZW1vdmluZyB0aGlzLiBXYXMgYWRkZWQganVzdCBhcyBhIHNhZmV0eSBmb3IgdGhlIGAmJiAhZmAgY2hlY2suXG5cdFx0XHRcdH07XG5cdFx0XHR9LCB7b246IDF9KTtcblx0XHRcdHJldHVybiBndW47XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIG5vbmUoZ3VuLG9wdCxjaGFpbil7XG5cdFx0XHRHdW4ubG9nLm9uY2UoXCJ2YWxvbmNlXCIsIFwiQ2hhaW5hYmxlIHZhbCBpcyBleHBlcmltZW50YWwsIGl0cyBiZWhhdmlvciBhbmQgQVBJIG1heSBjaGFuZ2UgbW92aW5nIGZvcndhcmQuIFBsZWFzZSBwbGF5IHdpdGggaXQgYW5kIHJlcG9ydCBidWdzIGFuZCBpZGVhcyBvbiBob3cgdG8gaW1wcm92ZSBpdC5cIik7XG5cdFx0XHQoY2hhaW4gPSBndW4uY2hhaW4oKSkuXy5uaXggPSBndW4ub25jZShmdW5jdGlvbihkYXRhLCBrZXkpeyBjaGFpbi5fLm9uKCdpbicsIHRoaXMuXykgfSk7XG5cdFx0XHRjaGFpbi5fLmxleCA9IGd1bi5fLmxleDsgLy8gVE9ETzogQmV0dGVyIGFwcHJvYWNoIGluIGZ1dHVyZT8gVGhpcyBpcyBxdWljayBmb3Igbm93LlxuXHRcdFx0cmV0dXJuIGNoYWluO1xuXHRcdH1cblxuXHRcdEd1bi5jaGFpbi5vZmYgPSBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gbWFrZSBvZmYgbW9yZSBhZ2dyZXNzaXZlLiBXYXJuaW5nLCBpdCBtaWdodCBiYWNrZmlyZSFcblx0XHRcdHZhciBndW4gPSB0aGlzLCBhdCA9IGd1bi5fLCB0bXA7XG5cdFx0XHR2YXIgY2F0ID0gYXQuYmFjaztcblx0XHRcdGlmKCFjYXQpeyByZXR1cm4gfVxuXHRcdFx0YXQuYWNrID0gMDsgLy8gc28gY2FuIHJlc3Vic2NyaWJlLlxuXHRcdFx0aWYodG1wID0gY2F0Lm5leHQpe1xuXHRcdFx0XHRpZih0bXBbYXQuZ2V0XSl7XG5cdFx0XHRcdFx0ZGVsZXRlIHRtcFthdC5nZXRdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIFRPRE86IGRlbGV0ZSBjYXQub25lW21hcC5pZF0/XG5cdFx0XHRpZih0bXAgPSBjYXQuYXNrKXtcblx0XHRcdFx0ZGVsZXRlIHRtcFthdC5nZXRdO1xuXHRcdFx0fVxuXHRcdFx0aWYodG1wID0gY2F0LnB1dCl7XG5cdFx0XHRcdGRlbGV0ZSB0bXBbYXQuZ2V0XTtcblx0XHRcdH1cblx0XHRcdGlmKHRtcCA9IGF0LnNvdWwpe1xuXHRcdFx0XHRkZWxldGUgY2F0LnJvb3QuZ3JhcGhbdG1wXTtcblx0XHRcdH1cblx0XHRcdGlmKHRtcCA9IGF0Lm1hcCl7XG5cdFx0XHRcdE9iamVjdC5rZXlzKHRtcCkuZm9yRWFjaChmdW5jdGlvbihpLGF0KXsgYXQgPSB0bXBbaV07IC8vb2JqX21hcCh0bXAsIGZ1bmN0aW9uKGF0KXtcblx0XHRcdFx0XHRpZihhdC5saW5rKXtcblx0XHRcdFx0XHRcdGNhdC5yb290LiQuZ2V0KGF0LmxpbmspLm9mZigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRpZih0bXAgPSBhdC5uZXh0KXtcblx0XHRcdFx0T2JqZWN0LmtleXModG1wKS5mb3JFYWNoKGZ1bmN0aW9uKGksbmVhdCl7IG5lYXQgPSB0bXBbaV07IC8vb2JqX21hcCh0bXAsIGZ1bmN0aW9uKG5lYXQpe1xuXHRcdFx0XHRcdG5lYXQuJC5vZmYoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRhdC5vbignb2ZmJywge30pO1xuXHRcdFx0cmV0dXJuIGd1bjtcblx0XHR9XG5cdFx0dmFyIGVtcHR5ID0ge30sIG5vb3AgPSBmdW5jdGlvbigpe30sIHU7XG5cdH0pKFVTRSwgJy4vb24nKTtcblxuXHQ7VVNFKGZ1bmN0aW9uKG1vZHVsZSl7XG5cdFx0dmFyIEd1biA9IFVTRSgnLi9pbmRleCcpLCBuZXh0ID0gR3VuLmNoYWluLmdldC5uZXh0O1xuXHRcdEd1bi5jaGFpbi5nZXQubmV4dCA9IGZ1bmN0aW9uKGd1biwgbGV4KXsgdmFyIHRtcDtcblx0XHRcdGlmKCFPYmplY3QucGxhaW4obGV4KSl7IHJldHVybiAobmV4dHx8bm9vcCkoZ3VuLCBsZXgpIH1cblx0XHRcdGlmKHRtcCA9ICgodG1wID0gbGV4WycjJ10pfHwnJylbJz0nXSB8fCB0bXApeyByZXR1cm4gZ3VuLmdldCh0bXApIH1cblx0XHRcdCh0bXAgPSBndW4uY2hhaW4oKS5fKS5sZXggPSBsZXg7IC8vIExFWCFcblx0XHRcdGd1bi5vbignaW4nLCBmdW5jdGlvbihldmUpe1xuXHRcdFx0XHRpZihTdHJpbmcubWF0Y2goZXZlLmdldHx8IChldmUucHV0fHwnJylbJy4nXSwgbGV4WycuJ10gfHwgbGV4WycjJ10gfHwgbGV4KSl7XG5cdFx0XHRcdFx0dG1wLm9uKCdpbicsIGV2ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy50by5uZXh0KGV2ZSk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiB0bXAuJDtcblx0XHR9XG5cdFx0R3VuLmNoYWluLm1hcCA9IGZ1bmN0aW9uKGNiLCBvcHQsIHQpe1xuXHRcdFx0dmFyIGd1biA9IHRoaXMsIGNhdCA9IGd1bi5fLCBsZXgsIGNoYWluO1xuXHRcdFx0aWYoT2JqZWN0LnBsYWluKGNiKSl7IGxleCA9IGNiWycuJ10/IGNiIDogeycuJzogY2J9OyBjYiA9IHUgfVxuXHRcdFx0aWYoIWNiKXtcblx0XHRcdFx0aWYoY2hhaW4gPSBjYXQuZWFjaCl7IHJldHVybiBjaGFpbiB9XG5cdFx0XHRcdChjYXQuZWFjaCA9IGNoYWluID0gZ3VuLmNoYWluKCkpLl8ubGV4ID0gbGV4IHx8IGNoYWluLl8ubGV4IHx8IGNhdC5sZXg7XG5cdFx0XHRcdGNoYWluLl8ubml4ID0gZ3VuLmJhY2soJ25peCcpO1xuXHRcdFx0XHRndW4ub24oJ2luJywgbWFwLCBjaGFpbi5fKTtcblx0XHRcdFx0cmV0dXJuIGNoYWluO1xuXHRcdFx0fVxuXHRcdFx0R3VuLmxvZy5vbmNlKFwibWFwZm5cIiwgXCJNYXAgZnVuY3Rpb25zIGFyZSBleHBlcmltZW50YWwsIHRoZWlyIGJlaGF2aW9yIGFuZCBBUEkgbWF5IGNoYW5nZSBtb3ZpbmcgZm9yd2FyZC4gUGxlYXNlIHBsYXkgd2l0aCBpdCBhbmQgcmVwb3J0IGJ1Z3MgYW5kIGlkZWFzIG9uIGhvdyB0byBpbXByb3ZlIGl0LlwiKTtcblx0XHRcdGNoYWluID0gZ3VuLmNoYWluKCk7XG5cdFx0XHRndW4ubWFwKCkub24oZnVuY3Rpb24oZGF0YSwga2V5LCBtc2csIGV2ZSl7XG5cdFx0XHRcdHZhciBuZXh0ID0gKGNifHxub29wKS5jYWxsKHRoaXMsIGRhdGEsIGtleSwgbXNnLCBldmUpO1xuXHRcdFx0XHRpZih1ID09PSBuZXh0KXsgcmV0dXJuIH1cblx0XHRcdFx0aWYoZGF0YSA9PT0gbmV4dCl7IHJldHVybiBjaGFpbi5fLm9uKCdpbicsIG1zZykgfVxuXHRcdFx0XHRpZihHdW4uaXMobmV4dCkpeyByZXR1cm4gY2hhaW4uXy5vbignaW4nLCBuZXh0Ll8pIH1cblx0XHRcdFx0dmFyIHRtcCA9IHt9OyBPYmplY3Qua2V5cyhtc2cucHV0KS5mb3JFYWNoKGZ1bmN0aW9uKGspeyB0bXBba10gPSBtc2cucHV0W2tdIH0sIHRtcCk7IHRtcFsnPSddID0gbmV4dDsgXG5cdFx0XHRcdGNoYWluLl8ub24oJ2luJywge2dldDoga2V5LCBwdXQ6IHRtcH0pO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gY2hhaW47XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIG1hcChtc2cpeyB0aGlzLnRvLm5leHQobXNnKTtcblx0XHRcdHZhciBjYXQgPSB0aGlzLmFzLCBndW4gPSBtc2cuJCwgYXQgPSBndW4uXywgcHV0ID0gbXNnLnB1dCwgdG1wO1xuXHRcdFx0aWYoIWF0LnNvdWwgJiYgIW1zZy4kJCl7IHJldHVybiB9IC8vIHRoaXMgbGluZSB0b29rIGh1bmRyZWRzIG9mIHRyaWVzIHRvIGZpZ3VyZSBvdXQuIEl0IG9ubHkgd29ya3MgaWYgY29yZSBjaGVja3MgdG8gZmlsdGVyIG91dCBhYm92ZSBjaGFpbnMgZHVyaW5nIGxpbmsgdGhvLiBUaGlzIHNheXMgXCJvbmx5IGJvdGhlciB0byBtYXAgb24gYSBub2RlXCIgZm9yIHRoaXMgbGF5ZXIgb2YgdGhlIGNoYWluLiBJZiBzb21ldGhpbmcgaXMgbm90IGEgbm9kZSwgbWFwIHNob3VsZCBub3Qgd29yay5cblx0XHRcdGlmKCh0bXAgPSBjYXQubGV4KSAmJiAhU3RyaW5nLm1hdGNoKG1zZy5nZXR8fCAocHV0fHwnJylbJy4nXSwgdG1wWycuJ10gfHwgdG1wWycjJ10gfHwgdG1wKSl7IHJldHVybiB9XG5cdFx0XHRHdW4ub24ubGluayhtc2csIGNhdCk7XG5cdFx0fVxuXHRcdHZhciBub29wID0gZnVuY3Rpb24oKXt9LCBldmVudCA9IHtzdHVuOiBub29wLCBvZmY6IG5vb3B9LCB1O1xuXHR9KShVU0UsICcuL21hcCcpO1xuXG5cdDtVU0UoZnVuY3Rpb24obW9kdWxlKXtcblx0XHR2YXIgR3VuID0gVVNFKCcuL2luZGV4Jyk7XG5cdFx0R3VuLmNoYWluLnNldCA9IGZ1bmN0aW9uKGl0ZW0sIGNiLCBvcHQpe1xuXHRcdFx0dmFyIGd1biA9IHRoaXMsIHJvb3QgPSBndW4uYmFjaygtMSksIHNvdWwsIHRtcDtcblx0XHRcdGNiID0gY2IgfHwgZnVuY3Rpb24oKXt9O1xuXHRcdFx0b3B0ID0gb3B0IHx8IHt9OyBvcHQuaXRlbSA9IG9wdC5pdGVtIHx8IGl0ZW07XG5cdFx0XHRpZihzb3VsID0gKChpdGVtfHwnJykuX3x8JycpWycjJ10peyAoaXRlbSA9IHt9KVsnIyddID0gc291bCB9IC8vIGNoZWNrIGlmIG5vZGUsIG1ha2UgbGluay5cblx0XHRcdGlmKCdzdHJpbmcnID09IHR5cGVvZiAodG1wID0gR3VuLnZhbGlkKGl0ZW0pKSl7IHJldHVybiBndW4uZ2V0KHNvdWwgPSB0bXApLnB1dChpdGVtLCBjYiwgb3B0KSB9IC8vIGNoZWNrIGlmIGxpbmtcblx0XHRcdGlmKCFHdW4uaXMoaXRlbSkpe1xuXHRcdFx0XHRpZihPYmplY3QucGxhaW4oaXRlbSkpe1xuXHRcdFx0XHRcdGl0ZW0gPSByb290LmdldChzb3VsID0gZ3VuLmJhY2soJ29wdC51dWlkJykoKSkucHV0KGl0ZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBndW4uZ2V0KHNvdWwgfHwgcm9vdC5iYWNrKCdvcHQudXVpZCcpKDcpKS5wdXQoaXRlbSwgY2IsIG9wdCk7XG5cdFx0XHR9XG5cdFx0XHRndW4ucHV0KGZ1bmN0aW9uKGdvKXtcblx0XHRcdFx0aXRlbS5nZXQoZnVuY3Rpb24oc291bCwgbywgbXNnKXsgLy8gVE9ETzogQlVHISBXZSBubyBsb25nZXIgaGF2ZSB0aGlzIG9wdGlvbj8gJiBnbyBlcnJvciBub3QgaGFuZGxlZD9cblx0XHRcdFx0XHRpZighc291bCl7IHJldHVybiBjYi5jYWxsKGd1biwge2VycjogR3VuLmxvZygnT25seSBhIG5vZGUgY2FuIGJlIGxpbmtlZCEgTm90IFwiJyArIG1zZy5wdXQgKyAnXCIhJyl9KSB9XG5cdFx0XHRcdFx0KHRtcCA9IHt9KVtzb3VsXSA9IHsnIyc6IHNvdWx9OyBnbyh0bXApO1xuXHRcdFx0XHR9LHRydWUpO1xuXHRcdFx0fSlcblx0XHRcdHJldHVybiBpdGVtO1xuXHRcdH1cblx0fSkoVVNFLCAnLi9zZXQnKTtcblxuXHQ7VVNFKGZ1bmN0aW9uKG1vZHVsZSl7XG5cdFx0VVNFKCcuL3NoaW0nKTtcblxuXHRcdHZhciBub29wID0gZnVuY3Rpb24oKXt9XG5cdFx0dmFyIHBhcnNlID0gSlNPTi5wYXJzZUFzeW5jIHx8IGZ1bmN0aW9uKHQsY2Iscil7IHZhciB1LCBkID0gK25ldyBEYXRlOyB0cnl7IGNiKHUsIEpTT04ucGFyc2UodCxyKSwganNvbi5zdWNrcygrbmV3IERhdGUgLSBkKSkgfWNhdGNoKGUpeyBjYihlKSB9IH1cblx0XHR2YXIganNvbiA9IEpTT04uc3RyaW5naWZ5QXN5bmMgfHwgZnVuY3Rpb24odixjYixyLHMpeyB2YXIgdSwgZCA9ICtuZXcgRGF0ZTsgdHJ5eyBjYih1LCBKU09OLnN0cmluZ2lmeSh2LHIscyksIGpzb24uc3Vja3MoK25ldyBEYXRlIC0gZCkpIH1jYXRjaChlKXsgY2IoZSkgfSB9XG5cdFx0anNvbi5zdWNrcyA9IGZ1bmN0aW9uKGQpeyBpZihkID4gOTkpeyBjb25zb2xlLmxvZyhcIldhcm5pbmc6IEpTT04gYmxvY2tpbmcgQ1BVIGRldGVjdGVkLiBBZGQgYGd1bi9saWIveXNvbi5qc2AgdG8gZml4LlwiKTsganNvbi5zdWNrcyA9IG5vb3AgfSB9XG5cblx0XHRmdW5jdGlvbiBNZXNoKHJvb3Qpe1xuXHRcdFx0dmFyIG1lc2ggPSBmdW5jdGlvbigpe307XG5cdFx0XHR2YXIgb3B0ID0gcm9vdC5vcHQgfHwge307XG5cdFx0XHRvcHQubG9nID0gb3B0LmxvZyB8fCBjb25zb2xlLmxvZztcblx0XHRcdG9wdC5nYXAgPSBvcHQuZ2FwIHx8IG9wdC53YWl0IHx8IDA7XG5cdFx0XHRvcHQubWF4ID0gb3B0Lm1heCB8fCAob3B0Lm1lbW9yeT8gKG9wdC5tZW1vcnkgKiA5OTkgKiA5OTkpIDogMzAwMDAwMDAwKSAqIDAuMztcblx0XHRcdG9wdC5wYWNrID0gb3B0LnBhY2sgfHwgKG9wdC5tYXggKiAwLjAxICogMC4wMSk7XG5cdFx0XHRvcHQucHVmZiA9IG9wdC5wdWZmIHx8IDk7IC8vIElERUE6IGRvIGEgc3RhcnQvZW5kIGJlbmNobWFyaywgZGl2aWRlIG9wcy9yZXN1bHQuXG5cdFx0XHR2YXIgcHVmZiA9IHNldFRpbWVvdXQudHVybiB8fCBzZXRUaW1lb3V0O1xuXG5cdFx0XHR2YXIgZHVwID0gcm9vdC5kdXAsIGR1cF9jaGVjayA9IGR1cC5jaGVjaywgZHVwX3RyYWNrID0gZHVwLnRyYWNrO1xuXG5cdFx0XHR2YXIgU1QgPSArbmV3IERhdGUsIExUID0gU1Q7XG5cblx0XHRcdHZhciBoZWFyID0gbWVzaC5oZWFyID0gZnVuY3Rpb24ocmF3LCBwZWVyKXtcblx0XHRcdFx0aWYoIXJhdyl7IHJldHVybiB9XG5cdFx0XHRcdGlmKG9wdC5tYXggPD0gcmF3Lmxlbmd0aCl7IHJldHVybiBtZXNoLnNheSh7ZGFtOiAnIScsIGVycjogXCJNZXNzYWdlIHRvbyBiaWchXCJ9LCBwZWVyKSB9XG5cdFx0XHRcdGlmKG1lc2ggPT09IHRoaXMpe1xuXHRcdFx0XHRcdC8qaWYoJ3N0cmluZycgPT0gdHlwZW9mIHJhdyl7IHRyeXtcblx0XHRcdFx0XHRcdHZhciBzdGF0ID0gY29uc29sZS5TVEFUIHx8IHt9O1xuXHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnSEVBUjonLCBwZWVyLmlkLCAocmF3fHwnJykuc2xpY2UoMCwyNTApLCAoKHJhd3x8JycpLmxlbmd0aCAvIDEwMjQgLyAxMDI0KS50b0ZpeGVkKDQpKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZyhzZXRUaW1lb3V0LnR1cm4ucy5sZW5ndGgsICdzdGFja3MnLCBwYXJzZUZsb2F0KCgtKExUIC0gKExUID0gK25ldyBEYXRlKSkvMTAwMCkudG9GaXhlZCgzKSksICdzZWMnLCBwYXJzZUZsb2F0KCgoTFQtU1QpLzEwMDAgLyA2MCkudG9GaXhlZCgxKSksICd1cCcsIHN0YXQucGVlcnN8fDAsICdwZWVycycsIHN0YXQuaGFzfHwwLCAnaGFzJywgc3RhdC5tZW1odXNlZHx8MCwgc3RhdC5tZW11c2VkfHwwLCBzdGF0Lm1lbWF4fHwwLCAnaGVhcCBtZW0gbWF4Jyk7XG5cdFx0XHRcdFx0fWNhdGNoKGUpeyBjb25zb2xlLmxvZygnREJHIGVycicsIGUpIH19Ki9cblx0XHRcdFx0XHRoZWFyLmQgKz0gcmF3Lmxlbmd0aHx8MCA7ICsraGVhci5jIH0gLy8gU1RBVFMhXG5cdFx0XHRcdHZhciBTID0gcGVlci5TSCA9ICtuZXcgRGF0ZTtcblx0XHRcdFx0dmFyIHRtcCA9IHJhd1swXSwgbXNnO1xuXHRcdFx0XHQvL3JhdyAmJiByYXcuc2xpY2UgJiYgY29uc29sZS5sb2coXCJoZWFyOlwiLCAoKHBlZXIud2lyZXx8JycpLmhlYWRlcnN8fCcnKS5vcmlnaW4sIHJhdy5sZW5ndGgsIHJhdy5zbGljZSAmJiByYXcuc2xpY2UoMCw1MCkpOyAvL3RjLWlhbXVuaXF1ZS10Yy1wYWNrYWdlLWRzMVxuXHRcdFx0XHRpZignWycgPT09IHRtcCl7XG5cdFx0XHRcdFx0cGFyc2UocmF3LCBmdW5jdGlvbihlcnIsIG1zZyl7XG5cdFx0XHRcdFx0XHRpZihlcnIgfHwgIW1zZyl7IHJldHVybiBtZXNoLnNheSh7ZGFtOiAnIScsIGVycjogXCJEQU0gSlNPTiBwYXJzZSBlcnJvci5cIn0sIHBlZXIpIH1cblx0XHRcdFx0XHRcdGNvbnNvbGUuU1RBVCAmJiBjb25zb2xlLlNUQVQoK25ldyBEYXRlLCBtc2cubGVuZ3RoLCAnIyBvbiBoZWFyIGJhdGNoJyk7XG5cdFx0XHRcdFx0XHR2YXIgUCA9IG9wdC5wdWZmO1xuXHRcdFx0XHRcdFx0KGZ1bmN0aW9uIGdvKCl7XG5cdFx0XHRcdFx0XHRcdHZhciBTID0gK25ldyBEYXRlO1xuXHRcdFx0XHRcdFx0XHR2YXIgaSA9IDAsIG07IHdoaWxlKGkgPCBQICYmIChtID0gbXNnW2krK10pKXsgbWVzaC5oZWFyKG0sIHBlZXIpIH1cblx0XHRcdFx0XHRcdFx0bXNnID0gbXNnLnNsaWNlKGkpOyAvLyBzbGljaW5nIGFmdGVyIGlzIGZhc3RlciB0aGFuIHNoaWZ0aW5nIGR1cmluZy5cblx0XHRcdFx0XHRcdFx0Y29uc29sZS5TVEFUICYmIGNvbnNvbGUuU1RBVChTLCArbmV3IERhdGUgLSBTLCAnaGVhciBsb29wJyk7XG5cdFx0XHRcdFx0XHRcdGZsdXNoKHBlZXIpOyAvLyBmb3JjZSBzZW5kIGFsbCBzeW5jaHJvbm91c2x5IGJhdGNoZWQgYWNrcy5cblx0XHRcdFx0XHRcdFx0aWYoIW1zZy5sZW5ndGgpeyByZXR1cm4gfVxuXHRcdFx0XHRcdFx0XHRwdWZmKGdvLCAwKTtcblx0XHRcdFx0XHRcdH0oKSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0cmF3ID0gJyc7IC8vIFxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZigneycgPT09IHRtcCB8fCAoKHJhd1snIyddIHx8IE9iamVjdC5wbGFpbihyYXcpKSAmJiAobXNnID0gcmF3KSkpe1xuXHRcdFx0XHRcdGlmKG1zZyl7IHJldHVybiBoZWFyLm9uZShtc2csIHBlZXIsIFMpIH1cblx0XHRcdFx0XHRwYXJzZShyYXcsIGZ1bmN0aW9uKGVyciwgbXNnKXtcblx0XHRcdFx0XHRcdGlmKGVyciB8fCAhbXNnKXsgcmV0dXJuIG1lc2guc2F5KHtkYW06ICchJywgZXJyOiBcIkRBTSBKU09OIHBhcnNlIGVycm9yLlwifSwgcGVlcikgfVxuXHRcdFx0XHRcdFx0aGVhci5vbmUobXNnLCBwZWVyLCBTKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGhlYXIub25lID0gZnVuY3Rpb24obXNnLCBwZWVyLCBTKXsgLy8gUyBoZXJlIGlzIHRlbXBvcmFyeSEgVW5kby5cblx0XHRcdFx0dmFyIGlkLCBoYXNoLCB0bXAsIGFzaCwgREJHO1xuXHRcdFx0XHRpZihtc2cuREJHKXsgbXNnLkRCRyA9IERCRyA9IHtEQkc6IG1zZy5EQkd9IH1cblx0XHRcdFx0REJHICYmIChEQkcuaCA9IFMpO1xuXHRcdFx0XHREQkcgJiYgKERCRy5ocCA9ICtuZXcgRGF0ZSk7XG5cdFx0XHRcdGlmKCEoaWQgPSBtc2dbJyMnXSkpeyBpZCA9IG1zZ1snIyddID0gU3RyaW5nLnJhbmRvbSg5KSB9XG5cdFx0XHRcdGlmKHRtcCA9IGR1cF9jaGVjayhpZCkpeyByZXR1cm4gfVxuXHRcdFx0XHQvLyBEQU0gbG9naWM6XG5cdFx0XHRcdGlmKCEoaGFzaCA9IG1zZ1snIyMnXSkgJiYgZmFsc2UgJiYgdSAhPT0gbXNnLnB1dCl7IC8qaGFzaCA9IG1zZ1snIyMnXSA9IFR5cGUub2JqLmhhc2gobXNnLnB1dCkqLyB9IC8vIGRpc2FibGUgaGFzaGluZyBmb3Igbm93IC8vIFRPRE86IGltcG9zZSB3YXJuaW5nL3BlbmFsdHkgaW5zdGVhZCAoPylcblx0XHRcdFx0aWYoaGFzaCAmJiAodG1wID0gbXNnWydAJ10gfHwgKG1zZy5nZXQgJiYgaWQpKSAmJiBkdXAuY2hlY2soYXNoID0gdG1wK2hhc2gpKXsgcmV0dXJuIH0gLy8gSW1hZ2luZSBBIDwtPiBCIDw9PiAoQyAmIEQpLCBDICYgRCByZXBseSB3aXRoIHNhbWUgQUNLIGJ1dCBoYXZlIGRpZmZlcmVudCBJRHMsIEIgY2FuIHVzZSBoYXNoIHRvIGRlZHVwLiBPciBpZiBhIEdFVCBoYXMgYSBoYXNoIGFscmVhZHksIHdlIHNob3VsZG4ndCBBQ0sgaWYgc2FtZS5cblx0XHRcdFx0KG1zZy5fID0gZnVuY3Rpb24oKXt9KS52aWEgPSBtZXNoLmxlYXAgPSBwZWVyO1xuXHRcdFx0XHRpZigodG1wID0gbXNnWyc+PCddKSAmJiAnc3RyaW5nJyA9PSB0eXBlb2YgdG1wKXsgdG1wLnNsaWNlKDAsOTkpLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbihrKXsgdGhpc1trXSA9IDEgfSwgKG1zZy5fKS55byA9IHt9KSB9IC8vIFBlZXJzIGFscmVhZHkgc2VudCB0bywgZG8gbm90IHJlc2VuZC5cblx0XHRcdFx0Ly8gREFNIF5cblx0XHRcdFx0aWYodG1wID0gbXNnLmRhbSl7XG5cdFx0XHRcdFx0aWYodG1wID0gbWVzaC5oZWFyW3RtcF0pe1xuXHRcdFx0XHRcdFx0dG1wKG1zZywgcGVlciwgcm9vdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGR1cF90cmFjayhpZCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBTID0gK25ldyBEYXRlO1xuXHRcdFx0XHREQkcgJiYgKERCRy5pcyA9IFMpOyBwZWVyLlNJID0gaWQ7XG5cdFx0XHRcdHJvb3Qub24oJ2luJywgbWVzaC5sYXN0ID0gbXNnKTtcblx0XHRcdFx0Ly9FQ0hPID0gbXNnLnB1dCB8fCBFQ0hPOyAhKG1zZy5vayAhPT0gLTM3NDApICYmIG1lc2guc2F5KHtvazogLTM3NDAsIHB1dDogRUNITywgJ0AnOiBtc2dbJyMnXX0sIHBlZXIpO1xuXHRcdFx0XHREQkcgJiYgKERCRy5oZCA9ICtuZXcgRGF0ZSk7XG5cdFx0XHRcdGNvbnNvbGUuU1RBVCAmJiBjb25zb2xlLlNUQVQoUywgK25ldyBEYXRlIC0gUywgbXNnLmdldD8gJ21zZyBnZXQnIDogbXNnLnB1dD8gJ21zZyBwdXQnIDogJ21zZycpO1xuXHRcdFx0XHQodG1wID0gZHVwX3RyYWNrKGlkKSkudmlhID0gcGVlcjsgLy8gZG9uJ3QgZGVkdXAgbWVzc2FnZSBJRCB0aWxsIGFmdGVyLCBjYXVzZSBHVU4gaGFzIGludGVybmFsIGRlZHVwIGNoZWNrLlxuXHRcdFx0XHRpZihtc2cuZ2V0KXsgdG1wLml0ID0gbXNnIH1cblx0XHRcdFx0aWYoYXNoKXsgZHVwX3RyYWNrKGFzaCkgfSAvL2R1cC50cmFjayh0bXAraGFzaCwgdHJ1ZSkuaXQgPSBpdChtc2cpO1xuXHRcdFx0XHRtZXNoLmxlYXAgPSBtZXNoLmxhc3QgPSBudWxsOyAvLyB3YXJuaW5nISBtZXNoLmxlYXAgY291bGQgYmUgYnVnZ3kuXG5cdFx0XHR9XG5cdFx0XHR2YXIgdG9tYXAgPSBmdW5jdGlvbihrLGksbSl7bShrLHRydWUpfTtcblx0XHRcdGhlYXIuYyA9IGhlYXIuZCA9IDA7XG5cblx0XHRcdDsoZnVuY3Rpb24oKXtcblx0XHRcdFx0dmFyIFNNSUEgPSAwO1xuXHRcdFx0XHR2YXIgbG9vcDtcblx0XHRcdFx0bWVzaC5oYXNoID0gZnVuY3Rpb24obXNnLCBwZWVyKXsgdmFyIGgsIHMsIHQ7XG5cdFx0XHRcdFx0dmFyIFMgPSArbmV3IERhdGU7XG5cdFx0XHRcdFx0anNvbihtc2cucHV0LCBmdW5jdGlvbiBoYXNoKGVyciwgdGV4dCl7XG5cdFx0XHRcdFx0XHR2YXIgc3MgPSAocyB8fCAocyA9IHQgPSB0ZXh0fHwnJykpLnNsaWNlKDAsIDMyNzY4KTsgLy8gMTAyNCAqIDMyXG5cdFx0XHRcdFx0ICBoID0gU3RyaW5nLmhhc2goc3MsIGgpOyBzID0gcy5zbGljZSgzMjc2OCk7XG5cdFx0XHRcdFx0ICBpZihzKXsgcHVmZihoYXNoLCAwKTsgcmV0dXJuIH1cblx0XHRcdFx0XHRcdGNvbnNvbGUuU1RBVCAmJiBjb25zb2xlLlNUQVQoUywgK25ldyBEYXRlIC0gUywgJ3NheSBqc29uK2hhc2gnKTtcblx0XHRcdFx0XHQgIG1zZy5fLiRwdXQgPSB0O1xuXHRcdFx0XHRcdCAgbXNnWycjIyddID0gaDtcblx0XHRcdFx0XHQgIG1lc2guc2F5KG1zZywgcGVlcik7XG5cdFx0XHRcdFx0ICBkZWxldGUgbXNnLl8uJHB1dDtcblx0XHRcdFx0XHR9LCBzb3J0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmdW5jdGlvbiBzb3J0KGssIHYpeyB2YXIgdG1wO1xuXHRcdFx0XHRcdGlmKCEodiBpbnN0YW5jZW9mIE9iamVjdCkpeyByZXR1cm4gdiB9XG5cdFx0XHRcdFx0T2JqZWN0LmtleXModikuc29ydCgpLmZvckVhY2goc29ydGEsIHt0bzogdG1wID0ge30sIG9uOiB2fSk7XG5cdFx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdFx0fSBmdW5jdGlvbiBzb3J0YShrKXsgdGhpcy50b1trXSA9IHRoaXMub25ba10gfVxuXG5cdFx0XHRcdHZhciBzYXkgPSBtZXNoLnNheSA9IGZ1bmN0aW9uKG1zZywgcGVlcil7IHZhciB0bXA7XG5cdFx0XHRcdFx0aWYoKHRtcCA9IHRoaXMpICYmICh0bXAgPSB0bXAudG8pICYmIHRtcC5uZXh0KXsgdG1wLm5leHQobXNnKSB9IC8vIGNvbXBhdGlibGUgd2l0aCBtaWRkbGV3YXJlIGFkYXB0ZXJzLlxuXHRcdFx0XHRcdGlmKCFtc2cpeyByZXR1cm4gZmFsc2UgfVxuXHRcdFx0XHRcdHZhciBpZCwgaGFzaCwgcmF3LCBhY2sgPSBtc2dbJ0AnXTtcbi8vaWYob3B0LnN1cGVyICYmICghYWNrIHx8ICFtc2cucHV0KSl7IHJldHVybiB9IC8vIFRPRE86IE1BTkhBVFRBTiBTVFVCIC8vT0JWSU9VU0xZIEJVRyEgQnV0IHNxdWVsY2ggcmVsYXkuIC8vIDooIGdldCBvbmx5IGlzIDEwMCUrIENQVSB1c2FnZSA6KFxuXHRcdFx0XHRcdHZhciBtZXRhID0gbXNnLl98fChtc2cuXz1mdW5jdGlvbigpe30pO1xuXHRcdFx0XHRcdHZhciBEQkcgPSBtc2cuREJHLCBTID0gK25ldyBEYXRlOyBtZXRhLnkgPSBtZXRhLnkgfHwgUzsgaWYoIXBlZXIpeyBEQkcgJiYgKERCRy55ID0gUykgfVxuXHRcdFx0XHRcdGlmKCEoaWQgPSBtc2dbJyMnXSkpeyBpZCA9IG1zZ1snIyddID0gU3RyaW5nLnJhbmRvbSg5KSB9XG5cdFx0XHRcdFx0IWxvb3AgJiYgZHVwX3RyYWNrKGlkKTsvLy5pdCA9IGl0KG1zZyk7IC8vIHRyYWNrIGZvciA5IHNlY29uZHMsIGRlZmF1bHQuIEVhcnRoPC0+TWFycyB3b3VsZCBuZWVkIG1vcmUhIC8vIGFsd2F5cyB0cmFjaywgbWF5YmUgbW92ZSB0aGlzIHRvIHRoZSAnYWZ0ZXInIGxvZ2ljIGlmIHdlIHNwbGl0IGZ1bmN0aW9uLlxuXHRcdFx0XHRcdGlmKG1zZy5wdXQgJiYgKG1zZy5lcnIgfHwgKGR1cC5zW2lkXXx8JycpLmVycikpeyByZXR1cm4gZmFsc2UgfSAvLyBUT0RPOiBpbiB0aGVvcnkgd2Ugc2hvdWxkIG5vdCBiZSBhYmxlIHRvIHN0dW4gYSBtZXNzYWdlLCBidXQgZm9yIG5vdyBnb2luZyB0byBjaGVjayBpZiBpdCBjYW4gaGVscCBuZXR3b3JrIHBlcmZvcm1hbmNlIHByZXZlbnRpbmcgaW52YWxpZCBkYXRhIHRvIHJlbGF5LlxuXHRcdFx0XHRcdGlmKCEoaGFzaCA9IG1zZ1snIyMnXSkgJiYgdSAhPT0gbXNnLnB1dCAmJiAhbWV0YS52aWEgJiYgYWNrKXsgbWVzaC5oYXNoKG1zZywgcGVlcik7IHJldHVybiB9IC8vIFRPRE86IFNob3VsZCBicm9hZGNhc3RzIGJlIGhhc2hlZD9cblx0XHRcdFx0XHRpZighcGVlciAmJiBhY2speyBwZWVyID0gKCh0bXAgPSBkdXAuc1thY2tdKSAmJiAodG1wLnZpYSB8fCAoKHRtcCA9IHRtcC5pdCkgJiYgKHRtcCA9IHRtcC5fKSAmJiB0bXAudmlhKSkpIHx8ICgodG1wID0gbWVzaC5sYXN0KSAmJiBhY2sgPT09IHRtcFsnIyddICYmIG1lc2gubGVhcCkgfSAvLyB3YXJuaW5nISBtZXNoLmxlYXAgY291bGQgYmUgYnVnZ3khIG1lc2ggbGFzdCBjaGVjayByZWR1Y2VzIHRoaXMuXG5cdFx0XHRcdFx0aWYoIXBlZXIgJiYgYWNrKXsgLy8gc3RpbGwgbm8gcGVlciwgdGhlbiBhY2sgZGFpc3kgY2hhaW4gbG9zdC5cblx0XHRcdFx0XHRcdGlmKGR1cC5zW2Fja10peyByZXR1cm4gfSAvLyBpbiBkdXBzIGJ1dCBubyBwZWVyIGhpbnRzIHRoYXQgdGhpcyB3YXMgYWNrIHRvIHNlbGYsIGlnbm9yZS5cblx0XHRcdFx0XHRcdGNvbnNvbGUuU1RBVCAmJiBjb25zb2xlLlNUQVQoK25ldyBEYXRlLCArK1NNSUEsICd0b3RhbCBubyBwZWVyIHRvIGFjayB0bycpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH0gLy8gVE9ETzogVGVtcG9yYXJ5PyBJZiBhY2sgdmlhIHRyYWNlIGhhcyBiZWVuIGxvc3QsIGFja3Mgd2lsbCBnbyB0byBhbGwgcGVlcnMsIHdoaWNoIHRyYXNoZXMgYnJvd3NlciBiYW5kd2lkdGguIE5vdCByZWxheWluZyB0aGUgYWNrIHdpbGwgZm9yY2Ugc2VuZGVyIHRvIGFzayBmb3IgYWNrIGFnYWluLiBOb3RlLCB0aGlzIGlzIHRlY2huaWNhbGx5IHdyb25nIGZvciBtZXNoIGJlaGF2aW9yLlxuXHRcdFx0XHRcdGlmKCFwZWVyICYmIG1lc2gud2F5KXsgcmV0dXJuIG1lc2gud2F5KG1zZykgfVxuXHRcdFx0XHRcdERCRyAmJiAoREJHLnloID0gK25ldyBEYXRlKTtcblx0XHRcdFx0XHRpZighKHJhdyA9IG1ldGEucmF3KSl7IG1lc2gucmF3KG1zZywgcGVlcik7IHJldHVybiB9XG5cdFx0XHRcdFx0REJHICYmIChEQkcueXIgPSArbmV3IERhdGUpO1xuXHRcdFx0XHRcdGlmKCFwZWVyIHx8ICFwZWVyLmlkKXtcblx0XHRcdFx0XHRcdGlmKCFPYmplY3QucGxhaW4ocGVlciB8fCBvcHQucGVlcnMpKXsgcmV0dXJuIGZhbHNlIH1cblx0XHRcdFx0XHRcdHZhciBTID0gK25ldyBEYXRlO1xuXHRcdFx0XHRcdFx0dmFyIFAgPSBvcHQucHVmZiwgcHMgPSBvcHQucGVlcnMsIHBsID0gT2JqZWN0LmtleXMocGVlciB8fCBvcHQucGVlcnMgfHwge30pOyAvLyBUT0RPOiAua2V5cyggaXMgc2xvd1xuXHRcdFx0XHRcdFx0Y29uc29sZS5TVEFUICYmIGNvbnNvbGUuU1RBVChTLCArbmV3IERhdGUgLSBTLCAncGVlciBrZXlzJyk7XG5cdFx0XHRcdFx0XHQ7KGZ1bmN0aW9uIGdvKCl7XG5cdFx0XHRcdFx0XHRcdHZhciBTID0gK25ldyBEYXRlO1xuXHRcdFx0XHRcdFx0XHQvL1R5cGUub2JqLm1hcChwZWVyIHx8IG9wdC5wZWVycywgZWFjaCk7IC8vIGluIGNhc2UgcGVlciBpcyBhIHBlZXIgbGlzdC5cblx0XHRcdFx0XHRcdFx0bG9vcCA9IDE7IHZhciB3ciA9IG1ldGEucmF3OyBtZXRhLnJhdyA9IHJhdzsgLy8gcXVpY2sgcGVyZiBoYWNrXG5cdFx0XHRcdFx0XHRcdHZhciBpID0gMCwgcDsgd2hpbGUoaSA8IDkgJiYgKHAgPSAocGx8fCcnKVtpKytdKSl7XG5cdFx0XHRcdFx0XHRcdFx0aWYoIShwID0gcHNbcF0pKXsgY29udGludWUgfVxuXHRcdFx0XHRcdFx0XHRcdG1lc2guc2F5KG1zZywgcCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0bWV0YS5yYXcgPSB3cjsgbG9vcCA9IDA7XG5cdFx0XHRcdFx0XHRcdHBsID0gcGwuc2xpY2UoaSk7IC8vIHNsaWNpbmcgYWZ0ZXIgaXMgZmFzdGVyIHRoYW4gc2hpZnRpbmcgZHVyaW5nLlxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLlNUQVQgJiYgY29uc29sZS5TVEFUKFMsICtuZXcgRGF0ZSAtIFMsICdzYXkgbG9vcCcpO1xuXHRcdFx0XHRcdFx0XHRpZighcGwubGVuZ3RoKXsgcmV0dXJuIH1cblx0XHRcdFx0XHRcdFx0cHVmZihnbywgMCk7XG5cdFx0XHRcdFx0XHRcdGFjayAmJiBkdXBfdHJhY2soYWNrKTsgLy8ga2VlcCBmb3IgbGF0ZXJcblx0XHRcdFx0XHRcdH0oKSk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIFRPRE86IFBFUkY6IGNvbnNpZGVyIHNwbGl0dGluZyBmdW5jdGlvbiBoZXJlLCBzbyBzYXkgbG9vcHMgZG8gbGVzcyB3b3JrLlxuXHRcdFx0XHRcdGlmKCFwZWVyLndpcmUgJiYgbWVzaC53aXJlKXsgbWVzaC53aXJlKHBlZXIpIH1cblx0XHRcdFx0XHRpZihpZCA9PT0gcGVlci5sYXN0KXsgcmV0dXJuIH0gcGVlci5sYXN0ID0gaWQ7ICAvLyB3YXMgaXQganVzdCBzZW50P1xuXHRcdFx0XHRcdGlmKHBlZXIgPT09IG1ldGEudmlhKXsgcmV0dXJuIGZhbHNlIH0gLy8gZG9uJ3Qgc2VuZCBiYWNrIHRvIHNlbGYuXG5cdFx0XHRcdFx0aWYoKHRtcCA9IG1ldGEueW8pICYmICh0bXBbcGVlci51cmxdIHx8IHRtcFtwZWVyLnBpZF0gfHwgdG1wW3BlZXIuaWRdKSAvKiYmICFvKi8peyByZXR1cm4gZmFsc2UgfVxuXHRcdFx0XHRcdGNvbnNvbGUuU1RBVCAmJiBjb25zb2xlLlNUQVQoUywgKChEQkd8fG1ldGEpLnlwID0gK25ldyBEYXRlKSAtIChtZXRhLnkgfHwgUyksICdzYXkgcHJlcCcpO1xuXHRcdFx0XHRcdCFsb29wICYmIGFjayAmJiBkdXBfdHJhY2soYWNrKTsgLy8gc3RyZWFtaW5nIGxvbmcgcmVzcG9uc2VzIG5lZWRzIHRvIGtlZXAgYWxpdmUgdGhlIGFjay5cblx0XHRcdFx0XHRpZihwZWVyLmJhdGNoKXtcblx0XHRcdFx0XHRcdHBlZXIudGFpbCA9ICh0bXAgPSBwZWVyLnRhaWwgfHwgMCkgKyByYXcubGVuZ3RoO1xuXHRcdFx0XHRcdFx0aWYocGVlci50YWlsIDw9IG9wdC5wYWNrKXtcblx0XHRcdFx0XHRcdFx0cGVlci5iYXRjaCArPSAodG1wPycsJzonJykrcmF3O1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRmbHVzaChwZWVyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cGVlci5iYXRjaCA9ICdbJzsgLy8gUHJldmVudHMgZG91YmxlIEpTT04hXG5cdFx0XHRcdFx0dmFyIFNUID0gK25ldyBEYXRlO1xuXHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdGNvbnNvbGUuU1RBVCAmJiBjb25zb2xlLlNUQVQoU1QsICtuZXcgRGF0ZSAtIFNULCAnMG1zIFRPJyk7XG5cdFx0XHRcdFx0XHRmbHVzaChwZWVyKTtcblx0XHRcdFx0XHR9LCBvcHQuZ2FwKTsgLy8gVE9ETzogcXVldWluZy9iYXRjaGluZyBtaWdodCBiZSBiYWQgZm9yIGxvdy1sYXRlbmN5IHZpZGVvIGdhbWUgcGVyZm9ybWFuY2UhIEFsbG93IG9wdCBvdXQ/XG5cdFx0XHRcdFx0c2VuZChyYXcsIHBlZXIpO1xuXHRcdFx0XHRcdGNvbnNvbGUuU1RBVCAmJiAoYWNrID09PSBwZWVyLlNJKSAmJiBjb25zb2xlLlNUQVQoUywgK25ldyBEYXRlIC0gcGVlci5TSCwgJ3NheSBhY2snKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtZXNoLnNheS5jID0gbWVzaC5zYXkuZCA9IDA7XG5cdFx0XHRcdC8vIFRPRE86IHRoaXMgY2F1c2VkIGEgb3V0LW9mLW1lbW9yeSBjcmFzaCFcblx0XHRcdFx0bWVzaC5yYXcgPSBmdW5jdGlvbihtc2csIHBlZXIpeyAvLyBUT0RPOiBDbGVhbiB0aGlzIHVwIC8gZGVsZXRlIGl0IC8gbW92ZSBsb2dpYyBvdXQhXG5cdFx0XHRcdFx0aWYoIW1zZyl7IHJldHVybiAnJyB9XG5cdFx0XHRcdFx0dmFyIG1ldGEgPSAobXNnLl8pIHx8IHt9LCBwdXQsIHRtcDtcblx0XHRcdFx0XHRpZih0bXAgPSBtZXRhLnJhdyl7IHJldHVybiB0bXAgfVxuXHRcdFx0XHRcdGlmKCdzdHJpbmcnID09IHR5cGVvZiBtc2cpeyByZXR1cm4gbXNnIH1cblx0XHRcdFx0XHR2YXIgaGFzaCA9IG1zZ1snIyMnXSwgYWNrID0gbXNnWydAJ107XG5cdFx0XHRcdFx0aWYoaGFzaCAmJiBhY2spe1xuXHRcdFx0XHRcdFx0aWYoIW1ldGEudmlhICYmIGR1cF9jaGVjayhhY2sraGFzaCkpeyByZXR1cm4gZmFsc2UgfSAvLyBmb3Igb3VyIG93biBvdXQgbWVzc2FnZXMsIG1lbW9yeSAmIHN0b3JhZ2UgbWF5IGFjayB0aGUgc2FtZSB0aGluZywgc28gZGVkdXAgdGhhdC4gVGhvIGlmIHZpYSBhbm90aGVyIHBlZXIsIHdlIGFscmVhZHkgdHJhY2tlZCBpdCB1cG9uIGhlYXJpbmcsIHNvIHRoaXMgd2lsbCBhbHdheXMgdHJpZ2dlciBmYWxzZSBwb3NpdGl2ZXMsIHNvIGRvbid0IGRvIHRoYXQhXG5cdFx0XHRcdFx0XHRpZigodG1wID0gKGR1cC5zW2Fja118fCcnKS5pdCkgfHwgKCh0bXAgPSBtZXNoLmxhc3QpICYmIGFjayA9PT0gdG1wWycjJ10pKXtcblx0XHRcdFx0XHRcdFx0aWYoaGFzaCA9PT0gdG1wWycjIyddKXsgcmV0dXJuIGZhbHNlIH0gLy8gaWYgYXNrIGhhcyBhIG1hdGNoaW5nIGhhc2gsIGFja2luZyBpcyBvcHRpb25hbC5cblx0XHRcdFx0XHRcdFx0aWYoIXRtcFsnIyMnXSl7IHRtcFsnIyMnXSA9IGhhc2ggfSAvLyBpZiBub25lLCBhZGQgb3VyIGhhc2ggdG8gYXNrIHNvIGFueW9uZSB3ZSByZWxheSB0byBjYW4gZGVkdXAuIC8vIE5PVEU6IE1heSBvbmx5IGNoZWNrIGFnYWluc3QgMXN0IGFjayBjaHVuaywgMm5kKyB3b24ndCBrbm93IGFuZCBzdGlsbCBzdHJlYW0gYmFjayB0byByZWxheWluZyBwZWVycyB3aGljaCBtYXkgdGhlbiBkZWR1cC4gQW55IHdheSB0byBmaXggdGhpcyB3YXN0ZWQgYmFuZHdpZHRoPyBJIGd1ZXNzIGZvcmNlIHJhdGUgbGltaXRpbmcgYnJlYWtpbmcgY2hhbmdlLCB0aGF0IGFza2luZyBwZWVyIGhhcyB0byBhc2sgZm9yIG5leHQgbGV4aWNhbCBjaHVuay5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoIW1zZy5kYW0pe1xuXHRcdFx0XHRcdFx0dmFyIGkgPSAwLCB0byA9IFtdOyB0bXAgPSBvcHQucGVlcnM7XG5cdFx0XHRcdFx0XHRmb3IodmFyIGsgaW4gdG1wKXsgdmFyIHAgPSB0bXBba107IC8vIFRPRE86IE1ha2UgaXQgdXAgcGVlcnMgaW5zdGVhZCFcblx0XHRcdFx0XHRcdFx0dG8ucHVzaChwLnVybCB8fCBwLnBpZCB8fCBwLmlkKTtcblx0XHRcdFx0XHRcdFx0aWYoKytpID4gNil7IGJyZWFrIH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKGkgPiAxKXsgbXNnWyc+PCddID0gdG8uam9pbigpIH0gLy8gVE9ETzogQlVHISBUaGlzIGdldHMgc2V0IHJlZ2FyZGxlc3Mgb2YgcGVlcnMgc2VudCB0byEgRGV0ZWN0P1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihwdXQgPSBtZXRhLiRwdXQpe1xuXHRcdFx0XHRcdFx0dG1wID0ge307IE9iamVjdC5rZXlzKG1zZykuZm9yRWFjaChmdW5jdGlvbihrKXsgdG1wW2tdID0gbXNnW2tdIH0pO1xuXHRcdFx0XHRcdFx0dG1wLnB1dCA9ICc6XSkoWzonO1xuXHRcdFx0XHRcdFx0anNvbih0bXAsIGZ1bmN0aW9uKGVyciwgcmF3KXtcblx0XHRcdFx0XHRcdFx0aWYoZXJyKXsgcmV0dXJuIH0gLy8gVE9ETzogSGFuZGxlISFcblx0XHRcdFx0XHRcdFx0dmFyIFMgPSArbmV3IERhdGU7XG5cdFx0XHRcdFx0XHRcdHRtcCA9IHJhdy5pbmRleE9mKCdcInB1dFwiOlwiOl0pKFs6XCInKTtcblx0XHRcdFx0XHRcdFx0cmVzKHUsIHJhdyA9IHJhdy5zbGljZSgwLCB0bXArNikgKyBwdXQgKyByYXcuc2xpY2UodG1wICsgMTQpKTtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5TVEFUICYmIGNvbnNvbGUuU1RBVChTLCArbmV3IERhdGUgLSBTLCAnc2F5IHNsaWNlJyk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0anNvbihtc2csIHJlcyk7XG5cdFx0XHRcdFx0ZnVuY3Rpb24gcmVzKGVyciwgcmF3KXtcblx0XHRcdFx0XHRcdGlmKGVycil7IHJldHVybiB9IC8vIFRPRE86IEhhbmRsZSEhXG5cdFx0XHRcdFx0XHRtZXRhLnJhdyA9IHJhdzsgLy9pZihtZXRhICYmIChyYXd8fCcnKS5sZW5ndGggPCAoOTk5ICogOTkpKXsgbWV0YS5yYXcgPSByYXcgfSAvLyBITlBFUkY6IElmIHN0cmluZyB0b28gYmlnLCBkb24ndCBrZWVwIGluIG1lbW9yeS5cblx0XHRcdFx0XHRcdG1lc2guc2F5KG1zZywgcGVlcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KCkpO1xuXG5cdFx0XHRmdW5jdGlvbiBmbHVzaChwZWVyKXtcblx0XHRcdFx0dmFyIHRtcCA9IHBlZXIuYmF0Y2gsIHQgPSAnc3RyaW5nJyA9PSB0eXBlb2YgdG1wLCBsO1xuXHRcdFx0XHRpZih0KXsgdG1wICs9ICddJyB9Ly8gVE9ETzogUHJldmVudCBkb3VibGUgSlNPTiFcblx0XHRcdFx0cGVlci5iYXRjaCA9IHBlZXIudGFpbCA9IG51bGw7XG5cdFx0XHRcdGlmKCF0bXApeyByZXR1cm4gfVxuXHRcdFx0XHRpZih0PyAzID4gdG1wLmxlbmd0aCA6ICF0bXAubGVuZ3RoKXsgcmV0dXJuIH0gLy8gVE9ETzogXlxuXHRcdFx0XHRpZighdCl7dHJ5e3RtcCA9ICgxID09PSB0bXAubGVuZ3RoPyB0bXBbMF0gOiBKU09OLnN0cmluZ2lmeSh0bXApKTtcblx0XHRcdFx0fWNhdGNoKGUpe3JldHVybiBvcHQubG9nKCdEQU0gSlNPTiBzdHJpbmdpZnkgZXJyb3InLCBlKX19XG5cdFx0XHRcdGlmKCF0bXApeyByZXR1cm4gfVxuXHRcdFx0XHRzZW5kKHRtcCwgcGVlcik7XG5cdFx0XHR9XG5cdFx0XHQvLyBmb3Igbm93IC0gZmluZCBiZXR0ZXIgcGxhY2UgbGF0ZXIuXG5cdFx0XHRmdW5jdGlvbiBzZW5kKHJhdywgcGVlcil7IHRyeXtcblx0XHRcdFx0dmFyIHdpcmUgPSBwZWVyLndpcmU7XG5cdFx0XHRcdGlmKHBlZXIuc2F5KXtcblx0XHRcdFx0XHRwZWVyLnNheShyYXcpO1xuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0aWYod2lyZS5zZW5kKXtcblx0XHRcdFx0XHR3aXJlLnNlbmQocmF3KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtZXNoLnNheS5kICs9IHJhdy5sZW5ndGh8fDA7ICsrbWVzaC5zYXkuYzsgLy8gU1RBVFMhXG5cdFx0XHR9Y2F0Y2goZSl7XG5cdFx0XHRcdChwZWVyLnF1ZXVlID0gcGVlci5xdWV1ZSB8fCBbXSkucHVzaChyYXcpO1xuXHRcdFx0fX1cblxuXHRcdFx0bWVzaC5oaSA9IGZ1bmN0aW9uKHBlZXIpe1xuXHRcdFx0XHR2YXIgd2lyZSA9IHBlZXIud2lyZSwgdG1wO1xuXHRcdFx0XHRpZighd2lyZSl7IG1lc2gud2lyZSgocGVlci5sZW5ndGggJiYge3VybDogcGVlcn0pIHx8IHBlZXIpOyByZXR1cm4gfVxuXHRcdFx0XHRpZihwZWVyLmlkKXtcblx0XHRcdFx0XHRvcHQucGVlcnNbcGVlci51cmwgfHwgcGVlci5pZF0gPSBwZWVyO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRtcCA9IHBlZXIuaWQgPSBwZWVyLmlkIHx8IFN0cmluZy5yYW5kb20oOSk7XG5cdFx0XHRcdFx0bWVzaC5zYXkoe2RhbTogJz8nLCBwaWQ6IHJvb3Qub3B0LnBpZH0sIG9wdC5wZWVyc1t0bXBdID0gcGVlcik7XG5cdFx0XHRcdFx0ZGVsZXRlIGR1cC5zW3BlZXIubGFzdF07IC8vIElNUE9SVEFOVDogc2VlIGh0dHBzOi8vZ3VuLmVjby9kb2NzL0RBTSNzZWxmXG5cdFx0XHRcdH1cblx0XHRcdFx0cGVlci5tZXQgPSBwZWVyLm1ldCB8fCArKG5ldyBEYXRlKTtcblx0XHRcdFx0aWYoIXdpcmUuaGllZCl7IHJvb3Qub24od2lyZS5oaWVkID0gJ2hpJywgcGVlcikgfVxuXHRcdFx0XHQvLyBAcm9nb3dza2kgSSBuZWVkIHRoaXMgaGVyZSBieSBkZWZhdWx0IGZvciBub3cgdG8gZml4IGdvMWRmaXNoJ3MgYnVnXG5cdFx0XHRcdHRtcCA9IHBlZXIucXVldWU7IHBlZXIucXVldWUgPSBbXTtcblx0XHRcdFx0c2V0VGltZW91dC5lYWNoKHRtcHx8W10sZnVuY3Rpb24obXNnKXtcblx0XHRcdFx0XHRzZW5kKG1zZywgcGVlcik7XG5cdFx0XHRcdH0sMCw5KTtcblx0XHRcdFx0Ly9UeXBlLm9iai5uYXRpdmUgJiYgVHlwZS5vYmoubmF0aXZlKCk7IC8vIGRpcnR5IHBsYWNlIHRvIGNoZWNrIGlmIG90aGVyIEpTIHBvbGx1dGVkLlxuXHRcdFx0fVxuXHRcdFx0bWVzaC5ieWUgPSBmdW5jdGlvbihwZWVyKXtcblx0XHRcdFx0cm9vdC5vbignYnllJywgcGVlcik7XG5cdFx0XHRcdHZhciB0bXAgPSArKG5ldyBEYXRlKTsgdG1wID0gKHRtcCAtIChwZWVyLm1ldHx8dG1wKSk7XG5cdFx0XHRcdG1lc2guYnllLnRpbWUgPSAoKG1lc2guYnllLnRpbWUgfHwgdG1wKSArIHRtcCkgLyAyO1xuXHRcdFx0fVxuXHRcdFx0bWVzaC5oZWFyWychJ10gPSBmdW5jdGlvbihtc2csIHBlZXIpeyBvcHQubG9nKCdFcnJvcjonLCBtc2cuZXJyKSB9XG5cdFx0XHRtZXNoLmhlYXJbJz8nXSA9IGZ1bmN0aW9uKG1zZywgcGVlcil7XG5cdFx0XHRcdGlmKG1zZy5waWQpe1xuXHRcdFx0XHRcdGlmKCFwZWVyLnBpZCl7IHBlZXIucGlkID0gbXNnLnBpZCB9XG5cdFx0XHRcdFx0aWYobXNnWydAJ10peyByZXR1cm4gfVxuXHRcdFx0XHR9XG5cdFx0XHRcdG1lc2guc2F5KHtkYW06ICc/JywgcGlkOiBvcHQucGlkLCAnQCc6IG1zZ1snIyddfSwgcGVlcik7XG5cdFx0XHRcdGRlbGV0ZSBkdXAuc1twZWVyLmxhc3RdOyAvLyBJTVBPUlRBTlQ6IHNlZSBodHRwczovL2d1bi5lY28vZG9jcy9EQU0jc2VsZlxuXHRcdFx0fVxuXG5cdFx0XHRyb290Lm9uKCdjcmVhdGUnLCBmdW5jdGlvbihyb290KXtcblx0XHRcdFx0cm9vdC5vcHQucGlkID0gcm9vdC5vcHQucGlkIHx8IFN0cmluZy5yYW5kb20oOSk7XG5cdFx0XHRcdHRoaXMudG8ubmV4dChyb290KTtcblx0XHRcdFx0cm9vdC5vbignb3V0JywgbWVzaC5zYXkpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHJvb3Qub24oJ2J5ZScsIGZ1bmN0aW9uKHBlZXIsIHRtcCl7XG5cdFx0XHRcdHBlZXIgPSBvcHQucGVlcnNbcGVlci5pZCB8fCBwZWVyXSB8fCBwZWVyO1xuXHRcdFx0XHR0aGlzLnRvLm5leHQocGVlcik7XG5cdFx0XHRcdHBlZXIuYnllPyBwZWVyLmJ5ZSgpIDogKHRtcCA9IHBlZXIud2lyZSkgJiYgdG1wLmNsb3NlICYmIHRtcC5jbG9zZSgpO1xuXHRcdFx0XHRkZWxldGUgb3B0LnBlZXJzW3BlZXIuaWRdO1xuXHRcdFx0XHRwZWVyLndpcmUgPSBudWxsO1xuXHRcdFx0fSk7XG5cblx0XHRcdHZhciBnZXRzID0ge307XG5cdFx0XHRyb290Lm9uKCdieWUnLCBmdW5jdGlvbihwZWVyLCB0bXApeyB0aGlzLnRvLm5leHQocGVlcik7XG5cdFx0XHRcdGlmKHRtcCA9IGNvbnNvbGUuU1RBVCl7IHRtcC5wZWVycyA9ICh0bXAucGVlcnMgfHwgMCkgLSAxOyB9XG5cdFx0XHRcdGlmKCEodG1wID0gcGVlci51cmwpKXsgcmV0dXJuIH0gZ2V0c1t0bXBdID0gdHJ1ZTtcblx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpeyBkZWxldGUgZ2V0c1t0bXBdIH0sb3B0LmxhY2sgfHwgOTAwMCk7XG5cdFx0XHR9KTtcblx0XHRcdHJvb3Qub24oJ2hpJywgZnVuY3Rpb24ocGVlciwgdG1wKXsgdGhpcy50by5uZXh0KHBlZXIpO1xuXHRcdFx0XHRpZih0bXAgPSBjb25zb2xlLlNUQVQpeyB0bXAucGVlcnMgPSAodG1wLnBlZXJzIHx8IDApICsgMSB9XG5cdFx0XHRcdGlmKCEodG1wID0gcGVlci51cmwpIHx8ICFnZXRzW3RtcF0peyByZXR1cm4gfSBkZWxldGUgZ2V0c1t0bXBdO1xuXHRcdFx0XHRpZihvcHQuc3VwZXIpeyByZXR1cm4gfSAvLyB0ZW1wb3JhcnkgKD8pIHVudGlsIHdlIGhhdmUgYmV0dGVyIGZpeC9zb2x1dGlvbj9cblx0XHRcdFx0c2V0VGltZW91dC5lYWNoKE9iamVjdC5rZXlzKHJvb3QubmV4dCksIGZ1bmN0aW9uKHNvdWwpeyB2YXIgbm9kZSA9IHJvb3QubmV4dFtzb3VsXTsgLy8gVE9ETzogLmtleXMoIGlzIHNsb3dcblx0XHRcdFx0XHR0bXAgPSB7fTsgdG1wW3NvdWxdID0gcm9vdC5ncmFwaFtzb3VsXTsgdG1wID0gU3RyaW5nLmhhc2godG1wKTsgLy8gVE9ETzogQlVHISBUaGlzIGlzIGJyb2tlbi5cblx0XHRcdFx0XHRtZXNoLnNheSh7JyMjJzogdG1wLCBnZXQ6IHsnIyc6IHNvdWx9fSwgcGVlcik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiBtZXNoO1xuXHRcdH1cblx0ICB2YXIgZW1wdHkgPSB7fSwgb2sgPSB0cnVlLCB1O1xuXG5cdCAgdHJ5eyBtb2R1bGUuZXhwb3J0cyA9IE1lc2ggfWNhdGNoKGUpe31cblxuXHR9KShVU0UsICcuL21lc2gnKTtcblxuXHQ7VVNFKGZ1bmN0aW9uKG1vZHVsZSl7XG5cdFx0dmFyIEd1biA9IFVTRSgnLi4vaW5kZXgnKTtcblx0XHRHdW4uTWVzaCA9IFVTRSgnLi9tZXNoJyk7XG5cblx0XHQvLyBUT0RPOiByZXN5bmMgdXBvbiByZWNvbm5lY3Qgb25saW5lL29mZmxpbmVcblx0XHQvL3dpbmRvdy5vbm9ubGluZSA9IHdpbmRvdy5vbm9mZmxpbmUgPSBmdW5jdGlvbigpeyBjb25zb2xlLmxvZygnb25saW5lPycsIG5hdmlnYXRvci5vbkxpbmUpIH1cblxuXHRcdEd1bi5vbignb3B0JywgZnVuY3Rpb24ocm9vdCl7XG5cdFx0XHR0aGlzLnRvLm5leHQocm9vdCk7XG5cdFx0XHRpZihyb290Lm9uY2UpeyByZXR1cm4gfVxuXHRcdFx0dmFyIG9wdCA9IHJvb3Qub3B0O1xuXHRcdFx0aWYoZmFsc2UgPT09IG9wdC5XZWJTb2NrZXQpeyByZXR1cm4gfVxuXG5cdFx0XHR2YXIgZW52ID0gR3VuLndpbmRvdyB8fCB7fTtcblx0XHRcdHZhciB3ZWJzb2NrZXQgPSBvcHQuV2ViU29ja2V0IHx8IGVudi5XZWJTb2NrZXQgfHwgZW52LndlYmtpdFdlYlNvY2tldCB8fCBlbnYubW96V2ViU29ja2V0O1xuXHRcdFx0aWYoIXdlYnNvY2tldCl7IHJldHVybiB9XG5cdFx0XHRvcHQuV2ViU29ja2V0ID0gd2Vic29ja2V0O1xuXG5cdFx0XHR2YXIgbWVzaCA9IG9wdC5tZXNoID0gb3B0Lm1lc2ggfHwgR3VuLk1lc2gocm9vdCk7XG5cblx0XHRcdHZhciB3aXJlID0gbWVzaC53aXJlIHx8IG9wdC53aXJlO1xuXHRcdFx0bWVzaC53aXJlID0gb3B0LndpcmUgPSBvcGVuO1xuXHRcdFx0ZnVuY3Rpb24gb3BlbihwZWVyKXsgdHJ5e1xuXHRcdFx0XHRpZighcGVlciB8fCAhcGVlci51cmwpeyByZXR1cm4gd2lyZSAmJiB3aXJlKHBlZXIpIH1cblx0XHRcdFx0dmFyIHVybCA9IHBlZXIudXJsLnJlcGxhY2UoL15odHRwLywgJ3dzJyk7XG5cdFx0XHRcdHZhciB3aXJlID0gcGVlci53aXJlID0gbmV3IG9wdC5XZWJTb2NrZXQodXJsKTtcblx0XHRcdFx0d2lyZS5vbmNsb3NlID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRvcHQubWVzaC5ieWUocGVlcik7XG5cdFx0XHRcdFx0cmVjb25uZWN0KHBlZXIpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHR3aXJlLm9uZXJyb3IgPSBmdW5jdGlvbihlcnJvcil7XG5cdFx0XHRcdFx0cmVjb25uZWN0KHBlZXIpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHR3aXJlLm9ub3BlbiA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0b3B0Lm1lc2guaGkocGVlcik7XG5cdFx0XHRcdH1cblx0XHRcdFx0d2lyZS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpe1xuXHRcdFx0XHRcdGlmKCFtc2cpeyByZXR1cm4gfVxuXHRcdFx0XHRcdG9wdC5tZXNoLmhlYXIobXNnLmRhdGEgfHwgbXNnLCBwZWVyKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIHdpcmU7XG5cdFx0XHR9Y2F0Y2goZSl7fX1cblxuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpeyAhb3B0LnN1cGVyICYmIHJvb3Qub24oJ291dCcsIHtkYW06J2hpJ30pIH0sMSk7IC8vIGl0IGNhbiB0YWtlIGEgd2hpbGUgdG8gb3BlbiBhIHNvY2tldCwgc28gbWF5YmUgbm8gbG9uZ2VyIGxhenkgbG9hZCBmb3IgcGVyZiByZWFzb25zP1xuXG5cdFx0XHR2YXIgd2FpdCA9IDIgKiA5OTk7XG5cdFx0XHRmdW5jdGlvbiByZWNvbm5lY3QocGVlcil7XG5cdFx0XHRcdGNsZWFyVGltZW91dChwZWVyLmRlZmVyKTtcblx0XHRcdFx0aWYoIW9wdC5wZWVyc1twZWVyLnVybF0peyByZXR1cm4gfVxuXHRcdFx0XHRpZihkb2MgJiYgcGVlci5yZXRyeSA8PSAwKXsgcmV0dXJuIH1cblx0XHRcdFx0cGVlci5yZXRyeSA9IChwZWVyLnJldHJ5IHx8IG9wdC5yZXRyeSsxIHx8IDYwKSAtICgoLXBlZXIudHJpZWQgKyAocGVlci50cmllZCA9ICtuZXcgRGF0ZSkgPCB3YWl0KjQpPzE6MCk7XG5cdFx0XHRcdHBlZXIuZGVmZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIHRvKCl7XG5cdFx0XHRcdFx0aWYoZG9jICYmIGRvYy5oaWRkZW4peyByZXR1cm4gc2V0VGltZW91dCh0byx3YWl0KSB9XG5cdFx0XHRcdFx0b3BlbihwZWVyKTtcblx0XHRcdFx0fSwgd2FpdCk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgZG9jID0gKCcnK3UgIT09IHR5cGVvZiBkb2N1bWVudCkgJiYgZG9jdW1lbnQ7XG5cdFx0fSk7XG5cdFx0dmFyIG5vb3AgPSBmdW5jdGlvbigpe30sIHU7XG5cdH0pKFVTRSwgJy4vd2Vic29ja2V0Jyk7XG5cblx0O1VTRShmdW5jdGlvbihtb2R1bGUpe1xuXHRcdGlmKHR5cGVvZiBHdW4gPT09ICd1bmRlZmluZWQnKXsgcmV0dXJuIH1cblxuXHRcdHZhciBub29wID0gZnVuY3Rpb24oKXt9LCBzdG9yZSwgdTtcblx0XHR0cnl7c3RvcmUgPSAoR3VuLndpbmRvd3x8bm9vcCkubG9jYWxTdG9yYWdlfWNhdGNoKGUpe31cblx0XHRpZighc3RvcmUpe1xuXHRcdFx0R3VuLmxvZyhcIldhcm5pbmc6IE5vIGxvY2FsU3RvcmFnZSBleGlzdHMgdG8gcGVyc2lzdCBkYXRhIHRvIVwiKTtcblx0XHRcdHN0b3JlID0ge3NldEl0ZW06IGZ1bmN0aW9uKGssdil7dGhpc1trXT12fSwgcmVtb3ZlSXRlbTogZnVuY3Rpb24oayl7ZGVsZXRlIHRoaXNba119LCBnZXRJdGVtOiBmdW5jdGlvbihrKXtyZXR1cm4gdGhpc1trXX19O1xuXHRcdH1cblxuXHRcdHZhciBwYXJzZSA9IEpTT04ucGFyc2VBc3luYyB8fCBmdW5jdGlvbih0LGNiLHIpeyB2YXIgdTsgdHJ5eyBjYih1LCBKU09OLnBhcnNlKHQscikpIH1jYXRjaChlKXsgY2IoZSkgfSB9XG5cdFx0dmFyIGpzb24gPSBKU09OLnN0cmluZ2lmeUFzeW5jIHx8IGZ1bmN0aW9uKHYsY2IscixzKXsgdmFyIHU7IHRyeXsgY2IodSwgSlNPTi5zdHJpbmdpZnkodixyLHMpKSB9Y2F0Y2goZSl7IGNiKGUpIH0gfVxuXG5cdFx0R3VuLm9uKCdjcmVhdGUnLCBmdW5jdGlvbiBsZyhyb290KXtcblx0XHRcdHRoaXMudG8ubmV4dChyb290KTtcblx0XHRcdHZhciBvcHQgPSByb290Lm9wdCwgZ3JhcGggPSByb290LmdyYXBoLCBhY2tzID0gW10sIGRpc2ssIHRvLCBzaXplLCBzdG9wO1xuXHRcdFx0aWYoZmFsc2UgPT09IG9wdC5sb2NhbFN0b3JhZ2UpeyByZXR1cm4gfVxuXHRcdFx0b3B0LnByZWZpeCA9IG9wdC5maWxlIHx8ICdndW4vJztcblx0XHRcdHRyeXsgZGlzayA9IGxnW29wdC5wcmVmaXhdID0gbGdbb3B0LnByZWZpeF0gfHwgSlNPTi5wYXJzZShzaXplID0gc3RvcmUuZ2V0SXRlbShvcHQucHJlZml4KSkgfHwge307IC8vIFRPRE86IFBlcmYhIFRoaXMgd2lsbCBibG9jaywgc2hvdWxkIHdlIGNhcmUsIHNpbmNlIGxpbWl0ZWQgdG8gNU1CIGFueXdheXM/XG5cdFx0XHR9Y2F0Y2goZSl7IGRpc2sgPSBsZ1tvcHQucHJlZml4XSA9IHt9OyB9XG5cdFx0XHRzaXplID0gKHNpemV8fCcnKS5sZW5ndGg7XG5cblx0XHRcdHJvb3Qub24oJ2dldCcsIGZ1bmN0aW9uKG1zZyl7XG5cdFx0XHRcdHRoaXMudG8ubmV4dChtc2cpO1xuXHRcdFx0XHR2YXIgbGV4ID0gbXNnLmdldCwgc291bCwgZGF0YSwgdG1wLCB1O1xuXHRcdFx0XHRpZighbGV4IHx8ICEoc291bCA9IGxleFsnIyddKSl7IHJldHVybiB9XG5cdFx0XHRcdGRhdGEgPSBkaXNrW3NvdWxdIHx8IHU7XG5cdFx0XHRcdGlmKGRhdGEgJiYgKHRtcCA9IGxleFsnLiddKSAmJiAhT2JqZWN0LnBsYWluKHRtcCkpeyAvLyBwbHVjayFcblx0XHRcdFx0XHRkYXRhID0gR3VuLnN0YXRlLmlmeSh7fSwgdG1wLCBHdW4uc3RhdGUuaXMoZGF0YSwgdG1wKSwgZGF0YVt0bXBdLCBzb3VsKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL2lmKGRhdGEpeyAodG1wID0ge30pW3NvdWxdID0gZGF0YSB9IC8vIGJhY2sgaW50byBhIGdyYXBoLlxuXHRcdFx0XHQvL3NldFRpbWVvdXQoZnVuY3Rpb24oKXtcblx0XHRcdFx0R3VuLm9uLmdldC5hY2sobXNnLCBkYXRhKTsgLy9yb290Lm9uKCdpbicsIHsnQCc6IG1zZ1snIyddLCBwdXQ6IHRtcCwgbFM6MX0pOy8vIHx8IHJvb3QuJH0pO1xuXHRcdFx0XHQvL30sIE1hdGgucmFuZG9tKCkgKiAxMCk7IC8vIEZPUiBURVNUSU5HIFBVUlBPU0VTIVxuXHRcdFx0fSk7XG5cblx0XHRcdHJvb3Qub24oJ3B1dCcsIGZ1bmN0aW9uKG1zZyl7XG5cdFx0XHRcdHRoaXMudG8ubmV4dChtc2cpOyAvLyByZW1lbWJlciB0byBjYWxsIG5leHQgbWlkZGxld2FyZSBhZGFwdGVyXG5cdFx0XHRcdHZhciBwdXQgPSBtc2cucHV0LCBzb3VsID0gcHV0WycjJ10sIGtleSA9IHB1dFsnLiddLCBpZCA9IG1zZ1snIyddLCB0bXA7IC8vIHB1bGwgZGF0YSBvZmYgd2lyZSBlbnZlbG9wZVxuXHRcdFx0XHRkaXNrW3NvdWxdID0gR3VuLnN0YXRlLmlmeShkaXNrW3NvdWxdLCBrZXksIHB1dFsnPiddLCBwdXRbJzonXSwgc291bCk7IC8vIG1lcmdlIGludG8gZGlzayBvYmplY3Rcblx0XHRcdFx0aWYoc3RvcCAmJiBzaXplID4gKDQ5OTk4ODApKXsgcm9vdC5vbignaW4nLCB7J0AnOiBpZCwgZXJyOiBcImxvY2FsU3RvcmFnZSBtYXghXCJ9KTsgcmV0dXJuOyB9XG5cdFx0XHRcdGlmKCFtc2dbJ0AnXSl7IGFja3MucHVzaChpZCkgfSAvLyB0aGVuIGFjayBhbnkgbm9uLWFjayB3cml0ZS4gLy8gVE9ETzogdXNlIGJhdGNoIGlkLlxuXHRcdFx0XHRpZih0byl7IHJldHVybiB9XG5cdFx0XHRcdHRvID0gc2V0VGltZW91dChmbHVzaCwgOSsoc2l6ZSAvIDMzMykpOyAvLyAwLjFNQiA9IDAuM3MsIDVNQiA9IDE1cyBcblx0XHRcdH0pO1xuXHRcdFx0ZnVuY3Rpb24gZmx1c2goKXtcblx0XHRcdFx0aWYoIWFja3MubGVuZ3RoICYmICgoc2V0VGltZW91dC50dXJufHwnJykuc3x8JycpLmxlbmd0aCl7IHNldFRpbWVvdXQoZmx1c2gsOTkpOyByZXR1cm47IH0gLy8gZGVmZXIgaWYgXCJidXN5XCIgJiYgbm8gc2F2ZXMuXG5cdFx0XHRcdHZhciBlcnIsIGFjayA9IGFja3M7IGNsZWFyVGltZW91dCh0byk7IHRvID0gZmFsc2U7IGFja3MgPSBbXTtcblx0XHRcdFx0anNvbihkaXNrLCBmdW5jdGlvbihlcnIsIHRtcCl7XG5cdFx0XHRcdFx0dHJ5eyFlcnIgJiYgc3RvcmUuc2V0SXRlbShvcHQucHJlZml4LCB0bXApO1xuXHRcdFx0XHRcdH1jYXRjaChlKXsgZXJyID0gc3RvcCA9IGUgfHwgXCJsb2NhbFN0b3JhZ2UgZmFpbHVyZVwiIH1cblx0XHRcdFx0XHRpZihlcnIpe1xuXHRcdFx0XHRcdFx0R3VuLmxvZyhlcnIgKyBcIiBDb25zaWRlciB1c2luZyBHVU4ncyBJbmRleGVkREIgcGx1Z2luIGZvciBSQUQgZm9yIG1vcmUgc3RvcmFnZSBzcGFjZSwgaHR0cHM6Ly9ndW4uZWNvL2RvY3MvUkFEI2luc3RhbGxcIik7XG5cdFx0XHRcdFx0XHRyb290Lm9uKCdsb2NhbFN0b3JhZ2U6ZXJyb3InLCB7ZXJyOiBlcnIsIGdldDogb3B0LnByZWZpeCwgcHV0OiBkaXNrfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNpemUgPSB0bXAubGVuZ3RoO1xuXG5cdFx0XHRcdFx0aWYoIWVyciAmJiAhT2JqZWN0LmVtcHR5KG9wdC5wZWVycykpeyByZXR1cm4gfSAvLyBvbmx5IGFjayBpZiB0aGVyZSBhcmUgbm8gcGVlcnMuIC8vIFN3aXRjaCB0aGlzIHRvIHByb2JhYmlsaXN0aWMgbW9kZVxuXHRcdFx0XHRcdHNldFRpbWVvdXQuZWFjaChhY2ssIGZ1bmN0aW9uKGlkKXtcblx0XHRcdFx0XHRcdHJvb3Qub24oJ2luJywgeydAJzogaWQsIGVycjogZXJyLCBvazogMH0pOyAvLyBsb2NhbFN0b3JhZ2UgaXNuJ3QgcmVsaWFibGUsIHNvIG1ha2UgaXRzIGBva2AgY29kZSBiZSBhIGxvdyBudW1iZXIuXG5cdFx0XHRcdFx0fSwwLDk5KTtcblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHRcblx0XHR9KTtcblx0fSkoVVNFLCAnLi9sb2NhbFN0b3JhZ2UnKTtcblxufSgpKTtcblxuLyogQkVMT1cgSVMgVEVNUE9SQVJZIEZPUiBPTEQgSU5URVJOQUwgQ09NUEFUSUJJTElUWSwgVEhFWSBBUkUgSU1NRURJQVRFTFkgREVQUkVDQVRFRCBBTkQgV0lMTCBCRSBSRU1PVkVEIElOIE5FWFQgVkVSU0lPTiAqL1xuOyhmdW5jdGlvbigpe1xuXHR2YXIgdTtcblx0aWYoJycrdSA9PSB0eXBlb2YgR3VuKXsgcmV0dXJuIH1cblx0dmFyIERFUCA9IGZ1bmN0aW9uKG4peyBjb25zb2xlLndhcm4oXCJXYXJuaW5nISBEZXByZWNhdGVkIGludGVybmFsIHV0aWxpdHkgd2lsbCBicmVhayBpbiBuZXh0IHZlcnNpb246XCIsIG4pIH1cblx0Ly8gR2VuZXJpYyBqYXZhc2NyaXB0IHV0aWxpdGllcy5cblx0dmFyIFR5cGUgPSBHdW47XG5cdC8vVHlwZS5mbnMgPSBUeXBlLmZuID0ge2lzOiBmdW5jdGlvbihmbil7IHJldHVybiAoISFmbiAmJiBmbiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB9fVxuXHRUeXBlLmZuID0gVHlwZS5mbiB8fCB7aXM6IGZ1bmN0aW9uKGZuKXsgREVQKCdmbicpOyByZXR1cm4gKCEhZm4gJiYgJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZm4pIH19XG5cdFR5cGUuYmkgPSBUeXBlLmJpIHx8IHtpczogZnVuY3Rpb24oYil7IERFUCgnYmknKTtyZXR1cm4gKGIgaW5zdGFuY2VvZiBCb29sZWFuIHx8IHR5cGVvZiBiID09ICdib29sZWFuJykgfX1cblx0VHlwZS5udW0gPSBUeXBlLm51bSB8fCB7aXM6IGZ1bmN0aW9uKG4peyBERVAoJ251bScpOyByZXR1cm4gIWxpc3RfaXMobikgJiYgKChuIC0gcGFyc2VGbG9hdChuKSArIDEpID49IDAgfHwgSW5maW5pdHkgPT09IG4gfHwgLUluZmluaXR5ID09PSBuKSB9fVxuXHRUeXBlLnRleHQgPSBUeXBlLnRleHQgfHwge2lzOiBmdW5jdGlvbih0KXsgREVQKCd0ZXh0Jyk7IHJldHVybiAodHlwZW9mIHQgPT0gJ3N0cmluZycpIH19XG5cdFR5cGUudGV4dC5pZnkgPSBUeXBlLnRleHQuaWZ5IHx8IGZ1bmN0aW9uKHQpeyBERVAoJ3RleHQuaWZ5Jyk7XG5cdFx0aWYoVHlwZS50ZXh0LmlzKHQpKXsgcmV0dXJuIHQgfVxuXHRcdGlmKHR5cGVvZiBKU09OICE9PSBcInVuZGVmaW5lZFwiKXsgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHQpIH1cblx0XHRyZXR1cm4gKHQgJiYgdC50b1N0cmluZyk/IHQudG9TdHJpbmcoKSA6IHQ7XG5cdH1cblx0VHlwZS50ZXh0LnJhbmRvbSA9IFR5cGUudGV4dC5yYW5kb20gfHwgZnVuY3Rpb24obCwgYyl7IERFUCgndGV4dC5yYW5kb20nKTtcblx0XHR2YXIgcyA9ICcnO1xuXHRcdGwgPSBsIHx8IDI0OyAvLyB5b3UgYXJlIG5vdCBnb2luZyB0byBtYWtlIGEgMCBsZW5ndGggcmFuZG9tIG51bWJlciwgc28gbm8gbmVlZCB0byBjaGVjayB0eXBlXG5cdFx0YyA9IGMgfHwgJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1haYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonO1xuXHRcdHdoaWxlKGwgPiAwKXsgcyArPSBjLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjLmxlbmd0aCkpOyBsLS0gfVxuXHRcdHJldHVybiBzO1xuXHR9XG5cdFR5cGUudGV4dC5tYXRjaCA9IFR5cGUudGV4dC5tYXRjaCB8fCBmdW5jdGlvbih0LCBvKXsgdmFyIHRtcCwgdTsgREVQKCd0ZXh0Lm1hdGNoJyk7XG5cdFx0aWYoJ3N0cmluZycgIT09IHR5cGVvZiB0KXsgcmV0dXJuIGZhbHNlIH1cblx0XHRpZignc3RyaW5nJyA9PSB0eXBlb2Ygbyl7IG8gPSB7Jz0nOiBvfSB9XG5cdFx0byA9IG8gfHwge307XG5cdFx0dG1wID0gKG9bJz0nXSB8fCBvWycqJ10gfHwgb1snPiddIHx8IG9bJzwnXSk7XG5cdFx0aWYodCA9PT0gdG1wKXsgcmV0dXJuIHRydWUgfVxuXHRcdGlmKHUgIT09IG9bJz0nXSl7IHJldHVybiBmYWxzZSB9XG5cdFx0dG1wID0gKG9bJyonXSB8fCBvWyc+J10gfHwgb1snPCddKTtcblx0XHRpZih0LnNsaWNlKDAsICh0bXB8fCcnKS5sZW5ndGgpID09PSB0bXApeyByZXR1cm4gdHJ1ZSB9XG5cdFx0aWYodSAhPT0gb1snKiddKXsgcmV0dXJuIGZhbHNlIH1cblx0XHRpZih1ICE9PSBvWyc+J10gJiYgdSAhPT0gb1snPCddKXtcblx0XHRcdHJldHVybiAodCA+PSBvWyc+J10gJiYgdCA8PSBvWyc8J10pPyB0cnVlIDogZmFsc2U7XG5cdFx0fVxuXHRcdGlmKHUgIT09IG9bJz4nXSAmJiB0ID49IG9bJz4nXSl7IHJldHVybiB0cnVlIH1cblx0XHRpZih1ICE9PSBvWyc8J10gJiYgdCA8PSBvWyc8J10peyByZXR1cm4gdHJ1ZSB9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdFR5cGUudGV4dC5oYXNoID0gVHlwZS50ZXh0Lmhhc2ggfHwgZnVuY3Rpb24ocywgYyl7IC8vIHZpYSBTT1xuXHRcdERFUCgndGV4dC5oYXNoJyk7XG5cdFx0aWYodHlwZW9mIHMgIT09ICdzdHJpbmcnKXsgcmV0dXJuIH1cblx0ICBjID0gYyB8fCAwO1xuXHQgIGlmKCFzLmxlbmd0aCl7IHJldHVybiBjIH1cblx0ICBmb3IodmFyIGk9MCxsPXMubGVuZ3RoLG47IGk8bDsgKytpKXtcblx0ICAgIG4gPSBzLmNoYXJDb2RlQXQoaSk7XG5cdCAgICBjID0gKChjPDw1KS1jKStuO1xuXHQgICAgYyB8PSAwO1xuXHQgIH1cblx0ICByZXR1cm4gYztcblx0fVxuXHRUeXBlLmxpc3QgPSBUeXBlLmxpc3QgfHwge2lzOiBmdW5jdGlvbihsKXsgREVQKCdsaXN0Jyk7IHJldHVybiAobCBpbnN0YW5jZW9mIEFycmF5KSB9fVxuXHRUeXBlLmxpc3Quc2xpdCA9IFR5cGUubGlzdC5zbGl0IHx8IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblx0VHlwZS5saXN0LnNvcnQgPSBUeXBlLmxpc3Quc29ydCB8fCBmdW5jdGlvbihrKXsgLy8gY3JlYXRlcyBhIG5ldyBzb3J0IGZ1bmN0aW9uIGJhc2VkIG9mZiBzb21lIGtleVxuXHRcdERFUCgnbGlzdC5zb3J0Jyk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKEEsQil7XG5cdFx0XHRpZighQSB8fCAhQil7IHJldHVybiAwIH0gQSA9IEFba107IEIgPSBCW2tdO1xuXHRcdFx0aWYoQSA8IEIpeyByZXR1cm4gLTEgfWVsc2UgaWYoQSA+IEIpeyByZXR1cm4gMSB9XG5cdFx0XHRlbHNlIHsgcmV0dXJuIDAgfVxuXHRcdH1cblx0fVxuXHRUeXBlLmxpc3QubWFwID0gVHlwZS5saXN0Lm1hcCB8fCBmdW5jdGlvbihsLCBjLCBfKXsgREVQKCdsaXN0Lm1hcCcpOyByZXR1cm4gb2JqX21hcChsLCBjLCBfKSB9XG5cdFR5cGUubGlzdC5pbmRleCA9IDE7IC8vIGNoYW5nZSB0aGlzIHRvIDAgaWYgeW91IHdhbnQgbm9uLWxvZ2ljYWwsIG5vbi1tYXRoZW1hdGljYWwsIG5vbi1tYXRyaXgsIG5vbi1jb252ZW5pZW50IGFycmF5IG5vdGF0aW9uXG5cdFR5cGUub2JqID0gVHlwZS5ib2ogfHwge2lzOiBmdW5jdGlvbihvKXsgREVQKCdvYmonKTsgcmV0dXJuIG8/IChvIGluc3RhbmNlb2YgT2JqZWN0ICYmIG8uY29uc3RydWN0b3IgPT09IE9iamVjdCkgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLm1hdGNoKC9eXFxbb2JqZWN0IChcXHcrKVxcXSQvKVsxXSA9PT0gJ09iamVjdCcgOiBmYWxzZSB9fVxuXHRUeXBlLm9iai5wdXQgPSBUeXBlLm9iai5wdXQgfHwgZnVuY3Rpb24obywgaywgdil7IERFUCgnb2JqLnB1dCcpOyByZXR1cm4gKG98fHt9KVtrXSA9IHYsIG8gfVxuXHRUeXBlLm9iai5oYXMgPSBUeXBlLm9iai5oYXMgfHwgZnVuY3Rpb24obywgayl7IERFUCgnb2JqLmhhcycpOyByZXR1cm4gbyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykgfVxuXHRUeXBlLm9iai5kZWwgPSBUeXBlLm9iai5kZWwgfHwgZnVuY3Rpb24obywgayl7IERFUCgnb2JqLmRlbCcpOyBcblx0XHRpZighbyl7IHJldHVybiB9XG5cdFx0b1trXSA9IG51bGw7XG5cdFx0ZGVsZXRlIG9ba107XG5cdFx0cmV0dXJuIG87XG5cdH1cblx0VHlwZS5vYmouYXMgPSBUeXBlLm9iai5hcyB8fCBmdW5jdGlvbihvLCBrLCB2LCB1KXsgREVQKCdvYmouYXMnKTsgcmV0dXJuIG9ba10gPSBvW2tdIHx8ICh1ID09PSB2PyB7fSA6IHYpIH1cblx0VHlwZS5vYmouaWZ5ID0gVHlwZS5vYmouaWZ5IHx8IGZ1bmN0aW9uKG8peyBERVAoJ29iai5pZnknKTsgXG5cdFx0aWYob2JqX2lzKG8pKXsgcmV0dXJuIG8gfVxuXHRcdHRyeXtvID0gSlNPTi5wYXJzZShvKTtcblx0XHR9Y2F0Y2goZSl7bz17fX07XG5cdFx0cmV0dXJuIG87XG5cdH1cblx0OyhmdW5jdGlvbigpeyB2YXIgdTtcblx0XHRmdW5jdGlvbiBtYXAodixrKXtcblx0XHRcdGlmKG9ial9oYXModGhpcyxrKSAmJiB1ICE9PSB0aGlzW2tdKXsgcmV0dXJuIH1cblx0XHRcdHRoaXNba10gPSB2O1xuXHRcdH1cblx0XHRUeXBlLm9iai50byA9IFR5cGUub2JqLnRvIHx8IGZ1bmN0aW9uKGZyb20sIHRvKXsgREVQKCdvYmoudG8nKTsgXG5cdFx0XHR0byA9IHRvIHx8IHt9O1xuXHRcdFx0b2JqX21hcChmcm9tLCBtYXAsIHRvKTtcblx0XHRcdHJldHVybiB0bztcblx0XHR9XG5cdH0oKSk7XG5cdFR5cGUub2JqLmNvcHkgPSBUeXBlLm9iai5jb3B5IHx8IGZ1bmN0aW9uKG8peyBERVAoJ29iai5jb3B5Jyk7IC8vIGJlY2F1c2UgaHR0cDovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNDAzMjgyMjQwMjUvaHR0cDovL2pzcGVyZi5jb20vY2xvbmluZy1hbi1vYmplY3QvMlxuXHRcdHJldHVybiAhbz8gbyA6IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobykpOyAvLyBpcyBzaG9ja2luZ2x5IGZhc3RlciB0aGFuIGFueXRoaW5nIGVsc2UsIGFuZCBvdXIgZGF0YSBoYXMgdG8gYmUgYSBzdWJzZXQgb2YgSlNPTiBhbnl3YXlzIVxuXHR9XG5cdDsoZnVuY3Rpb24oKXtcblx0XHRmdW5jdGlvbiBlbXB0eSh2LGkpeyB2YXIgbiA9IHRoaXMubiwgdTtcblx0XHRcdGlmKG4gJiYgKGkgPT09IG4gfHwgKG9ial9pcyhuKSAmJiBvYmpfaGFzKG4sIGkpKSkpeyByZXR1cm4gfVxuXHRcdFx0aWYodSAhPT0gaSl7IHJldHVybiB0cnVlIH1cblx0XHR9XG5cdFx0VHlwZS5vYmouZW1wdHkgPSBUeXBlLm9iai5lbXB0eSB8fCBmdW5jdGlvbihvLCBuKXsgREVQKCdvYmouZW1wdHknKTsgXG5cdFx0XHRpZighbyl7IHJldHVybiB0cnVlIH1cblx0XHRcdHJldHVybiBvYmpfbWFwKG8sZW1wdHkse246bn0pPyBmYWxzZSA6IHRydWU7XG5cdFx0fVxuXHR9KCkpO1xuXHQ7KGZ1bmN0aW9uKCl7XG5cdFx0ZnVuY3Rpb24gdChrLHYpe1xuXHRcdFx0aWYoMiA9PT0gYXJndW1lbnRzLmxlbmd0aCl7XG5cdFx0XHRcdHQuciA9IHQuciB8fCB7fTtcblx0XHRcdFx0dC5yW2tdID0gdjtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSB0LnIgPSB0LnIgfHwgW107XG5cdFx0XHR0LnIucHVzaChrKTtcblx0XHR9O1xuXHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMsIG1hcCwgdTtcblx0XHRPYmplY3Qua2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uKG8peyByZXR1cm4gbWFwKG8sIGZ1bmN0aW9uKHYsayx0KXt0KGspfSkgfVxuXHRcdFR5cGUub2JqLm1hcCA9IG1hcCA9IFR5cGUub2JqLm1hcCB8fCBmdW5jdGlvbihsLCBjLCBfKXsgREVQKCdvYmoubWFwJyk7IFxuXHRcdFx0dmFyIHUsIGkgPSAwLCB4LCByLCBsbCwgbGxlLCBmID0gJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgYztcblx0XHRcdHQuciA9IHU7XG5cdFx0XHRpZihrZXlzICYmIG9ial9pcyhsKSl7XG5cdFx0XHRcdGxsID0ga2V5cyhsKTsgbGxlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdF8gPSBfIHx8IHt9O1xuXHRcdFx0aWYobGlzdF9pcyhsKSB8fCBsbCl7XG5cdFx0XHRcdHggPSAobGwgfHwgbCkubGVuZ3RoO1xuXHRcdFx0XHRmb3IoO2kgPCB4OyBpKyspe1xuXHRcdFx0XHRcdHZhciBpaSA9IChpICsgVHlwZS5saXN0LmluZGV4KTtcblx0XHRcdFx0XHRpZihmKXtcblx0XHRcdFx0XHRcdHIgPSBsbGU/IGMuY2FsbChfLCBsW2xsW2ldXSwgbGxbaV0sIHQpIDogYy5jYWxsKF8sIGxbaV0sIGlpLCB0KTtcblx0XHRcdFx0XHRcdGlmKHIgIT09IHUpeyByZXR1cm4gciB9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vaWYoVHlwZS50ZXN0LmlzKGMsbFtpXSkpeyByZXR1cm4gaWkgfSAvLyBzaG91bGQgaW1wbGVtZW50IGRlZXAgZXF1YWxpdHkgdGVzdGluZyFcblx0XHRcdFx0XHRcdGlmKGMgPT09IGxbbGxlPyBsbFtpXSA6IGldKXsgcmV0dXJuIGxsPyBsbFtpXSA6IGlpIH0gLy8gdXNlIHRoaXMgZm9yIG5vd1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yKGkgaW4gbCl7XG5cdFx0XHRcdFx0aWYoZil7XG5cdFx0XHRcdFx0XHRpZihvYmpfaGFzKGwsaSkpe1xuXHRcdFx0XHRcdFx0XHRyID0gXz8gYy5jYWxsKF8sIGxbaV0sIGksIHQpIDogYyhsW2ldLCBpLCB0KTtcblx0XHRcdFx0XHRcdFx0aWYociAhPT0gdSl7IHJldHVybiByIH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly9pZihhLnRlc3QuaXMoYyxsW2ldKSl7IHJldHVybiBpIH0gLy8gc2hvdWxkIGltcGxlbWVudCBkZWVwIGVxdWFsaXR5IHRlc3RpbmchXG5cdFx0XHRcdFx0XHRpZihjID09PSBsW2ldKXsgcmV0dXJuIGkgfSAvLyB1c2UgdGhpcyBmb3Igbm93XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZj8gdC5yIDogVHlwZS5saXN0LmluZGV4PyAwIDogLTE7XG5cdFx0fVxuXHR9KCkpO1xuXHRUeXBlLnRpbWUgPSBUeXBlLnRpbWUgfHwge307XG5cdFR5cGUudGltZS5pcyA9IFR5cGUudGltZS5pcyB8fCBmdW5jdGlvbih0KXsgREVQKCd0aW1lJyk7IHJldHVybiB0PyB0IGluc3RhbmNlb2YgRGF0ZSA6ICgrbmV3IERhdGUoKS5nZXRUaW1lKCkpIH1cblxuXHR2YXIgZm5faXMgPSBUeXBlLmZuLmlzO1xuXHR2YXIgbGlzdF9pcyA9IFR5cGUubGlzdC5pcztcblx0dmFyIG9iaiA9IFR5cGUub2JqLCBvYmpfaXMgPSBvYmouaXMsIG9ial9oYXMgPSBvYmouaGFzLCBvYmpfbWFwID0gb2JqLm1hcDtcblxuXHR2YXIgVmFsID0ge307XG5cdFZhbC5pcyA9IGZ1bmN0aW9uKHYpeyBERVAoJ3ZhbC5pcycpOyAvLyBWYWxpZCB2YWx1ZXMgYXJlIGEgc3Vic2V0IG9mIEpTT046IG51bGwsIGJpbmFyeSwgbnVtYmVyICghSW5maW5pdHkpLCB0ZXh0LCBvciBhIHNvdWwgcmVsYXRpb24uIEFycmF5cyBuZWVkIHNwZWNpYWwgYWxnb3JpdGhtcyB0byBoYW5kbGUgY29uY3VycmVuY3ksIHNvIHRoZXkgYXJlIG5vdCBzdXBwb3J0ZWQgZGlyZWN0bHkuIFVzZSBhbiBleHRlbnNpb24gdGhhdCBzdXBwb3J0cyB0aGVtIGlmIG5lZWRlZCBidXQgcmVzZWFyY2ggdGhlaXIgcHJvYmxlbXMgZmlyc3QuXG5cdFx0aWYodiA9PT0gdSl7IHJldHVybiBmYWxzZSB9XG5cdFx0aWYodiA9PT0gbnVsbCl7IHJldHVybiB0cnVlIH0gLy8gXCJkZWxldGVzXCIsIG51bGxpbmcgb3V0IGtleXMuXG5cdFx0aWYodiA9PT0gSW5maW5pdHkpeyByZXR1cm4gZmFsc2UgfSAvLyB3ZSB3YW50IHRoaXMgdG8gYmUsIGJ1dCBKU09OIGRvZXMgbm90IHN1cHBvcnQgaXQsIHNhZCBmYWNlLlxuXHRcdGlmKHRleHRfaXModikgLy8gYnkgXCJ0ZXh0XCIgd2UgbWVhbiBzdHJpbmdzLlxuXHRcdHx8IGJpX2lzKHYpIC8vIGJ5IFwiYmluYXJ5XCIgd2UgbWVhbiBib29sZWFuLlxuXHRcdHx8IG51bV9pcyh2KSl7IC8vIGJ5IFwibnVtYmVyXCIgd2UgbWVhbiBpbnRlZ2VycyBvciBkZWNpbWFscy5cblx0XHRcdHJldHVybiB0cnVlOyAvLyBzaW1wbGUgdmFsdWVzIGFyZSB2YWxpZC5cblx0XHR9XG5cdFx0cmV0dXJuIFZhbC5saW5rLmlzKHYpIHx8IGZhbHNlOyAvLyBpcyB0aGUgdmFsdWUgYSBzb3VsIHJlbGF0aW9uPyBUaGVuIGl0IGlzIHZhbGlkIGFuZCByZXR1cm4gaXQuIElmIG5vdCwgZXZlcnl0aGluZyBlbHNlIHJlbWFpbmluZyBpcyBhbiBpbnZhbGlkIGRhdGEgdHlwZS4gQ3VzdG9tIGV4dGVuc2lvbnMgY2FuIGJlIGJ1aWx0IG9uIHRvcCBvZiB0aGVzZSBwcmltaXRpdmVzIHRvIHN1cHBvcnQgb3RoZXIgdHlwZXMuXG5cdH1cblx0VmFsLmxpbmsgPSBWYWwucmVsID0ge186ICcjJ307XG5cdDsoZnVuY3Rpb24oKXtcblx0XHRWYWwubGluay5pcyA9IGZ1bmN0aW9uKHYpeyBERVAoJ3ZhbC5saW5rLmlzJyk7IC8vIHRoaXMgZGVmaW5lcyB3aGV0aGVyIGFuIG9iamVjdCBpcyBhIHNvdWwgcmVsYXRpb24gb3Igbm90LCB0aGV5IGxvb2sgbGlrZSB0aGlzOiB7JyMnOiAnVVVJRCd9XG5cdFx0XHRpZih2ICYmIHZbcmVsX10gJiYgIXYuXyAmJiBvYmpfaXModikpeyAvLyBtdXN0IGJlIGFuIG9iamVjdC5cblx0XHRcdFx0dmFyIG8gPSB7fTtcblx0XHRcdFx0b2JqX21hcCh2LCBtYXAsIG8pO1xuXHRcdFx0XHRpZihvLmlkKXsgLy8gYSB2YWxpZCBpZCB3YXMgZm91bmQuXG5cdFx0XHRcdFx0cmV0dXJuIG8uaWQ7IC8vIHlheSEgUmV0dXJuIGl0LlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7IC8vIHRoZSB2YWx1ZSB3YXMgbm90IGEgdmFsaWQgc291bCByZWxhdGlvbi5cblx0XHR9XG5cdFx0ZnVuY3Rpb24gbWFwKHMsIGspeyB2YXIgbyA9IHRoaXM7IC8vIG1hcCBvdmVyIHRoZSBvYmplY3QuLi5cblx0XHRcdGlmKG8uaWQpeyByZXR1cm4gby5pZCA9IGZhbHNlIH0gLy8gaWYgSUQgaXMgYWxyZWFkeSBkZWZpbmVkIEFORCB3ZSdyZSBzdGlsbCBsb29waW5nIHRocm91Z2ggdGhlIG9iamVjdCwgaXQgaXMgY29uc2lkZXJlZCBpbnZhbGlkLlxuXHRcdFx0aWYoayA9PSByZWxfICYmIHRleHRfaXMocykpeyAvLyB0aGUga2V5IHNob3VsZCBiZSAnIycgYW5kIGhhdmUgYSB0ZXh0IHZhbHVlLlxuXHRcdFx0XHRvLmlkID0gczsgLy8gd2UgZm91bmQgdGhlIHNvdWwhXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gby5pZCA9IGZhbHNlOyAvLyBpZiB0aGVyZSBleGlzdHMgYW55dGhpbmcgZWxzZSBvbiB0aGUgb2JqZWN0IHRoYXQgaXNuJ3QgdGhlIHNvdWwsIHRoZW4gaXQgaXMgY29uc2lkZXJlZCBpbnZhbGlkLlxuXHRcdFx0fVxuXHRcdH1cblx0fSgpKTtcblx0VmFsLmxpbmsuaWZ5ID0gZnVuY3Rpb24odCl7IERFUCgndmFsLmxpbmsuaWZ5Jyk7IHJldHVybiBvYmpfcHV0KHt9LCByZWxfLCB0KSB9IC8vIGNvbnZlcnQgYSBzb3VsIGludG8gYSByZWxhdGlvbiBhbmQgcmV0dXJuIGl0LlxuXHRUeXBlLm9iai5oYXMuXyA9ICcuJztcblx0dmFyIHJlbF8gPSBWYWwubGluay5fLCB1O1xuXHR2YXIgYmlfaXMgPSBUeXBlLmJpLmlzO1xuXHR2YXIgbnVtX2lzID0gVHlwZS5udW0uaXM7XG5cdHZhciB0ZXh0X2lzID0gVHlwZS50ZXh0LmlzO1xuXHR2YXIgb2JqID0gVHlwZS5vYmosIG9ial9pcyA9IG9iai5pcywgb2JqX3B1dCA9IG9iai5wdXQsIG9ial9tYXAgPSBvYmoubWFwO1xuXG5cdFR5cGUudmFsID0gVHlwZS52YWwgfHwgVmFsO1xuXG5cdHZhciBOb2RlID0ge186ICdfJ307XG5cdE5vZGUuc291bCA9IGZ1bmN0aW9uKG4sIG8peyBERVAoJ25vZGUuc291bCcpOyByZXR1cm4gKG4gJiYgbi5fICYmIG4uX1tvIHx8IHNvdWxfXSkgfSAvLyBjb252ZW5pZW5jZSBmdW5jdGlvbiB0byBjaGVjayB0byBzZWUgaWYgdGhlcmUgaXMgYSBzb3VsIG9uIGEgbm9kZSBhbmQgcmV0dXJuIGl0LlxuXHROb2RlLnNvdWwuaWZ5ID0gZnVuY3Rpb24obiwgbyl7IERFUCgnbm9kZS5zb3VsLmlmeScpOyAvLyBwdXQgYSBzb3VsIG9uIGFuIG9iamVjdC5cblx0XHRvID0gKHR5cGVvZiBvID09PSAnc3RyaW5nJyk/IHtzb3VsOiBvfSA6IG8gfHwge307XG5cdFx0biA9IG4gfHwge307IC8vIG1ha2Ugc3VyZSBpdCBleGlzdHMuXG5cdFx0bi5fID0gbi5fIHx8IHt9OyAvLyBtYWtlIHN1cmUgbWV0YSBleGlzdHMuXG5cdFx0bi5fW3NvdWxfXSA9IG8uc291bCB8fCBuLl9bc291bF9dIHx8IHRleHRfcmFuZG9tKCk7IC8vIHB1dCB0aGUgc291bCBvbiBpdC5cblx0XHRyZXR1cm4gbjtcblx0fVxuXHROb2RlLnNvdWwuXyA9IFZhbC5saW5rLl87XG5cdDsoZnVuY3Rpb24oKXtcblx0XHROb2RlLmlzID0gZnVuY3Rpb24obiwgY2IsIGFzKXsgREVQKCdub2RlLmlzJyk7IHZhciBzOyAvLyBjaGVja3MgdG8gc2VlIGlmIGFuIG9iamVjdCBpcyBhIHZhbGlkIG5vZGUuXG5cdFx0XHRpZighb2JqX2lzKG4pKXsgcmV0dXJuIGZhbHNlIH0gLy8gbXVzdCBiZSBhbiBvYmplY3QuXG5cdFx0XHRpZihzID0gTm9kZS5zb3VsKG4pKXsgLy8gbXVzdCBoYXZlIGEgc291bCBvbiBpdC5cblx0XHRcdFx0cmV0dXJuICFvYmpfbWFwKG4sIG1hcCwge2FzOmFzLGNiOmNiLHM6cyxuOm59KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTsgLy8gbm9wZSEgVGhpcyB3YXMgbm90IGEgdmFsaWQgbm9kZS5cblx0XHR9XG5cdFx0ZnVuY3Rpb24gbWFwKHYsIGspeyAvLyB3ZSBpbnZlcnQgdGhpcyBiZWNhdXNlIHRoZSB3YXkgd2UgY2hlY2sgZm9yIHRoaXMgaXMgdmlhIGEgbmVnYXRpb24uXG5cdFx0XHRpZihrID09PSBOb2RlLl8peyByZXR1cm4gfSAvLyBza2lwIG92ZXIgdGhlIG1ldGFkYXRhLlxuXHRcdFx0aWYoIVZhbC5pcyh2KSl7IHJldHVybiB0cnVlIH0gLy8gaXQgaXMgdHJ1ZSB0aGF0IHRoaXMgaXMgYW4gaW52YWxpZCBub2RlLlxuXHRcdFx0aWYodGhpcy5jYil7IHRoaXMuY2IuY2FsbCh0aGlzLmFzLCB2LCBrLCB0aGlzLm4sIHRoaXMucykgfSAvLyBvcHRpb25hbGx5IGNhbGxiYWNrIGVhY2gga2V5L3ZhbHVlLlxuXHRcdH1cblx0fSgpKTtcblx0OyhmdW5jdGlvbigpe1xuXHRcdE5vZGUuaWZ5ID0gZnVuY3Rpb24ob2JqLCBvLCBhcyl7IERFUCgnbm9kZS5pZnknKTsgLy8gcmV0dXJucyBhIG5vZGUgZnJvbSBhIHNoYWxsb3cgb2JqZWN0LlxuXHRcdFx0aWYoIW8peyBvID0ge30gfVxuXHRcdFx0ZWxzZSBpZih0eXBlb2YgbyA9PT0gJ3N0cmluZycpeyBvID0ge3NvdWw6IG99IH1cblx0XHRcdGVsc2UgaWYoJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygbyl7IG8gPSB7bWFwOiBvfSB9XG5cdFx0XHRpZihvLm1hcCl7IG8ubm9kZSA9IG8ubWFwLmNhbGwoYXMsIG9iaiwgdSwgby5ub2RlIHx8IHt9KSB9XG5cdFx0XHRpZihvLm5vZGUgPSBOb2RlLnNvdWwuaWZ5KG8ubm9kZSB8fCB7fSwgbykpe1xuXHRcdFx0XHRvYmpfbWFwKG9iaiwgbWFwLCB7bzpvLGFzOmFzfSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gby5ub2RlOyAvLyBUaGlzIHdpbGwgb25seSBiZSBhIHZhbGlkIG5vZGUgaWYgdGhlIG9iamVjdCB3YXNuJ3QgYWxyZWFkeSBkZWVwIVxuXHRcdH1cblx0XHRmdW5jdGlvbiBtYXAodiwgayl7IHZhciBvID0gdGhpcy5vLCB0bXAsIHU7IC8vIGl0ZXJhdGUgb3ZlciBlYWNoIGtleS92YWx1ZS5cblx0XHRcdGlmKG8ubWFwKXtcblx0XHRcdFx0dG1wID0gby5tYXAuY2FsbCh0aGlzLmFzLCB2LCAnJytrLCBvLm5vZGUpO1xuXHRcdFx0XHRpZih1ID09PSB0bXApe1xuXHRcdFx0XHRcdG9ial9kZWwoby5ub2RlLCBrKTtcblx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdGlmKG8ubm9kZSl7IG8ubm9kZVtrXSA9IHRtcCB9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmKFZhbC5pcyh2KSl7XG5cdFx0XHRcdG8ubm9kZVtrXSA9IHY7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCkpO1xuXHR2YXIgb2JqID0gVHlwZS5vYmosIG9ial9pcyA9IG9iai5pcywgb2JqX2RlbCA9IG9iai5kZWwsIG9ial9tYXAgPSBvYmoubWFwO1xuXHR2YXIgdGV4dCA9IFR5cGUudGV4dCwgdGV4dF9yYW5kb20gPSB0ZXh0LnJhbmRvbTtcblx0dmFyIHNvdWxfID0gTm9kZS5zb3VsLl87XG5cdHZhciB1O1xuXHRUeXBlLm5vZGUgPSBUeXBlLm5vZGUgfHwgTm9kZTtcblxuXHR2YXIgU3RhdGUgPSBUeXBlLnN0YXRlO1xuXHRTdGF0ZS5sZXggPSBmdW5jdGlvbigpeyBERVAoJ3N0YXRlLmxleCcpOyByZXR1cm4gU3RhdGUoKS50b1N0cmluZygzNikucmVwbGFjZSgnLicsJycpIH1cblx0U3RhdGUudG8gPSBmdW5jdGlvbihmcm9tLCBrLCB0byl7IERFUCgnc3RhdGUudG8nKTsgXG5cdFx0dmFyIHZhbCA9IChmcm9tfHx7fSlba107XG5cdFx0aWYob2JqX2lzKHZhbCkpe1xuXHRcdFx0dmFsID0gb2JqX2NvcHkodmFsKTtcblx0XHR9XG5cdFx0cmV0dXJuIFN0YXRlLmlmeSh0bywgaywgU3RhdGUuaXMoZnJvbSwgayksIHZhbCwgTm9kZS5zb3VsKGZyb20pKTtcblx0fVxuXHQ7KGZ1bmN0aW9uKCl7XG5cdFx0U3RhdGUubWFwID0gZnVuY3Rpb24oY2IsIHMsIGFzKXsgREVQKCdzdGF0ZS5tYXAnKTsgdmFyIHU7IC8vIGZvciB1c2Ugd2l0aCBOb2RlLmlmeVxuXHRcdFx0dmFyIG8gPSBvYmpfaXMobyA9IGNiIHx8IHMpPyBvIDogbnVsbDtcblx0XHRcdGNiID0gZm5faXMoY2IgPSBjYiB8fCBzKT8gY2IgOiBudWxsO1xuXHRcdFx0aWYobyAmJiAhY2Ipe1xuXHRcdFx0XHRzID0gbnVtX2lzKHMpPyBzIDogU3RhdGUoKTtcblx0XHRcdFx0b1tOX10gPSBvW05fXSB8fCB7fTtcblx0XHRcdFx0b2JqX21hcChvLCBtYXAsIHtvOm8sczpzfSk7XG5cdFx0XHRcdHJldHVybiBvO1xuXHRcdFx0fVxuXHRcdFx0YXMgPSBhcyB8fCBvYmpfaXMocyk/IHMgOiB1O1xuXHRcdFx0cyA9IG51bV9pcyhzKT8gcyA6IFN0YXRlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24odiwgaywgbywgb3B0KXtcblx0XHRcdFx0aWYoIWNiKXtcblx0XHRcdFx0XHRtYXAuY2FsbCh7bzogbywgczogc30sIHYsayk7XG5cdFx0XHRcdFx0cmV0dXJuIHY7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2IuY2FsbChhcyB8fCB0aGlzIHx8IHt9LCB2LCBrLCBvLCBvcHQpO1xuXHRcdFx0XHRpZihvYmpfaGFzKG8saykgJiYgdSA9PT0gb1trXSl7IHJldHVybiB9XG5cdFx0XHRcdG1hcC5jYWxsKHtvOiBvLCBzOiBzfSwgdixrKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZnVuY3Rpb24gbWFwKHYsayl7XG5cdFx0XHRpZihOXyA9PT0gayl7IHJldHVybiB9XG5cdFx0XHRTdGF0ZS5pZnkodGhpcy5vLCBrLCB0aGlzLnMpIDtcblx0XHR9XG5cdH0oKSk7XG5cdHZhciBvYmogPSBUeXBlLm9iaiwgb2JqX2FzID0gb2JqLmFzLCBvYmpfaGFzID0gb2JqLmhhcywgb2JqX2lzID0gb2JqLmlzLCBvYmpfbWFwID0gb2JqLm1hcCwgb2JqX2NvcHkgPSBvYmouY29weTtcblx0dmFyIG51bSA9IFR5cGUubnVtLCBudW1faXMgPSBudW0uaXM7XG5cdHZhciBmbiA9IFR5cGUuZm4sIGZuX2lzID0gZm4uaXM7XG5cdHZhciBOXyA9IE5vZGUuXywgdTtcblxuXHR2YXIgR3JhcGggPSB7fTtcblx0OyhmdW5jdGlvbigpe1xuXHRcdEdyYXBoLmlzID0gZnVuY3Rpb24oZywgY2IsIGZuLCBhcyl7IERFUCgnZ3JhcGguaXMnKTsgLy8gY2hlY2tzIHRvIHNlZSBpZiBhbiBvYmplY3QgaXMgYSB2YWxpZCBncmFwaC5cblx0XHRcdGlmKCFnIHx8ICFvYmpfaXMoZykgfHwgb2JqX2VtcHR5KGcpKXsgcmV0dXJuIGZhbHNlIH0gLy8gbXVzdCBiZSBhbiBvYmplY3QuXG5cdFx0XHRyZXR1cm4gIW9ial9tYXAoZywgbWFwLCB7Y2I6Y2IsZm46Zm4sYXM6YXN9KTsgLy8gbWFrZXMgc3VyZSBpdCB3YXNuJ3QgYW4gZW1wdHkgb2JqZWN0LlxuXHRcdH1cblx0XHRmdW5jdGlvbiBtYXAobiwgcyl7IC8vIHdlIGludmVydCB0aGlzIGJlY2F1c2UgdGhlIHdheSc/IHdlIGNoZWNrIGZvciB0aGlzIGlzIHZpYSBhIG5lZ2F0aW9uLlxuXHRcdFx0aWYoIW4gfHwgcyAhPT0gTm9kZS5zb3VsKG4pIHx8ICFOb2RlLmlzKG4sIHRoaXMuZm4sIHRoaXMuYXMpKXsgcmV0dXJuIHRydWUgfSAvLyBpdCBpcyB0cnVlIHRoYXQgdGhpcyBpcyBhbiBpbnZhbGlkIGdyYXBoLlxuXHRcdFx0aWYoIXRoaXMuY2IpeyByZXR1cm4gfVxuXHRcdFx0bmYubiA9IG47IG5mLmFzID0gdGhpcy5hczsgLy8gc2VxdWVudGlhbCByYWNlIGNvbmRpdGlvbnMgYXJlbid0IHJhY2VzLlxuXHRcdFx0dGhpcy5jYi5jYWxsKG5mLmFzLCBuLCBzLCBuZik7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIG5mKGZuKXsgLy8gb3B0aW9uYWwgY2FsbGJhY2sgZm9yIGVhY2ggbm9kZS5cblx0XHRcdGlmKGZuKXsgTm9kZS5pcyhuZi5uLCBmbiwgbmYuYXMpIH0gLy8gd2hlcmUgd2UgdGhlbiBoYXZlIGFuIG9wdGlvbmFsIGNhbGxiYWNrIGZvciBlYWNoIGtleS92YWx1ZS5cblx0XHR9XG5cdH0oKSk7XG5cdDsoZnVuY3Rpb24oKXtcblx0XHRHcmFwaC5pZnkgPSBmdW5jdGlvbihvYmosIGVudiwgYXMpeyBERVAoJ2dyYXBoLmlmeScpOyBcblx0XHRcdHZhciBhdCA9IHtwYXRoOiBbXSwgb2JqOiBvYmp9O1xuXHRcdFx0aWYoIWVudil7XG5cdFx0XHRcdGVudiA9IHt9O1xuXHRcdFx0fSBlbHNlXG5cdFx0XHRpZih0eXBlb2YgZW52ID09PSAnc3RyaW5nJyl7XG5cdFx0XHRcdGVudiA9IHtzb3VsOiBlbnZ9O1xuXHRcdFx0fSBlbHNlXG5cdFx0XHRpZignZnVuY3Rpb24nID09IHR5cGVvZiBlbnYpe1xuXHRcdFx0XHRlbnYubWFwID0gZW52O1xuXHRcdFx0fVxuXHRcdFx0aWYodHlwZW9mIGFzID09PSAnc3RyaW5nJyl7XG5cdFx0XHRcdGVudi5zb3VsID0gZW52LnNvdWwgfHwgYXM7XG5cdFx0XHRcdGFzID0gdTtcblx0XHRcdH1cblx0XHRcdGlmKGVudi5zb3VsKXtcblx0XHRcdFx0YXQubGluayA9IFZhbC5saW5rLmlmeShlbnYuc291bCk7XG5cdFx0XHR9XG5cdFx0XHRlbnYuc2hlbGwgPSAoYXN8fHt9KS5zaGVsbDtcblx0XHRcdGVudi5ncmFwaCA9IGVudi5ncmFwaCB8fCB7fTtcblx0XHRcdGVudi5zZWVuID0gZW52LnNlZW4gfHwgW107XG5cdFx0XHRlbnYuYXMgPSBlbnYuYXMgfHwgYXM7XG5cdFx0XHRub2RlKGVudiwgYXQpO1xuXHRcdFx0ZW52LnJvb3QgPSBhdC5ub2RlO1xuXHRcdFx0cmV0dXJuIGVudi5ncmFwaDtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gbm9kZShlbnYsIGF0KXsgdmFyIHRtcDtcblx0XHRcdGlmKHRtcCA9IHNlZW4oZW52LCBhdCkpeyByZXR1cm4gdG1wIH1cblx0XHRcdGF0LmVudiA9IGVudjtcblx0XHRcdGF0LnNvdWwgPSBzb3VsO1xuXHRcdFx0aWYoTm9kZS5pZnkoYXQub2JqLCBtYXAsIGF0KSl7XG5cdFx0XHRcdGF0LmxpbmsgPSBhdC5saW5rIHx8IFZhbC5saW5rLmlmeShOb2RlLnNvdWwoYXQubm9kZSkpO1xuXHRcdFx0XHRpZihhdC5vYmogIT09IGVudi5zaGVsbCl7XG5cdFx0XHRcdFx0ZW52LmdyYXBoW1ZhbC5saW5rLmlzKGF0LmxpbmspXSA9IGF0Lm5vZGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBhdDtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gbWFwKHYsayxuKXtcblx0XHRcdHZhciBhdCA9IHRoaXMsIGVudiA9IGF0LmVudiwgaXMsIHRtcDtcblx0XHRcdGlmKE5vZGUuXyA9PT0gayAmJiBvYmpfaGFzKHYsVmFsLmxpbmsuXykpe1xuXHRcdFx0XHRyZXR1cm4gbi5fOyAvLyBUT0RPOiBCdWc/XG5cdFx0XHR9XG5cdFx0XHRpZighKGlzID0gdmFsaWQodixrLG4sIGF0LGVudikpKXsgcmV0dXJuIH1cblx0XHRcdGlmKCFrKXtcblx0XHRcdFx0YXQubm9kZSA9IGF0Lm5vZGUgfHwgbiB8fCB7fTtcblx0XHRcdFx0aWYob2JqX2hhcyh2LCBOb2RlLl8pICYmIE5vZGUuc291bCh2KSl7IC8vID8gZm9yIHNhZmV0eSA/XG5cdFx0XHRcdFx0YXQubm9kZS5fID0gb2JqX2NvcHkodi5fKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhdC5ub2RlID0gTm9kZS5zb3VsLmlmeShhdC5ub2RlLCBWYWwubGluay5pcyhhdC5saW5rKSk7XG5cdFx0XHRcdGF0LmxpbmsgPSBhdC5saW5rIHx8IFZhbC5saW5rLmlmeShOb2RlLnNvdWwoYXQubm9kZSkpO1xuXHRcdFx0fVxuXHRcdFx0aWYodG1wID0gZW52Lm1hcCl7XG5cdFx0XHRcdHRtcC5jYWxsKGVudi5hcyB8fCB7fSwgdixrLG4sIGF0KTtcblx0XHRcdFx0aWYob2JqX2hhcyhuLGspKXtcblx0XHRcdFx0XHR2ID0gbltrXTtcblx0XHRcdFx0XHRpZih1ID09PSB2KXtcblx0XHRcdFx0XHRcdG9ial9kZWwobiwgayk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKCEoaXMgPSB2YWxpZCh2LGssbiwgYXQsZW52KSkpeyByZXR1cm4gfVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZighayl7IHJldHVybiBhdC5ub2RlIH1cblx0XHRcdGlmKHRydWUgPT09IGlzKXtcblx0XHRcdFx0cmV0dXJuIHY7XG5cdFx0XHR9XG5cdFx0XHR0bXAgPSBub2RlKGVudiwge29iajogdiwgcGF0aDogYXQucGF0aC5jb25jYXQoayl9KTtcblx0XHRcdGlmKCF0bXAubm9kZSl7IHJldHVybiB9XG5cdFx0XHRyZXR1cm4gdG1wLmxpbms7IC8veycjJzogTm9kZS5zb3VsKHRtcC5ub2RlKX07XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIHNvdWwoaWQpeyB2YXIgYXQgPSB0aGlzO1xuXHRcdFx0dmFyIHByZXYgPSBWYWwubGluay5pcyhhdC5saW5rKSwgZ3JhcGggPSBhdC5lbnYuZ3JhcGg7XG5cdFx0XHRhdC5saW5rID0gYXQubGluayB8fCBWYWwubGluay5pZnkoaWQpO1xuXHRcdFx0YXQubGlua1tWYWwubGluay5fXSA9IGlkO1xuXHRcdFx0aWYoYXQubm9kZSAmJiBhdC5ub2RlW05vZGUuX10pe1xuXHRcdFx0XHRhdC5ub2RlW05vZGUuX11bVmFsLmxpbmsuX10gPSBpZDtcblx0XHRcdH1cblx0XHRcdGlmKG9ial9oYXMoZ3JhcGgsIHByZXYpKXtcblx0XHRcdFx0Z3JhcGhbaWRdID0gZ3JhcGhbcHJldl07XG5cdFx0XHRcdG9ial9kZWwoZ3JhcGgsIHByZXYpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmdW5jdGlvbiB2YWxpZCh2LGssbiwgYXQsZW52KXsgdmFyIHRtcDtcblx0XHRcdGlmKFZhbC5pcyh2KSl7IHJldHVybiB0cnVlIH1cblx0XHRcdGlmKG9ial9pcyh2KSl7IHJldHVybiAxIH1cblx0XHRcdGlmKHRtcCA9IGVudi5pbnZhbGlkKXtcblx0XHRcdFx0diA9IHRtcC5jYWxsKGVudi5hcyB8fCB7fSwgdixrLG4pO1xuXHRcdFx0XHRyZXR1cm4gdmFsaWQodixrLG4sIGF0LGVudik7XG5cdFx0XHR9XG5cdFx0XHRlbnYuZXJyID0gXCJJbnZhbGlkIHZhbHVlIGF0ICdcIiArIGF0LnBhdGguY29uY2F0KGspLmpvaW4oJy4nKSArIFwiJyFcIjtcblx0XHRcdGlmKFR5cGUubGlzdC5pcyh2KSl7IGVudi5lcnIgKz0gXCIgVXNlIGAuc2V0KGl0ZW0pYCBpbnN0ZWFkIG9mIGFuIEFycmF5LlwiIH1cblx0XHR9XG5cdFx0ZnVuY3Rpb24gc2VlbihlbnYsIGF0KXtcblx0XHRcdHZhciBhcnIgPSBlbnYuc2VlbiwgaSA9IGFyci5sZW5ndGgsIGhhcztcblx0XHRcdHdoaWxlKGktLSl7IGhhcyA9IGFycltpXTtcblx0XHRcdFx0aWYoYXQub2JqID09PSBoYXMub2JqKXsgcmV0dXJuIGhhcyB9XG5cdFx0XHR9XG5cdFx0XHRhcnIucHVzaChhdCk7XG5cdFx0fVxuXHR9KCkpO1xuXHRHcmFwaC5ub2RlID0gZnVuY3Rpb24obm9kZSl7IERFUCgnZ3JhcGgubm9kZScpOyBcblx0XHR2YXIgc291bCA9IE5vZGUuc291bChub2RlKTtcblx0XHRpZighc291bCl7IHJldHVybiB9XG5cdFx0cmV0dXJuIG9ial9wdXQoe30sIHNvdWwsIG5vZGUpO1xuXHR9XG5cdDsoZnVuY3Rpb24oKXtcblx0XHRHcmFwaC50byA9IGZ1bmN0aW9uKGdyYXBoLCByb290LCBvcHQpeyBERVAoJ2dyYXBoLnRvJyk7IFxuXHRcdFx0aWYoIWdyYXBoKXsgcmV0dXJuIH1cblx0XHRcdHZhciBvYmogPSB7fTtcblx0XHRcdG9wdCA9IG9wdCB8fCB7c2Vlbjoge319O1xuXHRcdFx0b2JqX21hcChncmFwaFtyb290XSwgbWFwLCB7b2JqOm9iaiwgZ3JhcGg6IGdyYXBoLCBvcHQ6IG9wdH0pO1xuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gbWFwKHYsayl7IHZhciB0bXAsIG9iajtcblx0XHRcdGlmKE5vZGUuXyA9PT0gayl7XG5cdFx0XHRcdGlmKG9ial9lbXB0eSh2LCBWYWwubGluay5fKSl7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMub2JqW2tdID0gb2JqX2NvcHkodik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmKCEodG1wID0gVmFsLmxpbmsuaXModikpKXtcblx0XHRcdFx0dGhpcy5vYmpba10gPSB2O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZihvYmogPSB0aGlzLm9wdC5zZWVuW3RtcF0pe1xuXHRcdFx0XHR0aGlzLm9ialtrXSA9IG9iajtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5vYmpba10gPSB0aGlzLm9wdC5zZWVuW3RtcF0gPSBHcmFwaC50byh0aGlzLmdyYXBoLCB0bXAsIHRoaXMub3B0KTtcblx0XHR9XG5cdH0oKSk7XG5cdHZhciBmbl9pcyA9IFR5cGUuZm4uaXM7XG5cdHZhciBvYmogPSBUeXBlLm9iaiwgb2JqX2lzID0gb2JqLmlzLCBvYmpfZGVsID0gb2JqLmRlbCwgb2JqX2hhcyA9IG9iai5oYXMsIG9ial9lbXB0eSA9IG9iai5lbXB0eSwgb2JqX3B1dCA9IG9iai5wdXQsIG9ial9tYXAgPSBvYmoubWFwLCBvYmpfY29weSA9IG9iai5jb3B5O1xuXHR2YXIgdTtcblx0VHlwZS5ncmFwaCA9IFR5cGUuZ3JhcGggfHwgR3JhcGg7XG59KCkpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/gun/gun.js\n"));

/***/ }),

/***/ "./node_modules/gun sync recursive":
/*!********************************!*\
  !*** ./node_modules/gun/ sync ***!
  \********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/gun sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./pages/index.css":
/*!*****************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./pages/index.css ***!
  \*****************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"body {\\r\\n    margin: 0;\\r\\n    font-family: -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", \\\"Roboto\\\", \\\"Oxygen\\\",\\r\\n      \\\"Ubuntu\\\", \\\"Cantarell\\\", \\\"Fira Sans\\\", \\\"Droid Sans\\\", \\\"Helvetica Neue\\\",\\r\\n      sans-serif;\\r\\n    -webkit-font-smoothing: antialiased;\\r\\n    -moz-osx-font-smoothing: grayscale;\\r\\n    height: 100vh;\\r\\n    width: 100vw;\\r\\n    background-color: rgb(25, 33, 52) !important;\\r\\n    background: rgb(25, 33, 52);\\r\\n    background: linear-gradient(\\r\\n      180deg,\\r\\n      rgba(25, 33, 52, 1) 28%,\\r\\n      rgba(7, 8, 21, 1) 75%\\r\\n    );\\r\\n    color: white;\\r\\n  }\\r\\n  \\r\\n  code {\\r\\n    font-family: source-code-pro, Menlo, Monaco, Consolas, \\\"Courier New\\\",\\r\\n      monospace;\\r\\n  }\\r\\n  \\r\\n  .ant-input {\\r\\n    background-color: #1f2639 !important;\\r\\n    color: white !important;\\r\\n    border-width: 0px !important;\\r\\n    height: 96px !important;\\r\\n    margin-bottom: 5px;\\r\\n    font-size: 35px;\\r\\n    border-radius: 12px !important;\\r\\n  }\\r\\n  \\r\\n  .ant-input::-moz-placeholder {\\r\\n    color: #5f6783 !important;\\r\\n  }\\r\\n  \\r\\n  .ant-input::placeholder {\\r\\n    color: #5f6783 !important;\\r\\n  }\\r\\n  \\r\\n  .ant-popover-arrow {\\r\\n    visibility: hidden;\\r\\n  }\\r\\n  \\r\\n  .ant-popover-title {\\r\\n    color: white !important;\\r\\n  }\\r\\n  \\r\\n  .ant-popover-inner-content {\\r\\n    color: white !important;\\r\\n  }\\r\\n  \\r\\n  .ant-popover-inner {\\r\\n    min-width: 260px !important;\\r\\n    min-height: 140px !important;\\r\\n    border: 1px solid #21273a;\\r\\n    background-color: #0e111b !important;\\r\\n  }\\r\\n  \\r\\n  .ant-radio-group {\\r\\n    margin-top: 10px;\\r\\n  }\\r\\n  \\r\\n  .ant-radio-button-wrapper {\\r\\n    background-color: #1f2639 !important;\\r\\n    color: white !important;\\r\\n    font-weight: 500;\\r\\n    border-color: white !important;\\r\\n  }\\r\\n  \\r\\n  .ant-radio-button-wrapper-checked {\\r\\n    border-color: white !important;\\r\\n    background-color: #363e54 !important;\\r\\n  }\\r\\n  \\r\\n  .ant-radio-button-wrapper-checked::before {\\r\\n    background-color: white !important;\\r\\n  }\\r\\n  \\r\\n  .ant-modal-content {\\r\\n    background-color: #0e111b !important;\\r\\n    color: white !important;\\r\\n    padding: 0px !important;\\r\\n  }\\r\\n  \\r\\n  .ant-modal {\\r\\n    border: 1px solid #363e54;\\r\\n    width: 400px !important;\\r\\n    border-radius: 10px;\\r\\n  }\\r\\n  \\r\\n  .ant-modal-header {\\r\\n    background-color: #0e111b !important;\\r\\n  }\\r\\n  \\r\\n  .ant-modal-title {\\r\\n    color: white !important;\\r\\n    padding-top: 17px !important;\\r\\n    margin-left: 20px !important;\\r\\n  }\\r\\n  \\r\\n  .ant-modal-close-icon {\\r\\n    color: #363e54 !important;\\r\\n    transition: 0.3s;\\r\\n  }\\r\\n  \\r\\n  .ant-modal-close-icon:hover {\\r\\n    color: white !important;\\r\\n  }\", \"\",{\"version\":3,\"sources\":[\"webpack://pages/index.css\"],\"names\":[],\"mappings\":\"AAAA;IACI,SAAS;IACT;;gBAEY;IACZ,mCAAmC;IACnC,kCAAkC;IAClC,aAAa;IACb,YAAY;IACZ,4CAA4C;IAC5C,2BAA2B;IAC3B;;;;KAIC;IACD,YAAY;EACd;;EAEA;IACE;eACW;EACb;;EAEA;IACE,oCAAoC;IACpC,uBAAuB;IACvB,4BAA4B;IAC5B,uBAAuB;IACvB,kBAAkB;IAClB,eAAe;IACf,8BAA8B;EAChC;;EAEA;IACE,yBAAyB;EAC3B;;EAFA;IACE,yBAAyB;EAC3B;;EAEA;IACE,kBAAkB;EACpB;;EAEA;IACE,uBAAuB;EACzB;;EAEA;IACE,uBAAuB;EACzB;;EAEA;IACE,2BAA2B;IAC3B,4BAA4B;IAC5B,yBAAyB;IACzB,oCAAoC;EACtC;;EAEA;IACE,gBAAgB;EAClB;;EAEA;IACE,oCAAoC;IACpC,uBAAuB;IACvB,gBAAgB;IAChB,8BAA8B;EAChC;;EAEA;IACE,8BAA8B;IAC9B,oCAAoC;EACtC;;EAEA;IACE,kCAAkC;EACpC;;EAEA;IACE,oCAAoC;IACpC,uBAAuB;IACvB,uBAAuB;EACzB;;EAEA;IACE,yBAAyB;IACzB,uBAAuB;IACvB,mBAAmB;EACrB;;EAEA;IACE,oCAAoC;EACtC;;EAEA;IACE,uBAAuB;IACvB,4BAA4B;IAC5B,4BAA4B;EAC9B;;EAEA;IACE,yBAAyB;IACzB,gBAAgB;EAClB;;EAEA;IACE,uBAAuB;EACzB\",\"sourcesContent\":[\"body {\\r\\n    margin: 0;\\r\\n    font-family: -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", \\\"Roboto\\\", \\\"Oxygen\\\",\\r\\n      \\\"Ubuntu\\\", \\\"Cantarell\\\", \\\"Fira Sans\\\", \\\"Droid Sans\\\", \\\"Helvetica Neue\\\",\\r\\n      sans-serif;\\r\\n    -webkit-font-smoothing: antialiased;\\r\\n    -moz-osx-font-smoothing: grayscale;\\r\\n    height: 100vh;\\r\\n    width: 100vw;\\r\\n    background-color: rgb(25, 33, 52) !important;\\r\\n    background: rgb(25, 33, 52);\\r\\n    background: linear-gradient(\\r\\n      180deg,\\r\\n      rgba(25, 33, 52, 1) 28%,\\r\\n      rgba(7, 8, 21, 1) 75%\\r\\n    );\\r\\n    color: white;\\r\\n  }\\r\\n  \\r\\n  code {\\r\\n    font-family: source-code-pro, Menlo, Monaco, Consolas, \\\"Courier New\\\",\\r\\n      monospace;\\r\\n  }\\r\\n  \\r\\n  .ant-input {\\r\\n    background-color: #1f2639 !important;\\r\\n    color: white !important;\\r\\n    border-width: 0px !important;\\r\\n    height: 96px !important;\\r\\n    margin-bottom: 5px;\\r\\n    font-size: 35px;\\r\\n    border-radius: 12px !important;\\r\\n  }\\r\\n  \\r\\n  .ant-input::placeholder {\\r\\n    color: #5f6783 !important;\\r\\n  }\\r\\n  \\r\\n  .ant-popover-arrow {\\r\\n    visibility: hidden;\\r\\n  }\\r\\n  \\r\\n  .ant-popover-title {\\r\\n    color: white !important;\\r\\n  }\\r\\n  \\r\\n  .ant-popover-inner-content {\\r\\n    color: white !important;\\r\\n  }\\r\\n  \\r\\n  .ant-popover-inner {\\r\\n    min-width: 260px !important;\\r\\n    min-height: 140px !important;\\r\\n    border: 1px solid #21273a;\\r\\n    background-color: #0e111b !important;\\r\\n  }\\r\\n  \\r\\n  .ant-radio-group {\\r\\n    margin-top: 10px;\\r\\n  }\\r\\n  \\r\\n  .ant-radio-button-wrapper {\\r\\n    background-color: #1f2639 !important;\\r\\n    color: white !important;\\r\\n    font-weight: 500;\\r\\n    border-color: white !important;\\r\\n  }\\r\\n  \\r\\n  .ant-radio-button-wrapper-checked {\\r\\n    border-color: white !important;\\r\\n    background-color: #363e54 !important;\\r\\n  }\\r\\n  \\r\\n  .ant-radio-button-wrapper-checked::before {\\r\\n    background-color: white !important;\\r\\n  }\\r\\n  \\r\\n  .ant-modal-content {\\r\\n    background-color: #0e111b !important;\\r\\n    color: white !important;\\r\\n    padding: 0px !important;\\r\\n  }\\r\\n  \\r\\n  .ant-modal {\\r\\n    border: 1px solid #363e54;\\r\\n    width: 400px !important;\\r\\n    border-radius: 10px;\\r\\n  }\\r\\n  \\r\\n  .ant-modal-header {\\r\\n    background-color: #0e111b !important;\\r\\n  }\\r\\n  \\r\\n  .ant-modal-title {\\r\\n    color: white !important;\\r\\n    padding-top: 17px !important;\\r\\n    margin-left: 20px !important;\\r\\n  }\\r\\n  \\r\\n  .ant-modal-close-icon {\\r\\n    color: #363e54 !important;\\r\\n    transition: 0.3s;\\r\\n  }\\r\\n  \\r\\n  .ant-modal-close-icon:hover {\\r\\n    color: white !important;\\r\\n  }\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls5XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOV0udXNlWzJdIS4vcGFnZXMvaW5kZXguY3NzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ3dIO0FBQ3hILDhCQUE4QixrSEFBMkI7QUFDekQ7QUFDQSxnREFBZ0Qsa0JBQWtCLHlNQUF5TSw0Q0FBNEMsMkNBQTJDLHNCQUFzQixxQkFBcUIscURBQXFELG9DQUFvQyxnSUFBZ0kscUJBQXFCLE9BQU8sa0JBQWtCLG1HQUFtRyxPQUFPLHdCQUF3Qiw2Q0FBNkMsZ0NBQWdDLHFDQUFxQyxnQ0FBZ0MsMkJBQTJCLHdCQUF3Qix1Q0FBdUMsT0FBTywwQ0FBMEMsa0NBQWtDLE9BQU8scUNBQXFDLGtDQUFrQyxPQUFPLGdDQUFnQywyQkFBMkIsT0FBTyxnQ0FBZ0MsZ0NBQWdDLE9BQU8sd0NBQXdDLGdDQUFnQyxPQUFPLGdDQUFnQyxvQ0FBb0MscUNBQXFDLGtDQUFrQyw2Q0FBNkMsT0FBTyw4QkFBOEIseUJBQXlCLE9BQU8sdUNBQXVDLDZDQUE2QyxnQ0FBZ0MseUJBQXlCLHVDQUF1QyxPQUFPLCtDQUErQyx1Q0FBdUMsNkNBQTZDLE9BQU8sdURBQXVELDJDQUEyQyxPQUFPLGdDQUFnQyw2Q0FBNkMsZ0NBQWdDLGdDQUFnQyxPQUFPLHdCQUF3QixrQ0FBa0MsZ0NBQWdDLDRCQUE0QixPQUFPLCtCQUErQiw2Q0FBNkMsT0FBTyw4QkFBOEIsZ0NBQWdDLHFDQUFxQyxxQ0FBcUMsT0FBTyxtQ0FBbUMsa0NBQWtDLHlCQUF5QixPQUFPLHlDQUF5QyxnQ0FBZ0MsT0FBTyxPQUFPLGdGQUFnRixVQUFVLE1BQU0sTUFBTSxZQUFZLGFBQWEsV0FBVyxVQUFVLFlBQVksYUFBYSxTQUFTLEtBQUssVUFBVSxNQUFNLEtBQUssS0FBSyxLQUFLLE1BQU0sS0FBSyxZQUFZLGFBQWEsYUFBYSxhQUFhLGFBQWEsV0FBVyxZQUFZLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZLGFBQWEsYUFBYSxhQUFhLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZLGFBQWEsYUFBYSxhQUFhLE9BQU8sS0FBSyxZQUFZLGFBQWEsT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksYUFBYSxhQUFhLE9BQU8sS0FBSyxZQUFZLGFBQWEsYUFBYSxPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssWUFBWSxhQUFhLGFBQWEsT0FBTyxLQUFLLFlBQVksYUFBYSxPQUFPLEtBQUssWUFBWSxnQ0FBZ0Msa0JBQWtCLHlNQUF5TSw0Q0FBNEMsMkNBQTJDLHNCQUFzQixxQkFBcUIscURBQXFELG9DQUFvQyxnSUFBZ0kscUJBQXFCLE9BQU8sa0JBQWtCLG1HQUFtRyxPQUFPLHdCQUF3Qiw2Q0FBNkMsZ0NBQWdDLHFDQUFxQyxnQ0FBZ0MsMkJBQTJCLHdCQUF3Qix1Q0FBdUMsT0FBTyxxQ0FBcUMsa0NBQWtDLE9BQU8sZ0NBQWdDLDJCQUEyQixPQUFPLGdDQUFnQyxnQ0FBZ0MsT0FBTyx3Q0FBd0MsZ0NBQWdDLE9BQU8sZ0NBQWdDLG9DQUFvQyxxQ0FBcUMsa0NBQWtDLDZDQUE2QyxPQUFPLDhCQUE4Qix5QkFBeUIsT0FBTyx1Q0FBdUMsNkNBQTZDLGdDQUFnQyx5QkFBeUIsdUNBQXVDLE9BQU8sK0NBQStDLHVDQUF1Qyw2Q0FBNkMsT0FBTyx1REFBdUQsMkNBQTJDLE9BQU8sZ0NBQWdDLDZDQUE2QyxnQ0FBZ0MsZ0NBQWdDLE9BQU8sd0JBQXdCLGtDQUFrQyxnQ0FBZ0MsNEJBQTRCLE9BQU8sK0JBQStCLDZDQUE2QyxPQUFPLDhCQUE4QixnQ0FBZ0MscUNBQXFDLHFDQUFxQyxPQUFPLG1DQUFtQyxrQ0FBa0MseUJBQXlCLE9BQU8seUNBQXlDLGdDQUFnQyxPQUFPLG1CQUFtQjtBQUNudE07QUFDQSwrREFBZSx1QkFBdUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wYWdlcy9pbmRleC5jc3M/YmQ0OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiYm9keSB7XFxyXFxuICAgIG1hcmdpbjogMDtcXHJcXG4gICAgZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgXFxcIlNlZ29lIFVJXFxcIiwgXFxcIlJvYm90b1xcXCIsIFxcXCJPeHlnZW5cXFwiLFxcclxcbiAgICAgIFxcXCJVYnVudHVcXFwiLCBcXFwiQ2FudGFyZWxsXFxcIiwgXFxcIkZpcmEgU2Fuc1xcXCIsIFxcXCJEcm9pZCBTYW5zXFxcIiwgXFxcIkhlbHZldGljYSBOZXVlXFxcIixcXHJcXG4gICAgICBzYW5zLXNlcmlmO1xcclxcbiAgICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcXHJcXG4gICAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGdyYXlzY2FsZTtcXHJcXG4gICAgaGVpZ2h0OiAxMDB2aDtcXHJcXG4gICAgd2lkdGg6IDEwMHZ3O1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjUsIDMzLCA1MikgIWltcG9ydGFudDtcXHJcXG4gICAgYmFja2dyb3VuZDogcmdiKDI1LCAzMywgNTIpO1xcclxcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoXFxyXFxuICAgICAgMTgwZGVnLFxcclxcbiAgICAgIHJnYmEoMjUsIDMzLCA1MiwgMSkgMjglLFxcclxcbiAgICAgIHJnYmEoNywgOCwgMjEsIDEpIDc1JVxcclxcbiAgICApO1xcclxcbiAgICBjb2xvcjogd2hpdGU7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIGNvZGUge1xcclxcbiAgICBmb250LWZhbWlseTogc291cmNlLWNvZGUtcHJvLCBNZW5sbywgTW9uYWNvLCBDb25zb2xhcywgXFxcIkNvdXJpZXIgTmV3XFxcIixcXHJcXG4gICAgICBtb25vc3BhY2U7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC5hbnQtaW5wdXQge1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMWYyNjM5ICFpbXBvcnRhbnQ7XFxyXFxuICAgIGNvbG9yOiB3aGl0ZSAhaW1wb3J0YW50O1xcclxcbiAgICBib3JkZXItd2lkdGg6IDBweCAhaW1wb3J0YW50O1xcclxcbiAgICBoZWlnaHQ6IDk2cHggIWltcG9ydGFudDtcXHJcXG4gICAgbWFyZ2luLWJvdHRvbTogNXB4O1xcclxcbiAgICBmb250LXNpemU6IDM1cHg7XFxyXFxuICAgIGJvcmRlci1yYWRpdXM6IDEycHggIWltcG9ydGFudDtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLmFudC1pbnB1dDo6LW1vei1wbGFjZWhvbGRlciB7XFxyXFxuICAgIGNvbG9yOiAjNWY2NzgzICFpbXBvcnRhbnQ7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC5hbnQtaW5wdXQ6OnBsYWNlaG9sZGVyIHtcXHJcXG4gICAgY29sb3I6ICM1ZjY3ODMgIWltcG9ydGFudDtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLmFudC1wb3BvdmVyLWFycm93IHtcXHJcXG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAuYW50LXBvcG92ZXItdGl0bGUge1xcclxcbiAgICBjb2xvcjogd2hpdGUgIWltcG9ydGFudDtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLmFudC1wb3BvdmVyLWlubmVyLWNvbnRlbnQge1xcclxcbiAgICBjb2xvcjogd2hpdGUgIWltcG9ydGFudDtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLmFudC1wb3BvdmVyLWlubmVyIHtcXHJcXG4gICAgbWluLXdpZHRoOiAyNjBweCAhaW1wb3J0YW50O1xcclxcbiAgICBtaW4taGVpZ2h0OiAxNDBweCAhaW1wb3J0YW50O1xcclxcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjMjEyNzNhO1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMGUxMTFiICFpbXBvcnRhbnQ7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC5hbnQtcmFkaW8tZ3JvdXAge1xcclxcbiAgICBtYXJnaW4tdG9wOiAxMHB4O1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAuYW50LXJhZGlvLWJ1dHRvbi13cmFwcGVyIHtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzFmMjYzOSAhaW1wb3J0YW50O1xcclxcbiAgICBjb2xvcjogd2hpdGUgIWltcG9ydGFudDtcXHJcXG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcXHJcXG4gICAgYm9yZGVyLWNvbG9yOiB3aGl0ZSAhaW1wb3J0YW50O1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAuYW50LXJhZGlvLWJ1dHRvbi13cmFwcGVyLWNoZWNrZWQge1xcclxcbiAgICBib3JkZXItY29sb3I6IHdoaXRlICFpbXBvcnRhbnQ7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMzNjNlNTQgIWltcG9ydGFudDtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLmFudC1yYWRpby1idXR0b24td3JhcHBlci1jaGVja2VkOjpiZWZvcmUge1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZSAhaW1wb3J0YW50O1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAuYW50LW1vZGFsLWNvbnRlbnQge1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMGUxMTFiICFpbXBvcnRhbnQ7XFxyXFxuICAgIGNvbG9yOiB3aGl0ZSAhaW1wb3J0YW50O1xcclxcbiAgICBwYWRkaW5nOiAwcHggIWltcG9ydGFudDtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLmFudC1tb2RhbCB7XFxyXFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICMzNjNlNTQ7XFxyXFxuICAgIHdpZHRoOiA0MDBweCAhaW1wb3J0YW50O1xcclxcbiAgICBib3JkZXItcmFkaXVzOiAxMHB4O1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAuYW50LW1vZGFsLWhlYWRlciB7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMwZTExMWIgIWltcG9ydGFudDtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLmFudC1tb2RhbC10aXRsZSB7XFxyXFxuICAgIGNvbG9yOiB3aGl0ZSAhaW1wb3J0YW50O1xcclxcbiAgICBwYWRkaW5nLXRvcDogMTdweCAhaW1wb3J0YW50O1xcclxcbiAgICBtYXJnaW4tbGVmdDogMjBweCAhaW1wb3J0YW50O1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAuYW50LW1vZGFsLWNsb3NlLWljb24ge1xcclxcbiAgICBjb2xvcjogIzM2M2U1NCAhaW1wb3J0YW50O1xcclxcbiAgICB0cmFuc2l0aW9uOiAwLjNzO1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAuYW50LW1vZGFsLWNsb3NlLWljb246aG92ZXIge1xcclxcbiAgICBjb2xvcjogd2hpdGUgIWltcG9ydGFudDtcXHJcXG4gIH1cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vcGFnZXMvaW5kZXguY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0lBQ0ksU0FBUztJQUNUOztnQkFFWTtJQUNaLG1DQUFtQztJQUNuQyxrQ0FBa0M7SUFDbEMsYUFBYTtJQUNiLFlBQVk7SUFDWiw0Q0FBNEM7SUFDNUMsMkJBQTJCO0lBQzNCOzs7O0tBSUM7SUFDRCxZQUFZO0VBQ2Q7O0VBRUE7SUFDRTtlQUNXO0VBQ2I7O0VBRUE7SUFDRSxvQ0FBb0M7SUFDcEMsdUJBQXVCO0lBQ3ZCLDRCQUE0QjtJQUM1Qix1QkFBdUI7SUFDdkIsa0JBQWtCO0lBQ2xCLGVBQWU7SUFDZiw4QkFBOEI7RUFDaEM7O0VBRUE7SUFDRSx5QkFBeUI7RUFDM0I7O0VBRkE7SUFDRSx5QkFBeUI7RUFDM0I7O0VBRUE7SUFDRSxrQkFBa0I7RUFDcEI7O0VBRUE7SUFDRSx1QkFBdUI7RUFDekI7O0VBRUE7SUFDRSx1QkFBdUI7RUFDekI7O0VBRUE7SUFDRSwyQkFBMkI7SUFDM0IsNEJBQTRCO0lBQzVCLHlCQUF5QjtJQUN6QixvQ0FBb0M7RUFDdEM7O0VBRUE7SUFDRSxnQkFBZ0I7RUFDbEI7O0VBRUE7SUFDRSxvQ0FBb0M7SUFDcEMsdUJBQXVCO0lBQ3ZCLGdCQUFnQjtJQUNoQiw4QkFBOEI7RUFDaEM7O0VBRUE7SUFDRSw4QkFBOEI7SUFDOUIsb0NBQW9DO0VBQ3RDOztFQUVBO0lBQ0Usa0NBQWtDO0VBQ3BDOztFQUVBO0lBQ0Usb0NBQW9DO0lBQ3BDLHVCQUF1QjtJQUN2Qix1QkFBdUI7RUFDekI7O0VBRUE7SUFDRSx5QkFBeUI7SUFDekIsdUJBQXVCO0lBQ3ZCLG1CQUFtQjtFQUNyQjs7RUFFQTtJQUNFLG9DQUFvQztFQUN0Qzs7RUFFQTtJQUNFLHVCQUF1QjtJQUN2Qiw0QkFBNEI7SUFDNUIsNEJBQTRCO0VBQzlCOztFQUVBO0lBQ0UseUJBQXlCO0lBQ3pCLGdCQUFnQjtFQUNsQjs7RUFFQTtJQUNFLHVCQUF1QjtFQUN6QlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJib2R5IHtcXHJcXG4gICAgbWFyZ2luOiAwO1xcclxcbiAgICBmb250LWZhbWlseTogLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBcXFwiU2Vnb2UgVUlcXFwiLCBcXFwiUm9ib3RvXFxcIiwgXFxcIk94eWdlblxcXCIsXFxyXFxuICAgICAgXFxcIlVidW50dVxcXCIsIFxcXCJDYW50YXJlbGxcXFwiLCBcXFwiRmlyYSBTYW5zXFxcIiwgXFxcIkRyb2lkIFNhbnNcXFwiLCBcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLFxcclxcbiAgICAgIHNhbnMtc2VyaWY7XFxyXFxuICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xcclxcbiAgICAtbW96LW9zeC1mb250LXNtb290aGluZzogZ3JheXNjYWxlO1xcclxcbiAgICBoZWlnaHQ6IDEwMHZoO1xcclxcbiAgICB3aWR0aDogMTAwdnc7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYigyNSwgMzMsIDUyKSAhaW1wb3J0YW50O1xcclxcbiAgICBiYWNrZ3JvdW5kOiByZ2IoMjUsIDMzLCA1Mik7XFxyXFxuICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudChcXHJcXG4gICAgICAxODBkZWcsXFxyXFxuICAgICAgcmdiYSgyNSwgMzMsIDUyLCAxKSAyOCUsXFxyXFxuICAgICAgcmdiYSg3LCA4LCAyMSwgMSkgNzUlXFxyXFxuICAgICk7XFxyXFxuICAgIGNvbG9yOiB3aGl0ZTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgY29kZSB7XFxyXFxuICAgIGZvbnQtZmFtaWx5OiBzb3VyY2UtY29kZS1wcm8sIE1lbmxvLCBNb25hY28sIENvbnNvbGFzLCBcXFwiQ291cmllciBOZXdcXFwiLFxcclxcbiAgICAgIG1vbm9zcGFjZTtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLmFudC1pbnB1dCB7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMxZjI2MzkgIWltcG9ydGFudDtcXHJcXG4gICAgY29sb3I6IHdoaXRlICFpbXBvcnRhbnQ7XFxyXFxuICAgIGJvcmRlci13aWR0aDogMHB4ICFpbXBvcnRhbnQ7XFxyXFxuICAgIGhlaWdodDogOTZweCAhaW1wb3J0YW50O1xcclxcbiAgICBtYXJnaW4tYm90dG9tOiA1cHg7XFxyXFxuICAgIGZvbnQtc2l6ZTogMzVweDtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogMTJweCAhaW1wb3J0YW50O1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAuYW50LWlucHV0OjpwbGFjZWhvbGRlciB7XFxyXFxuICAgIGNvbG9yOiAjNWY2NzgzICFpbXBvcnRhbnQ7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC5hbnQtcG9wb3Zlci1hcnJvdyB7XFxyXFxuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLmFudC1wb3BvdmVyLXRpdGxlIHtcXHJcXG4gICAgY29sb3I6IHdoaXRlICFpbXBvcnRhbnQ7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC5hbnQtcG9wb3Zlci1pbm5lci1jb250ZW50IHtcXHJcXG4gICAgY29sb3I6IHdoaXRlICFpbXBvcnRhbnQ7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC5hbnQtcG9wb3Zlci1pbm5lciB7XFxyXFxuICAgIG1pbi13aWR0aDogMjYwcHggIWltcG9ydGFudDtcXHJcXG4gICAgbWluLWhlaWdodDogMTQwcHggIWltcG9ydGFudDtcXHJcXG4gICAgYm9yZGVyOiAxcHggc29saWQgIzIxMjczYTtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzBlMTExYiAhaW1wb3J0YW50O1xcclxcbiAgfVxcclxcbiAgXFxyXFxuICAuYW50LXJhZGlvLWdyb3VwIHtcXHJcXG4gICAgbWFyZ2luLXRvcDogMTBweDtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLmFudC1yYWRpby1idXR0b24td3JhcHBlciB7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMxZjI2MzkgIWltcG9ydGFudDtcXHJcXG4gICAgY29sb3I6IHdoaXRlICFpbXBvcnRhbnQ7XFxyXFxuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XFxyXFxuICAgIGJvcmRlci1jb2xvcjogd2hpdGUgIWltcG9ydGFudDtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLmFudC1yYWRpby1idXR0b24td3JhcHBlci1jaGVja2VkIHtcXHJcXG4gICAgYm9yZGVyLWNvbG9yOiB3aGl0ZSAhaW1wb3J0YW50O1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMzYzZTU0ICFpbXBvcnRhbnQ7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC5hbnQtcmFkaW8tYnV0dG9uLXdyYXBwZXItY2hlY2tlZDo6YmVmb3JlIHtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGUgIWltcG9ydGFudDtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLmFudC1tb2RhbC1jb250ZW50IHtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzBlMTExYiAhaW1wb3J0YW50O1xcclxcbiAgICBjb2xvcjogd2hpdGUgIWltcG9ydGFudDtcXHJcXG4gICAgcGFkZGluZzogMHB4ICFpbXBvcnRhbnQ7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC5hbnQtbW9kYWwge1xcclxcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjMzYzZTU0O1xcclxcbiAgICB3aWR0aDogNDAwcHggIWltcG9ydGFudDtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogMTBweDtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLmFudC1tb2RhbC1oZWFkZXIge1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMGUxMTFiICFpbXBvcnRhbnQ7XFxyXFxuICB9XFxyXFxuICBcXHJcXG4gIC5hbnQtbW9kYWwtdGl0bGUge1xcclxcbiAgICBjb2xvcjogd2hpdGUgIWltcG9ydGFudDtcXHJcXG4gICAgcGFkZGluZy10b3A6IDE3cHggIWltcG9ydGFudDtcXHJcXG4gICAgbWFyZ2luLWxlZnQ6IDIwcHggIWltcG9ydGFudDtcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLmFudC1tb2RhbC1jbG9zZS1pY29uIHtcXHJcXG4gICAgY29sb3I6ICMzNjNlNTQgIWltcG9ydGFudDtcXHJcXG4gICAgdHJhbnNpdGlvbjogMC4zcztcXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgLmFudC1tb2RhbC1jbG9zZS1pY29uOmhvdmVyIHtcXHJcXG4gICAgY29sb3I6IHdoaXRlICFpbXBvcnRhbnQ7XFxyXFxuICB9XCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./pages/index.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./styles/globals.css":
/*!********************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./styles/globals.css ***!
  \********************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/*\\n! tailwindcss v3.1.8 | MIT License | https://tailwindcss.com\\n*//*\\n1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)\\n2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)\\n*/\\n\\n*,\\n::before,\\n::after {\\n  box-sizing: border-box; /* 1 */\\n  border-width: 0; /* 2 */\\n  border-style: solid; /* 2 */\\n  border-color: #e5e7eb; /* 2 */\\n}\\n\\n::before,\\n::after {\\n  --tw-content: '';\\n}\\n\\n/*\\n1. Use a consistent sensible line-height in all browsers.\\n2. Prevent adjustments of font size after orientation changes in iOS.\\n3. Use a more readable tab size.\\n4. Use the user's configured `sans` font-family by default.\\n*/\\n\\nhtml {\\n  line-height: 1.5; /* 1 */\\n  -webkit-text-size-adjust: 100%; /* 2 */\\n  -moz-tab-size: 4; /* 3 */\\n  -o-tab-size: 4;\\n     tab-size: 4; /* 3 */\\n  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, \\\"Helvetica Neue\\\", Arial, \\\"Noto Sans\\\", sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\", \\\"Noto Color Emoji\\\"; /* 4 */\\n}\\n\\n/*\\n1. Remove the margin in all browsers.\\n2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.\\n*/\\n\\nbody {\\n  margin: 0; /* 1 */\\n  line-height: inherit; /* 2 */\\n}\\n\\n/*\\n1. Add the correct height in Firefox.\\n2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\\n3. Ensure horizontal rules are visible by default.\\n*/\\n\\nhr {\\n  height: 0; /* 1 */\\n  color: inherit; /* 2 */\\n  border-top-width: 1px; /* 3 */\\n}\\n\\n/*\\nAdd the correct text decoration in Chrome, Edge, and Safari.\\n*/\\n\\nabbr:where([title]) {\\n  -webkit-text-decoration: underline dotted;\\n          text-decoration: underline dotted;\\n}\\n\\n/*\\nRemove the default font size and weight for headings.\\n*/\\n\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6 {\\n  font-size: inherit;\\n  font-weight: inherit;\\n}\\n\\n/*\\nReset links to optimize for opt-in styling instead of opt-out.\\n*/\\n\\na {\\n  color: inherit;\\n  text-decoration: inherit;\\n}\\n\\n/*\\nAdd the correct font weight in Edge and Safari.\\n*/\\n\\nb,\\nstrong {\\n  font-weight: bolder;\\n}\\n\\n/*\\n1. Use the user's configured `mono` font family by default.\\n2. Correct the odd `em` font sizing in all browsers.\\n*/\\n\\ncode,\\nkbd,\\nsamp,\\npre {\\n  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \\\"Liberation Mono\\\", \\\"Courier New\\\", monospace; /* 1 */\\n  font-size: 1em; /* 2 */\\n}\\n\\n/*\\nAdd the correct font size in all browsers.\\n*/\\n\\nsmall {\\n  font-size: 80%;\\n}\\n\\n/*\\nPrevent `sub` and `sup` elements from affecting the line height in all browsers.\\n*/\\n\\nsub,\\nsup {\\n  font-size: 75%;\\n  line-height: 0;\\n  position: relative;\\n  vertical-align: baseline;\\n}\\n\\nsub {\\n  bottom: -0.25em;\\n}\\n\\nsup {\\n  top: -0.5em;\\n}\\n\\n/*\\n1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\\n2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\\n3. Remove gaps between table borders by default.\\n*/\\n\\ntable {\\n  text-indent: 0; /* 1 */\\n  border-color: inherit; /* 2 */\\n  border-collapse: collapse; /* 3 */\\n}\\n\\n/*\\n1. Change the font styles in all browsers.\\n2. Remove the margin in Firefox and Safari.\\n3. Remove default padding in all browsers.\\n*/\\n\\nbutton,\\ninput,\\noptgroup,\\nselect,\\ntextarea {\\n  font-family: inherit; /* 1 */\\n  font-size: 100%; /* 1 */\\n  font-weight: inherit; /* 1 */\\n  line-height: inherit; /* 1 */\\n  color: inherit; /* 1 */\\n  margin: 0; /* 2 */\\n  padding: 0; /* 3 */\\n}\\n\\n/*\\nRemove the inheritance of text transform in Edge and Firefox.\\n*/\\n\\nbutton,\\nselect {\\n  text-transform: none;\\n}\\n\\n/*\\n1. Correct the inability to style clickable types in iOS and Safari.\\n2. Remove default button styles.\\n*/\\n\\nbutton,\\n[type='button'],\\n[type='reset'],\\n[type='submit'] {\\n  -webkit-appearance: button; /* 1 */\\n  background-color: transparent; /* 2 */\\n  background-image: none; /* 2 */\\n}\\n\\n/*\\nUse the modern Firefox focus style for all focusable elements.\\n*/\\n\\n:-moz-focusring {\\n  outline: auto;\\n}\\n\\n/*\\nRemove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)\\n*/\\n\\n:-moz-ui-invalid {\\n  box-shadow: none;\\n}\\n\\n/*\\nAdd the correct vertical alignment in Chrome and Firefox.\\n*/\\n\\nprogress {\\n  vertical-align: baseline;\\n}\\n\\n/*\\nCorrect the cursor style of increment and decrement buttons in Safari.\\n*/\\n\\n::-webkit-inner-spin-button,\\n::-webkit-outer-spin-button {\\n  height: auto;\\n}\\n\\n/*\\n1. Correct the odd appearance in Chrome and Safari.\\n2. Correct the outline style in Safari.\\n*/\\n\\n[type='search'] {\\n  -webkit-appearance: textfield; /* 1 */\\n  outline-offset: -2px; /* 2 */\\n}\\n\\n/*\\nRemove the inner padding in Chrome and Safari on macOS.\\n*/\\n\\n::-webkit-search-decoration {\\n  -webkit-appearance: none;\\n}\\n\\n/*\\n1. Correct the inability to style clickable types in iOS and Safari.\\n2. Change font properties to `inherit` in Safari.\\n*/\\n\\n::-webkit-file-upload-button {\\n  -webkit-appearance: button; /* 1 */\\n  font: inherit; /* 2 */\\n}\\n\\n/*\\nAdd the correct display in Chrome and Safari.\\n*/\\n\\nsummary {\\n  display: list-item;\\n}\\n\\n/*\\nRemoves the default spacing and border for appropriate elements.\\n*/\\n\\nblockquote,\\ndl,\\ndd,\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6,\\nhr,\\nfigure,\\np,\\npre {\\n  margin: 0;\\n}\\n\\nfieldset {\\n  margin: 0;\\n  padding: 0;\\n}\\n\\nlegend {\\n  padding: 0;\\n}\\n\\nol,\\nul,\\nmenu {\\n  list-style: none;\\n  margin: 0;\\n  padding: 0;\\n}\\n\\n/*\\nPrevent resizing textareas horizontally by default.\\n*/\\n\\ntextarea {\\n  resize: vertical;\\n}\\n\\n/*\\n1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)\\n2. Set the default placeholder color to the user's configured gray 400 color.\\n*/\\n\\ninput::-moz-placeholder, textarea::-moz-placeholder {\\n  opacity: 1; /* 1 */\\n  color: #9ca3af; /* 2 */\\n}\\n\\ninput::placeholder,\\ntextarea::placeholder {\\n  opacity: 1; /* 1 */\\n  color: #9ca3af; /* 2 */\\n}\\n\\n/*\\nSet the default cursor for buttons.\\n*/\\n\\nbutton,\\n[role=\\\"button\\\"] {\\n  cursor: pointer;\\n}\\n\\n/*\\nMake sure disabled buttons don't get the pointer cursor.\\n*/\\n:disabled {\\n  cursor: default;\\n}\\n\\n/*\\n1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)\\n2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)\\n   This can trigger a poorly considered lint error in some tools but is included by design.\\n*/\\n\\nimg,\\nsvg,\\nvideo,\\ncanvas,\\naudio,\\niframe,\\nembed,\\nobject {\\n  display: block; /* 1 */\\n  vertical-align: middle; /* 2 */\\n}\\n\\n/*\\nConstrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)\\n*/\\n\\nimg,\\nvideo {\\n  max-width: 100%;\\n  height: auto;\\n}\\n\\n*, ::before, ::after {\\n  --tw-border-spacing-x: 0;\\n  --tw-border-spacing-y: 0;\\n  --tw-translate-x: 0;\\n  --tw-translate-y: 0;\\n  --tw-rotate: 0;\\n  --tw-skew-x: 0;\\n  --tw-skew-y: 0;\\n  --tw-scale-x: 1;\\n  --tw-scale-y: 1;\\n  --tw-pan-x:  ;\\n  --tw-pan-y:  ;\\n  --tw-pinch-zoom:  ;\\n  --tw-scroll-snap-strictness: proximity;\\n  --tw-ordinal:  ;\\n  --tw-slashed-zero:  ;\\n  --tw-numeric-figure:  ;\\n  --tw-numeric-spacing:  ;\\n  --tw-numeric-fraction:  ;\\n  --tw-ring-inset:  ;\\n  --tw-ring-offset-width: 0px;\\n  --tw-ring-offset-color: #fff;\\n  --tw-ring-color: rgb(59 130 246 / 0.5);\\n  --tw-ring-offset-shadow: 0 0 #0000;\\n  --tw-ring-shadow: 0 0 #0000;\\n  --tw-shadow: 0 0 #0000;\\n  --tw-shadow-colored: 0 0 #0000;\\n  --tw-blur:  ;\\n  --tw-brightness:  ;\\n  --tw-contrast:  ;\\n  --tw-grayscale:  ;\\n  --tw-hue-rotate:  ;\\n  --tw-invert:  ;\\n  --tw-saturate:  ;\\n  --tw-sepia:  ;\\n  --tw-drop-shadow:  ;\\n  --tw-backdrop-blur:  ;\\n  --tw-backdrop-brightness:  ;\\n  --tw-backdrop-contrast:  ;\\n  --tw-backdrop-grayscale:  ;\\n  --tw-backdrop-hue-rotate:  ;\\n  --tw-backdrop-invert:  ;\\n  --tw-backdrop-opacity:  ;\\n  --tw-backdrop-saturate:  ;\\n  --tw-backdrop-sepia:  ;\\n}\\n\\n::backdrop {\\n  --tw-border-spacing-x: 0;\\n  --tw-border-spacing-y: 0;\\n  --tw-translate-x: 0;\\n  --tw-translate-y: 0;\\n  --tw-rotate: 0;\\n  --tw-skew-x: 0;\\n  --tw-skew-y: 0;\\n  --tw-scale-x: 1;\\n  --tw-scale-y: 1;\\n  --tw-pan-x:  ;\\n  --tw-pan-y:  ;\\n  --tw-pinch-zoom:  ;\\n  --tw-scroll-snap-strictness: proximity;\\n  --tw-ordinal:  ;\\n  --tw-slashed-zero:  ;\\n  --tw-numeric-figure:  ;\\n  --tw-numeric-spacing:  ;\\n  --tw-numeric-fraction:  ;\\n  --tw-ring-inset:  ;\\n  --tw-ring-offset-width: 0px;\\n  --tw-ring-offset-color: #fff;\\n  --tw-ring-color: rgb(59 130 246 / 0.5);\\n  --tw-ring-offset-shadow: 0 0 #0000;\\n  --tw-ring-shadow: 0 0 #0000;\\n  --tw-shadow: 0 0 #0000;\\n  --tw-shadow-colored: 0 0 #0000;\\n  --tw-blur:  ;\\n  --tw-brightness:  ;\\n  --tw-contrast:  ;\\n  --tw-grayscale:  ;\\n  --tw-hue-rotate:  ;\\n  --tw-invert:  ;\\n  --tw-saturate:  ;\\n  --tw-sepia:  ;\\n  --tw-drop-shadow:  ;\\n  --tw-backdrop-blur:  ;\\n  --tw-backdrop-brightness:  ;\\n  --tw-backdrop-contrast:  ;\\n  --tw-backdrop-grayscale:  ;\\n  --tw-backdrop-hue-rotate:  ;\\n  --tw-backdrop-invert:  ;\\n  --tw-backdrop-opacity:  ;\\n  --tw-backdrop-saturate:  ;\\n  --tw-backdrop-sepia:  ;\\n}\\r\\n.container {\\n  width: 100%;\\n}\\r\\n@media (min-width: 640px) {\\n\\n  .container {\\n    max-width: 640px;\\n  }\\n}\\r\\n@media (min-width: 768px) {\\n\\n  .container {\\n    max-width: 768px;\\n  }\\n}\\r\\n@media (min-width: 1024px) {\\n\\n  .container {\\n    max-width: 1024px;\\n  }\\n}\\r\\n@media (min-width: 1280px) {\\n\\n  .container {\\n    max-width: 1280px;\\n  }\\n}\\r\\n@media (min-width: 1536px) {\\n\\n  .container {\\n    max-width: 1536px;\\n  }\\n}\\r\\n.visible {\\n  visibility: visible;\\n}\\r\\n.fixed {\\n  position: fixed;\\n}\\r\\n.absolute {\\n  position: absolute;\\n}\\r\\n.relative {\\n  position: relative;\\n}\\r\\n.bottom-5 {\\n  bottom: 1.25rem;\\n}\\r\\n.right-0 {\\n  right: 0px;\\n}\\r\\n.top-1 {\\n  top: 0.25rem;\\n}\\r\\n.top-0 {\\n  top: 0px;\\n}\\r\\n.left-0 {\\n  left: 0px;\\n}\\r\\n.z-10 {\\n  z-index: 10;\\n}\\r\\n.m-auto {\\n  margin: auto;\\n}\\r\\n.mx-\\\\[10px\\\\] {\\n  margin-left: 10px;\\n  margin-right: 10px;\\n}\\r\\n.mx-auto {\\n  margin-left: auto;\\n  margin-right: auto;\\n}\\r\\n.my-10 {\\n  margin-top: 2.5rem;\\n  margin-bottom: 2.5rem;\\n}\\r\\n.my-4 {\\n  margin-top: 1rem;\\n  margin-bottom: 1rem;\\n}\\r\\n.my-3 {\\n  margin-top: 0.75rem;\\n  margin-bottom: 0.75rem;\\n}\\r\\n.mx-5 {\\n  margin-left: 1.25rem;\\n  margin-right: 1.25rem;\\n}\\r\\n.mt-10 {\\n  margin-top: 2.5rem;\\n}\\r\\n.mt-20 {\\n  margin-top: 5rem;\\n}\\r\\n.mb-2 {\\n  margin-bottom: 0.5rem;\\n}\\r\\n.mr-2 {\\n  margin-right: 0.5rem;\\n}\\r\\n.ml-5 {\\n  margin-left: 1.25rem;\\n}\\r\\n.mr-10 {\\n  margin-right: 2.5rem;\\n}\\r\\n.ml-1 {\\n  margin-left: 0.25rem;\\n}\\r\\n.mb-6 {\\n  margin-bottom: 1.5rem;\\n}\\r\\n.ml-2 {\\n  margin-left: 0.5rem;\\n}\\r\\n.mt-2 {\\n  margin-top: 0.5rem;\\n}\\r\\n.ml-3 {\\n  margin-left: 0.75rem;\\n}\\r\\n.mt-3 {\\n  margin-top: 0.75rem;\\n}\\r\\n.mr-3 {\\n  margin-right: 0.75rem;\\n}\\r\\n.mb-3 {\\n  margin-bottom: 0.75rem;\\n}\\r\\n.ml-10 {\\n  margin-left: 2.5rem;\\n}\\r\\n.-ml-16 {\\n  margin-left: -4rem;\\n}\\r\\n.mr-1 {\\n  margin-right: 0.25rem;\\n}\\r\\n.mr-5 {\\n  margin-right: 1.25rem;\\n}\\r\\n.mt-5 {\\n  margin-top: 1.25rem;\\n}\\r\\n.mb-5 {\\n  margin-bottom: 1.25rem;\\n}\\r\\n.mb-4 {\\n  margin-bottom: 1rem;\\n}\\r\\n.block {\\n  display: block;\\n}\\r\\n.inline-block {\\n  display: inline-block;\\n}\\r\\n.flex {\\n  display: flex;\\n}\\r\\n.table {\\n  display: table;\\n}\\r\\n.grid {\\n  display: grid;\\n}\\r\\n.h-min {\\n  height: -moz-min-content;\\n  height: min-content;\\n}\\r\\n.h-1 {\\n  height: 0.25rem;\\n}\\r\\n.h-screen {\\n  height: 100vh;\\n}\\r\\n.min-h-screen {\\n  min-height: 100vh;\\n}\\r\\n.w-1\\\\/5 {\\n  width: 20%;\\n}\\r\\n.w-full {\\n  width: 100%;\\n}\\r\\n.w-2\\\\/3 {\\n  width: 66.666667%;\\n}\\r\\n.w-fit {\\n  width: -moz-fit-content;\\n  width: fit-content;\\n}\\r\\n.w-1 {\\n  width: 0.25rem;\\n}\\r\\n.w-min {\\n  width: -moz-min-content;\\n  width: min-content;\\n}\\r\\n.w-screen {\\n  width: 100vw;\\n}\\r\\n.w-max {\\n  width: -moz-max-content;\\n  width: max-content;\\n}\\r\\n.w-1\\\\/3 {\\n  width: 33.333333%;\\n}\\r\\n.min-w-full {\\n  min-width: 100%;\\n}\\r\\n.max-w-sm {\\n  max-width: 24rem;\\n}\\r\\n.max-w-screen-2xl {\\n  max-width: 1536px;\\n}\\r\\n.max-w-lg {\\n  max-width: 32rem;\\n}\\r\\n.max-w-screen-xl {\\n  max-width: 1280px;\\n}\\r\\n.transform {\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\n}\\r\\n.cursor-pointer {\\n  cursor: pointer;\\n}\\r\\n.grid-cols-1 {\\n  grid-template-columns: repeat(1, minmax(0, 1fr));\\n}\\r\\n.flex-col {\\n  flex-direction: column;\\n}\\r\\n.flex-wrap {\\n  flex-wrap: wrap;\\n}\\r\\n.items-start {\\n  align-items: flex-start;\\n}\\r\\n.items-center {\\n  align-items: center;\\n}\\r\\n.justify-end {\\n  justify-content: flex-end;\\n}\\r\\n.justify-center {\\n  justify-content: center;\\n}\\r\\n.justify-between {\\n  justify-content: space-between;\\n}\\r\\n.gap-5 {\\n  gap: 1.25rem;\\n}\\r\\n.gap-\\\\[20px\\\\] {\\n  gap: 20px;\\n}\\r\\n.gap-\\\\[100px\\\\] {\\n  gap: 100px;\\n}\\r\\n.overflow-hidden {\\n  overflow: hidden;\\n}\\r\\n.whitespace-nowrap {\\n  white-space: nowrap;\\n}\\r\\n.rounded {\\n  border-radius: 0.25rem;\\n}\\r\\n.rounded-2xl {\\n  border-radius: 1rem;\\n}\\r\\n.rounded-lg {\\n  border-radius: 0.5rem;\\n}\\r\\n.rounded-xl {\\n  border-radius: 0.75rem;\\n}\\r\\n.rounded-full {\\n  border-radius: 9999px;\\n}\\r\\n.rounded-md {\\n  border-radius: 0.375rem;\\n}\\r\\n.border {\\n  border-width: 1px;\\n}\\r\\n.border-b {\\n  border-bottom-width: 1px;\\n}\\r\\n.border-l {\\n  border-left-width: 1px;\\n}\\r\\n.border-t {\\n  border-top-width: 1px;\\n}\\r\\n.border-gray-500\\\\/10 {\\n  border-color: rgb(107 114 128 / 0.1);\\n}\\r\\n.border-green-600 {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(22 163 74 / var(--tw-border-opacity));\\n}\\r\\n.border-red-600 {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(220 38 38 / var(--tw-border-opacity));\\n}\\r\\n.border-gray-700 {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(55 65 81 / var(--tw-border-opacity));\\n}\\r\\n.border-gray-800 {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(31 41 55 / var(--tw-border-opacity));\\n}\\r\\n.border-gray-600\\\\/50 {\\n  border-color: rgb(75 85 99 / 0.5);\\n}\\r\\n.bg-cyan-600 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(8 145 178 / var(--tw-bg-opacity));\\n}\\r\\n.bg-\\\\[\\\\#171924\\\\] {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(23 25 36 / var(--tw-bg-opacity));\\n}\\r\\n.bg-\\\\[\\\\#222531\\\\] {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(34 37 49 / var(--tw-bg-opacity));\\n}\\r\\n.bg-\\\\[\\\\#6188FF\\\\] {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(97 136 255 / var(--tw-bg-opacity));\\n}\\r\\n.bg-\\\\[\\\\#323546\\\\] {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(50 53 70 / var(--tw-bg-opacity));\\n}\\r\\n.bg-green-600 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(22 163 74 / var(--tw-bg-opacity));\\n}\\r\\n.bg-red-500 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(239 68 68 / var(--tw-bg-opacity));\\n}\\r\\n.bg-slate-800 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(30 41 59 / var(--tw-bg-opacity));\\n}\\r\\n.bg-\\\\[\\\\#1A1F3A\\\\] {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(26 31 58 / var(--tw-bg-opacity));\\n}\\r\\n.bg-blue-600 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(37 99 235 / var(--tw-bg-opacity));\\n}\\r\\n.bg-\\\\[\\\\#17171A\\\\] {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(23 23 26 / var(--tw-bg-opacity));\\n}\\r\\n.bg-transparent {\\n  background-color: transparent;\\n}\\r\\n.bg-black {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(0 0 0 / var(--tw-bg-opacity));\\n}\\r\\n.bg-blue-500 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(59 130 246 / var(--tw-bg-opacity));\\n}\\r\\n.bg-\\\\[\\\\#1d4ed8\\\\] {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(29 78 216 / var(--tw-bg-opacity));\\n}\\r\\n.bg-gray-900\\\\/90 {\\n  background-color: rgb(17 24 39 / 0.9);\\n}\\r\\n.bg-white {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(255 255 255 / var(--tw-bg-opacity));\\n}\\r\\n.bg-blue-700 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(29 78 216 / var(--tw-bg-opacity));\\n}\\r\\n.to-cyan-300 {\\n  --tw-gradient-to: #67e8f9;\\n}\\r\\n.p-10 {\\n  padding: 2.5rem;\\n}\\r\\n.p-1 {\\n  padding: 0.25rem;\\n}\\r\\n.p-2 {\\n  padding: 0.5rem;\\n}\\r\\n.p-4 {\\n  padding: 1rem;\\n}\\r\\n.p-5 {\\n  padding: 1.25rem;\\n}\\r\\n.p-\\\\[30px\\\\] {\\n  padding: 30px;\\n}\\r\\n.p-3 {\\n  padding: 0.75rem;\\n}\\r\\n.px-6 {\\n  padding-left: 1.5rem;\\n  padding-right: 1.5rem;\\n}\\r\\n.py-2\\\\.5 {\\n  padding-top: 0.625rem;\\n  padding-bottom: 0.625rem;\\n}\\r\\n.py-2 {\\n  padding-top: 0.5rem;\\n  padding-bottom: 0.5rem;\\n}\\r\\n.py-4 {\\n  padding-top: 1rem;\\n  padding-bottom: 1rem;\\n}\\r\\n.px-2 {\\n  padding-left: 0.5rem;\\n  padding-right: 0.5rem;\\n}\\r\\n.px-5 {\\n  padding-left: 1.25rem;\\n  padding-right: 1.25rem;\\n}\\r\\n.px-3 {\\n  padding-left: 0.75rem;\\n  padding-right: 0.75rem;\\n}\\r\\n.py-1 {\\n  padding-top: 0.25rem;\\n  padding-bottom: 0.25rem;\\n}\\r\\n.px-4 {\\n  padding-left: 1rem;\\n  padding-right: 1rem;\\n}\\r\\n.px-10 {\\n  padding-left: 2.5rem;\\n  padding-right: 2.5rem;\\n}\\r\\n.py-5 {\\n  padding-top: 1.25rem;\\n  padding-bottom: 1.25rem;\\n}\\r\\n.py-3 {\\n  padding-top: 0.75rem;\\n  padding-bottom: 0.75rem;\\n}\\r\\n.pt-10 {\\n  padding-top: 2.5rem;\\n}\\r\\n.pt-5 {\\n  padding-top: 1.25rem;\\n}\\r\\n.pb-0 {\\n  padding-bottom: 0px;\\n}\\r\\n.pl-0 {\\n  padding-left: 0px;\\n}\\r\\n.pr-0 {\\n  padding-right: 0px;\\n}\\r\\n.pb-6 {\\n  padding-bottom: 1.5rem;\\n}\\r\\n.pl-5 {\\n  padding-left: 1.25rem;\\n}\\r\\n.pt-20 {\\n  padding-top: 5rem;\\n}\\r\\n.pl-1 {\\n  padding-left: 0.25rem;\\n}\\r\\n.text-left {\\n  text-align: left;\\n}\\r\\n.text-center {\\n  text-align: center;\\n}\\r\\n.text-5xl {\\n  font-size: 3rem;\\n  line-height: 1;\\n}\\r\\n.text-xs {\\n  font-size: 0.75rem;\\n  line-height: 1rem;\\n}\\r\\n.text-xl {\\n  font-size: 1.25rem;\\n  line-height: 1.75rem;\\n}\\r\\n.text-base {\\n  font-size: 1rem;\\n  line-height: 1.5rem;\\n}\\r\\n.text-sm {\\n  font-size: 0.875rem;\\n  line-height: 1.25rem;\\n}\\r\\n.text-3xl {\\n  font-size: 1.875rem;\\n  line-height: 2.25rem;\\n}\\r\\n.text-4xl {\\n  font-size: 2.25rem;\\n  line-height: 2.5rem;\\n}\\r\\n.text-2xl {\\n  font-size: 1.5rem;\\n  line-height: 2rem;\\n}\\r\\n.text-\\\\[0\\\\.93rem\\\\] {\\n  font-size: 0.93rem;\\n}\\r\\n.font-medium {\\n  font-weight: 500;\\n}\\r\\n.font-bold {\\n  font-weight: 700;\\n}\\r\\n.uppercase {\\n  text-transform: uppercase;\\n}\\r\\n.leading-tight {\\n  line-height: 1.25;\\n}\\r\\n.text-white {\\n  --tw-text-opacity: 1;\\n  color: rgb(255 255 255 / var(--tw-text-opacity));\\n}\\r\\n.text-red-300 {\\n  --tw-text-opacity: 1;\\n  color: rgb(252 165 165 / var(--tw-text-opacity));\\n}\\r\\n.text-cyan-300 {\\n  --tw-text-opacity: 1;\\n  color: rgb(103 232 249 / var(--tw-text-opacity));\\n}\\r\\n.text-\\\\[\\\\#6188FF\\\\] {\\n  --tw-text-opacity: 1;\\n  color: rgb(97 136 255 / var(--tw-text-opacity));\\n}\\r\\n.text-green-600 {\\n  --tw-text-opacity: 1;\\n  color: rgb(22 163 74 / var(--tw-text-opacity));\\n}\\r\\n.text-\\\\[\\\\#EA3943\\\\] {\\n  --tw-text-opacity: 1;\\n  color: rgb(234 57 67 / var(--tw-text-opacity));\\n}\\r\\n.text-gray-400 {\\n  --tw-text-opacity: 1;\\n  color: rgb(156 163 175 / var(--tw-text-opacity));\\n}\\r\\n.text-red-500 {\\n  --tw-text-opacity: 1;\\n  color: rgb(239 68 68 / var(--tw-text-opacity));\\n}\\r\\n.text-gray-600 {\\n  --tw-text-opacity: 1;\\n  color: rgb(75 85 99 / var(--tw-text-opacity));\\n}\\r\\n.text-\\\\[\\\\#17C784\\\\] {\\n  --tw-text-opacity: 1;\\n  color: rgb(23 199 132 / var(--tw-text-opacity));\\n}\\r\\n.underline {\\n  -webkit-text-decoration-line: underline;\\n          text-decoration-line: underline;\\n}\\r\\n.opacity-40 {\\n  opacity: 0.4;\\n}\\r\\n.shadow-lg {\\n  --tw-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);\\n  --tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\n}\\r\\n.outline-none {\\n  outline: 2px solid transparent;\\n  outline-offset: 2px;\\n}\\r\\n.ring-4 {\\n  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);\\n  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(4px + var(--tw-ring-offset-width)) var(--tw-ring-color);\\n  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);\\n}\\r\\n.blur {\\n  --tw-blur: blur(8px);\\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\\n}\\r\\n.filter {\\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\\n}\\r\\n.transition {\\n  transition-property: color, background-color, border-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-text-decoration-color, -webkit-backdrop-filter;\\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;\\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-text-decoration-color, -webkit-backdrop-filter;\\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\n  transition-duration: 150ms;\\n}\\r\\n.duration-150 {\\n  transition-duration: 150ms;\\n}\\r\\n.ease-in-out {\\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\n}\\r\\n\\r\\n/* @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@100;200;300;400;500;600;700;800;900&display=swap'); */\\r\\n/* @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@300;400;500;600;700&display=swap'); */\\r\\n\\r\\nbody {\\r\\n  background: linear-gradient(to bottom, #0a0b0c, #000000);\\r\\n  height: 100%;\\r\\n  width: 100vw;\\r\\n}\\r\\n\\r\\n/*\\r\\n* {\\r\\n  font-family: 'Fredoka', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,\\r\\n    Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\\r\\n  box-sizing: border-box;\\r\\n  list-style: none;\\r\\n  text-decoration: none;\\r\\n  padding: 0;\\r\\n  margin: 0;\\r\\n  outline: none;\\r\\n  border: none;\\r\\n}\\r\\n\\r\\nbody {\\r\\n  min-height: 100vh;\\r\\n  background: linear-gradient(to bottom, #1f222b, #17171a);\\r\\n  font-size: 0.97rem;\\r\\n  color: #fff;\\r\\n}\\r\\n\\r\\na {\\r\\n  user-select: none;\\r\\n}\\r\\n\\r\\n:root {\\r\\n  --header-bg: #17171a;\\r\\n  --primary-color: #3861fb;\\r\\n  --search-box-bg: #181924;\\r\\n  --green: #16c784;\\r\\n  --red: #ea3943;\\r\\n  --table-height: 80px;\\r\\n  --trending-item-bg: #323546;\\r\\n  --cmc-chat-bg: #222531;\\r\\n  overflow-x: hidden;\\r\\n}\\r\\n\\r\\n.header {\\r\\n  background: var(--header-bg);\\r\\n  color: #fff;\\r\\n  height: 80px;\\r\\n}\\r\\n\\r\\n.header-wrapper,\\r\\n.cmc-table-wrapper,\\r\\n.cmc-trending-wrapper,\\r\\nmain {\\r\\n  margin: auto;\\r\\n  max-width: 1300px;\\r\\n}\\r\\n\\r\\n.header-wrapper {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: space-between;\\r\\n  height: 100%;\\r\\n}\\r\\n\\r\\n.header nav {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: space-between;\\r\\n}\\r\\n\\r\\n.header nav a {\\r\\n  color: #fff;\\r\\n  padding: 16px;\\r\\n}\\r\\n\\r\\n.header nav a:hover {\\r\\n  color: var(--primary-color);\\r\\n}\\r\\n\\r\\n.header .nav-item {\\r\\n  position: relative;\\r\\n  font-weight: 500;\\r\\n}\\r\\n\\r\\n.header .nav-item .nav-badge {\\r\\n  background: var(--primary-color);\\r\\n  border-radius: 100px;\\r\\n  box-shadow: 0 0 7px 3px #0027ff;\\r\\n  height: 5px;\\r\\n  width: 5px;\\r\\n  position: absolute;\\r\\n  top: 0;\\r\\n  right: 5px;\\r\\n}\\r\\n\\r\\n.header .right-content .btn {\\r\\n  margin: 15px;\\r\\n}\\r\\n\\r\\n.header .right-content a {\\r\\n  margin-left: 15px;\\r\\n  color: #fff;\\r\\n  display: block;\\r\\n}\\r\\n\\r\\n.btn {\\r\\n  background: var(--primary-color);\\r\\n  border: none;\\r\\n  padding: 11px 22px;\\r\\n  border-radius: 10px;\\r\\n  color: #fff;\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.search-box {\\r\\n  background: var(--search-box-bg);\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: center;\\r\\n  padding: 7px 10px;\\r\\n  border-radius: 10px;\\r\\n}\\r\\n\\r\\n.search-box input {\\r\\n  background: transparent;\\r\\n  color: #fff;\\r\\n  width: 100px;\\r\\n}\\r\\n\\r\\n.search-box ::placeholder {\\r\\n  color: #474c5d;\\r\\n  margin-right: 30px;\\r\\n}\\r\\n\\r\\n.search-box svg {\\r\\n  width: 20px;\\r\\n  height: 20px;\\r\\n  margin-right: 10px;\\r\\n}\\r\\n\\r\\n.search-slash-btn {\\r\\n  background: #7d8395;\\r\\n  color: #fff;\\r\\n  border-radius: 6px;\\r\\n  width: 30px;\\r\\n  height: 30px;\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: center;\\r\\n  font-size: 14px;\\r\\n}\\r\\n\\r\\n.flex {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: center;\\r\\n}\\r\\n\\r\\n.flex-between {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: space-between;\\r\\n}\\r\\n\\r\\n.text-btn {\\r\\n  user-select: none;\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.flex-start {\\r\\n  display: flex;\\r\\n}\\r\\n\\r\\ntable {\\r\\n  color: #fff;\\r\\n  width: 100%;\\r\\n  text-align: left;\\r\\n  border-collapse: collapse;\\r\\n}\\r\\n\\r\\ntr {\\r\\n  height: var(--table-height);\\r\\n  border-bottom: 1px solid #7d83951c;\\r\\n  padding-left: 20px;\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.table-row:hover {\\r\\n  background: #191a1f;\\r\\n}\\r\\n\\r\\n.table-title p {\\r\\n  margin-right: 5px;\\r\\n}\\r\\n\\r\\ntable tr td:last-child {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  height: var(--table-height);\\r\\n  margin-left: -70px;\\r\\n}\\r\\n\\r\\ntable .circulating-supply-value {\\r\\n  position: relative;\\r\\n  right: -100px;\\r\\n}\\r\\n\\r\\ntable .volume-value {\\r\\n  position: relative;\\r\\n  right: 40px;\\r\\n  text-align: right;\\r\\n}\\r\\n\\r\\ntable .market-cap-value {\\r\\n  position: relative;\\r\\n  right: -40px;\\r\\n}\\r\\n\\r\\ntable .volume-value .coin-crypto-value {\\r\\n  font-size: 13px;\\r\\n  margin-top: 3px;\\r\\n}\\r\\n\\r\\ntable .buy-label {\\r\\n  background: #1a2033;\\r\\n  color: #5c81f1;\\r\\n  padding: 7px 9px;\\r\\n  border-radius: 7px;\\r\\n  font-size: 12px;\\r\\n}\\r\\n\\r\\n.fade-text {\\r\\n  opacity: 0.5;\\r\\n}\\r\\n\\r\\n.rate {\\r\\n  width: min-content;\\r\\n}\\r\\n\\r\\n.rate p {\\r\\n  margin-left: 10px;\\r\\n}\\r\\n\\r\\n.increment-rate {\\r\\n  color: var(--green);\\r\\n}\\r\\n\\r\\n.increment-rate svg {\\r\\n  fill: var(--green);\\r\\n}\\r\\n\\r\\n.decrement-rate {\\r\\n  color: var(--red);\\r\\n}\\r\\n\\r\\n.decrement-rate svg {\\r\\n  fill: var(--red);\\r\\n}\\r\\n\\r\\n.increment-rate svg,\\r\\n.decrement-rate svg {\\r\\n  margin-right: -5px;\\r\\n}\\r\\n\\r\\ntd .flex {\\r\\n  justify-content: flex-start;\\r\\n}\\r\\n\\r\\ntd .flex p {\\r\\n  margin-left: 10px;\\r\\n}\\r\\n\\r\\n.underline {\\r\\n  text-decoration: underline;\\r\\n}\\r\\n\\r\\n.trending-cards-container {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n}\\r\\n\\r\\n.trending-card {\\r\\n  width: 100%;\\r\\n  margin-left: 20px;\\r\\n  background: var(--trending-item-bg);\\r\\n  padding: 20px;\\r\\n  border-radius: 10px;\\r\\n  color: #fff;\\r\\n}\\r\\n\\r\\n.trending-card:first-child {\\r\\n  margin-left: 0;\\r\\n}\\r\\n\\r\\n.trending-more-btn {\\r\\n  color: var(--primary-color);\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: space-between;\\r\\n  width: min-content;\\r\\n  white-space: nowrap;\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.trending-card-row {\\r\\n  margin-bottom: 20px;\\r\\n}\\r\\n\\r\\n.trending-card-row:last-child {\\r\\n  margin-bottom: 0;\\r\\n}\\r\\n\\r\\n.trending-crypto-name-icon {\\r\\n  width: 100%;\\r\\n  display: flex;\\r\\n  padding-left: 20px;\\r\\n}\\r\\n\\r\\n.trending-crypto-name-icon p {\\r\\n  margin-left: 20px;\\r\\n}\\r\\n\\r\\n.trending-more-btn svg {\\r\\n  fill: var(--primary-color);\\r\\n}\\r\\n\\r\\n.switch {\\r\\n  position: relative;\\r\\n  display: inline-block;\\r\\n  width: 60px;\\r\\n  height: 34px;\\r\\n}\\r\\n\\r\\n.switch input {\\r\\n  opacity: 0;\\r\\n  width: 0;\\r\\n  height: 0;\\r\\n}\\r\\n\\r\\n.slider {\\r\\n  position: absolute;\\r\\n  cursor: pointer;\\r\\n  top: 0;\\r\\n  left: 0;\\r\\n  right: 0;\\r\\n  bottom: 0;\\r\\n  background-color: #ccc;\\r\\n  -webkit-transition: 0.4s;\\r\\n  transition: 0.4s;\\r\\n}\\r\\n\\r\\n.slider:before {\\r\\n  position: absolute;\\r\\n  content: '';\\r\\n  height: 26px;\\r\\n  width: 26px;\\r\\n  left: 4px;\\r\\n  bottom: 4px;\\r\\n  background-color: white;\\r\\n  -webkit-transition: 0.4s;\\r\\n  transition: 0.4s;\\r\\n}\\r\\n\\r\\ninput:checked + .slider {\\r\\n  background-color: #2196f3;\\r\\n}\\r\\n\\r\\ninput:focus + .slider {\\r\\n  box-shadow: 0 0 1px #2196f3;\\r\\n}\\r\\n\\r\\ninput:checked + .slider:before {\\r\\n  -webkit-transform: translateX(26px);\\r\\n  -ms-transform: translateX(26px);\\r\\n  transform: translateX(26px);\\r\\n}\\r\\n\\r\\n.slider.round {\\r\\n  border-radius: 34px;\\r\\n}\\r\\n\\r\\n.slider.round:before {\\r\\n  border-radius: 50%;\\r\\n}\\r\\n\\r\\n.modal {\\r\\n  width: 100vw;\\r\\n  height: 100vh;\\r\\n  background: #00000024;\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: center;\\r\\n  backdrop-filter: blur(28px);\\r\\n  position: fixed;\\r\\n  top: 0;\\r\\n  left: 0;\\r\\n  z-index: 100;\\r\\n}\\r\\n\\r\\n.wallet-selector {\\r\\n  background: var(--trending-item-bg);\\r\\n  width: 500px;\\r\\n  border-radius: 20px;\\r\\n}\\r\\n\\r\\n.wallet-item {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: center;\\r\\n  padding: 20px;\\r\\n  cursor: pointer;\\r\\n  border-bottom: 1px solid #a9abb517;\\r\\n  user-select: none;\\r\\n}\\r\\n\\r\\n.wallet-item:last-child {\\r\\n  border: none;\\r\\n}\\r\\n\\r\\n.wallet-item p {\\r\\n  margin-left: 20px;\\r\\n}\\r\\n\\r\\n.wallet-item:hover {\\r\\n  background: #17191e2e;\\r\\n}\\r\\n\\r\\n.cmc-chat-container {\\r\\n  width: 500px;\\r\\n}\\r\\n\\r\\n.cmc-chat {\\r\\n  background: var(--cmc-chat-bg);\\r\\n  padding: 20px;\\r\\n  border-radius: 10px;\\r\\n}\\r\\n\\r\\n.avatar-container {\\r\\n  border-radius: 100px;\\r\\n  width: 40px;\\r\\n  height: 40px;\\r\\n  overflow: hidden;\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: center;\\r\\n}\\r\\n\\r\\n.bullish-label svg {\\r\\n  fill: var(--green);\\r\\n}\\r\\n\\r\\n.bearish-label svg {\\r\\n  fill: var(--red);\\r\\n}\\r\\n\\r\\n.bullish-label,\\r\\n.bearish-label {\\r\\n  border: 1px solid #ffffff24;\\r\\n  border-radius: 5px;\\r\\n  padding: 2px 11px;\\r\\n  display: flex;\\r\\n  width: min-content;\\r\\n  align-items: center;\\r\\n}\\r\\n\\r\\n.bullish-label svg,\\r\\n.bearish-label svg {\\r\\n  margin-right: 7px;\\r\\n}\\r\\n\\r\\n.cmc-chat .input-box {\\r\\n  background: var(--trending-item-bg);\\r\\n  width: 100%;\\r\\n  padding: 17px;\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  border-radius: 10px;\\r\\n  margin: 25px 0;\\r\\n  color: var(--primary-color);\\r\\n}\\r\\n\\r\\n.cmc-chat .input-box input {\\r\\n  width: 100%;\\r\\n  height: 31px;\\r\\n  background: transparent;\\r\\n  padding: 10px;\\r\\n  color: #fff;\\r\\n  font-size: 17px;\\r\\n}\\r\\n\\r\\n.flex-horizontal-end {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: flex-end;\\r\\n}\\r\\n\\r\\n.text-align-left {\\r\\n  display: flex;\\r\\n  flex-direction: column;\\r\\n}\\r\\n\\r\\n.chat-user {\\r\\n  display: flex;\\r\\n  justify-content: center;\\r\\n  align-items: center;\\r\\n  justify-content: flex-start;\\r\\n}\\r\\n\\r\\n.chat-user .text-align-left {\\r\\n  margin-top: -17px;\\r\\n  margin-left: 10px;\\r\\n}\\r\\n\\r\\n.bullish-filled {\\r\\n  background: var(--green);\\r\\n}\\r\\n\\r\\n.bullish-filled svg,\\r\\n.bearish-filled svg {\\r\\n  fill: #fff;\\r\\n}\\r\\n\\r\\n.bearish-filled {\\r\\n  background: var(--red);\\r\\n}\\r\\n\\r\\n.chat-card {\\r\\n  margin-top: 20px;\\r\\n  padding-top: 50px;\\r\\n  border-top: 1px solid var(--trending-item-bg);\\r\\n}\\r\\n\\r\\n.chat-card .chat-user {\\r\\n  margin-bottom: 20px;\\r\\n}\\r\\n\\r\\n.chat-user-info {\\r\\n  width: 400px;\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: space-between;\\r\\n}\\r\\n\\r\\n.post-action {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  color: #61636e;\\r\\n}\\r\\n\\r\\n.post-action svg {\\r\\n  margin-right: 10px;\\r\\n}\\r\\n\\r\\n.post-actions-container {\\r\\n  margin-top: 20px;\\r\\n}\\r\\n\\r\\n.price-converter {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: space-between;\\r\\n  background: #171924;\\r\\n  padding: 24px 20px;\\r\\n  border-radius: 20px;\\r\\n  border: 1px solid #ffc8c80f;\\r\\n} */\\r\\n\\r\\n.hover\\\\:bg-cyan-600:hover {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(8 145 178 / var(--tw-bg-opacity));\\n}\\r\\n\\r\\n.hover\\\\:text-red-300:hover {\\n  --tw-text-opacity: 1;\\n  color: rgb(252 165 165 / var(--tw-text-opacity));\\n}\\r\\n\\r\\n.hover\\\\:opacity-50:hover {\\n  opacity: 0.5;\\n}\\r\\n\\r\\n.hover\\\\:opacity-60:hover {\\n  opacity: 0.6;\\n}\\r\\n\\r\\n.hover\\\\:shadow-lg:hover {\\n  --tw-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);\\n  --tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\n}\\r\\n\\r\\n.focus\\\\:bg-cyan-600:focus {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(8 145 178 / var(--tw-bg-opacity));\\n}\\r\\n\\r\\n.focus\\\\:shadow-lg:focus {\\n  --tw-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);\\n  --tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\n}\\r\\n\\r\\n.focus\\\\:outline-none:focus {\\n  outline: 2px solid transparent;\\n  outline-offset: 2px;\\n}\\r\\n\\r\\n.focus\\\\:ring-0:focus {\\n  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);\\n  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);\\n  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);\\n}\\r\\n\\r\\n.active\\\\:bg-red-300:active {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(252 165 165 / var(--tw-bg-opacity));\\n}\\r\\n\\r\\n.active\\\\:bg-green-600:active {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(22 163 74 / var(--tw-bg-opacity));\\n}\\r\\n\\r\\n.active\\\\:bg-red-500:active {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(239 68 68 / var(--tw-bg-opacity));\\n}\\r\\n\\r\\n.active\\\\:shadow-lg:active {\\n  --tw-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);\\n  --tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\n}\\r\\n\\r\\n@media (min-width: 640px) {\\n\\n  .sm\\\\:grid-cols-1 {\\n    grid-template-columns: repeat(1, minmax(0, 1fr));\\n  }\\n}\\r\\n\\r\\n@media (min-width: 768px) {\\n\\n  .md\\\\:grid-cols-3 {\\n    grid-template-columns: repeat(3, minmax(0, 1fr));\\n  }\\n}\\r\\n\\r\\n@media (min-width: 1024px) {\\n\\n  .lg\\\\:grid-cols-3 {\\n    grid-template-columns: repeat(3, minmax(0, 1fr));\\n  }\\n}\\r\\n\\r\\n@media (min-width: 1280px) {\\n\\n  .xl\\\\:grid-cols-3 {\\n    grid-template-columns: repeat(3, minmax(0, 1fr));\\n  }\\n}\\r\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://styles/globals.css\",\"<no source>\"],\"names\":[],\"mappings\":\"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AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,wBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,uBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,uBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,uBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,sBAAmB;EAAnB;AAAmB;AAAnB;EAAA,sBAAmB;EAAnB;AAAmB;AAAnB;EAAA,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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA8iBG;;AA3jBH;EAAA,mBCAA;EDAA;CCAA;;ADAA;EAAA,qBCAA;EDAA;CCAA;;ADAA;EAAA;CCAA;;ADAA;EAAA;CCAA;;ADAA;EAAA,gFCAA;EDAA,oGCAA;EDAA;CCAA;;ADAA;EAAA,mBCAA;EDAA;CCAA;;ADAA;EAAA,gFCAA;EDAA,oGCAA;EDAA;CCAA;;ADAA;EAAA,+BCAA;EDAA;CCAA;;ADAA;EAAA,4GCAA;EDAA,0GCAA;EDAA;CCAA;;ADAA;EAAA,mBCAA;EDAA;CCAA;;ADAA;EAAA,mBCAA;EDAA;CCAA;;ADAA;EAAA,mBCAA;EDAA;CCAA;;ADAA;EAAA,gFCAA;EDAA,oGCAA;EDAA;CCAA;;ADAA;;EAAA;IAAA;GCAA;CAAA;;ADAA;;EAAA;IAAA;GCAA;CAAA;;ADAA;;EAAA;IAAA;GCAA;CAAA;;ADAA;;EAAA;IAAA;GCAA;CAAA\",\"sourcesContent\":[\"@tailwind base;\\r\\n@tailwind components;\\r\\n@tailwind utilities;\\r\\n\\r\\n/* @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@100;200;300;400;500;600;700;800;900&display=swap'); */\\r\\n/* @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@300;400;500;600;700&display=swap'); */\\r\\n\\r\\nbody {\\r\\n  background: linear-gradient(to bottom, #0a0b0c, #000000);\\r\\n  height: 100%;\\r\\n  width: 100vw;\\r\\n}\\r\\n\\r\\n/*\\r\\n* {\\r\\n  font-family: 'Fredoka', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,\\r\\n    Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\\r\\n  box-sizing: border-box;\\r\\n  list-style: none;\\r\\n  text-decoration: none;\\r\\n  padding: 0;\\r\\n  margin: 0;\\r\\n  outline: none;\\r\\n  border: none;\\r\\n}\\r\\n\\r\\nbody {\\r\\n  min-height: 100vh;\\r\\n  background: linear-gradient(to bottom, #1f222b, #17171a);\\r\\n  font-size: 0.97rem;\\r\\n  color: #fff;\\r\\n}\\r\\n\\r\\na {\\r\\n  user-select: none;\\r\\n}\\r\\n\\r\\n:root {\\r\\n  --header-bg: #17171a;\\r\\n  --primary-color: #3861fb;\\r\\n  --search-box-bg: #181924;\\r\\n  --green: #16c784;\\r\\n  --red: #ea3943;\\r\\n  --table-height: 80px;\\r\\n  --trending-item-bg: #323546;\\r\\n  --cmc-chat-bg: #222531;\\r\\n  overflow-x: hidden;\\r\\n}\\r\\n\\r\\n.header {\\r\\n  background: var(--header-bg);\\r\\n  color: #fff;\\r\\n  height: 80px;\\r\\n}\\r\\n\\r\\n.header-wrapper,\\r\\n.cmc-table-wrapper,\\r\\n.cmc-trending-wrapper,\\r\\nmain {\\r\\n  margin: auto;\\r\\n  max-width: 1300px;\\r\\n}\\r\\n\\r\\n.header-wrapper {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: space-between;\\r\\n  height: 100%;\\r\\n}\\r\\n\\r\\n.header nav {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: space-between;\\r\\n}\\r\\n\\r\\n.header nav a {\\r\\n  color: #fff;\\r\\n  padding: 16px;\\r\\n}\\r\\n\\r\\n.header nav a:hover {\\r\\n  color: var(--primary-color);\\r\\n}\\r\\n\\r\\n.header .nav-item {\\r\\n  position: relative;\\r\\n  font-weight: 500;\\r\\n}\\r\\n\\r\\n.header .nav-item .nav-badge {\\r\\n  background: var(--primary-color);\\r\\n  border-radius: 100px;\\r\\n  box-shadow: 0 0 7px 3px #0027ff;\\r\\n  height: 5px;\\r\\n  width: 5px;\\r\\n  position: absolute;\\r\\n  top: 0;\\r\\n  right: 5px;\\r\\n}\\r\\n\\r\\n.header .right-content .btn {\\r\\n  margin: 15px;\\r\\n}\\r\\n\\r\\n.header .right-content a {\\r\\n  margin-left: 15px;\\r\\n  color: #fff;\\r\\n  display: block;\\r\\n}\\r\\n\\r\\n.btn {\\r\\n  background: var(--primary-color);\\r\\n  border: none;\\r\\n  padding: 11px 22px;\\r\\n  border-radius: 10px;\\r\\n  color: #fff;\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.search-box {\\r\\n  background: var(--search-box-bg);\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: center;\\r\\n  padding: 7px 10px;\\r\\n  border-radius: 10px;\\r\\n}\\r\\n\\r\\n.search-box input {\\r\\n  background: transparent;\\r\\n  color: #fff;\\r\\n  width: 100px;\\r\\n}\\r\\n\\r\\n.search-box ::placeholder {\\r\\n  color: #474c5d;\\r\\n  margin-right: 30px;\\r\\n}\\r\\n\\r\\n.search-box svg {\\r\\n  width: 20px;\\r\\n  height: 20px;\\r\\n  margin-right: 10px;\\r\\n}\\r\\n\\r\\n.search-slash-btn {\\r\\n  background: #7d8395;\\r\\n  color: #fff;\\r\\n  border-radius: 6px;\\r\\n  width: 30px;\\r\\n  height: 30px;\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: center;\\r\\n  font-size: 14px;\\r\\n}\\r\\n\\r\\n.flex {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: center;\\r\\n}\\r\\n\\r\\n.flex-between {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: space-between;\\r\\n}\\r\\n\\r\\n.text-btn {\\r\\n  user-select: none;\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.flex-start {\\r\\n  display: flex;\\r\\n}\\r\\n\\r\\ntable {\\r\\n  color: #fff;\\r\\n  width: 100%;\\r\\n  text-align: left;\\r\\n  border-collapse: collapse;\\r\\n}\\r\\n\\r\\ntr {\\r\\n  height: var(--table-height);\\r\\n  border-bottom: 1px solid #7d83951c;\\r\\n  padding-left: 20px;\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.table-row:hover {\\r\\n  background: #191a1f;\\r\\n}\\r\\n\\r\\n.table-title p {\\r\\n  margin-right: 5px;\\r\\n}\\r\\n\\r\\ntable tr td:last-child {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  height: var(--table-height);\\r\\n  margin-left: -70px;\\r\\n}\\r\\n\\r\\ntable .circulating-supply-value {\\r\\n  position: relative;\\r\\n  right: -100px;\\r\\n}\\r\\n\\r\\ntable .volume-value {\\r\\n  position: relative;\\r\\n  right: 40px;\\r\\n  text-align: right;\\r\\n}\\r\\n\\r\\ntable .market-cap-value {\\r\\n  position: relative;\\r\\n  right: -40px;\\r\\n}\\r\\n\\r\\ntable .volume-value .coin-crypto-value {\\r\\n  font-size: 13px;\\r\\n  margin-top: 3px;\\r\\n}\\r\\n\\r\\ntable .buy-label {\\r\\n  background: #1a2033;\\r\\n  color: #5c81f1;\\r\\n  padding: 7px 9px;\\r\\n  border-radius: 7px;\\r\\n  font-size: 12px;\\r\\n}\\r\\n\\r\\n.fade-text {\\r\\n  opacity: 0.5;\\r\\n}\\r\\n\\r\\n.rate {\\r\\n  width: min-content;\\r\\n}\\r\\n\\r\\n.rate p {\\r\\n  margin-left: 10px;\\r\\n}\\r\\n\\r\\n.increment-rate {\\r\\n  color: var(--green);\\r\\n}\\r\\n\\r\\n.increment-rate svg {\\r\\n  fill: var(--green);\\r\\n}\\r\\n\\r\\n.decrement-rate {\\r\\n  color: var(--red);\\r\\n}\\r\\n\\r\\n.decrement-rate svg {\\r\\n  fill: var(--red);\\r\\n}\\r\\n\\r\\n.increment-rate svg,\\r\\n.decrement-rate svg {\\r\\n  margin-right: -5px;\\r\\n}\\r\\n\\r\\ntd .flex {\\r\\n  justify-content: flex-start;\\r\\n}\\r\\n\\r\\ntd .flex p {\\r\\n  margin-left: 10px;\\r\\n}\\r\\n\\r\\n.underline {\\r\\n  text-decoration: underline;\\r\\n}\\r\\n\\r\\n.trending-cards-container {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n}\\r\\n\\r\\n.trending-card {\\r\\n  width: 100%;\\r\\n  margin-left: 20px;\\r\\n  background: var(--trending-item-bg);\\r\\n  padding: 20px;\\r\\n  border-radius: 10px;\\r\\n  color: #fff;\\r\\n}\\r\\n\\r\\n.trending-card:first-child {\\r\\n  margin-left: 0;\\r\\n}\\r\\n\\r\\n.trending-more-btn {\\r\\n  color: var(--primary-color);\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: space-between;\\r\\n  width: min-content;\\r\\n  white-space: nowrap;\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.trending-card-row {\\r\\n  margin-bottom: 20px;\\r\\n}\\r\\n\\r\\n.trending-card-row:last-child {\\r\\n  margin-bottom: 0;\\r\\n}\\r\\n\\r\\n.trending-crypto-name-icon {\\r\\n  width: 100%;\\r\\n  display: flex;\\r\\n  padding-left: 20px;\\r\\n}\\r\\n\\r\\n.trending-crypto-name-icon p {\\r\\n  margin-left: 20px;\\r\\n}\\r\\n\\r\\n.trending-more-btn svg {\\r\\n  fill: var(--primary-color);\\r\\n}\\r\\n\\r\\n.switch {\\r\\n  position: relative;\\r\\n  display: inline-block;\\r\\n  width: 60px;\\r\\n  height: 34px;\\r\\n}\\r\\n\\r\\n.switch input {\\r\\n  opacity: 0;\\r\\n  width: 0;\\r\\n  height: 0;\\r\\n}\\r\\n\\r\\n.slider {\\r\\n  position: absolute;\\r\\n  cursor: pointer;\\r\\n  top: 0;\\r\\n  left: 0;\\r\\n  right: 0;\\r\\n  bottom: 0;\\r\\n  background-color: #ccc;\\r\\n  -webkit-transition: 0.4s;\\r\\n  transition: 0.4s;\\r\\n}\\r\\n\\r\\n.slider:before {\\r\\n  position: absolute;\\r\\n  content: '';\\r\\n  height: 26px;\\r\\n  width: 26px;\\r\\n  left: 4px;\\r\\n  bottom: 4px;\\r\\n  background-color: white;\\r\\n  -webkit-transition: 0.4s;\\r\\n  transition: 0.4s;\\r\\n}\\r\\n\\r\\ninput:checked + .slider {\\r\\n  background-color: #2196f3;\\r\\n}\\r\\n\\r\\ninput:focus + .slider {\\r\\n  box-shadow: 0 0 1px #2196f3;\\r\\n}\\r\\n\\r\\ninput:checked + .slider:before {\\r\\n  -webkit-transform: translateX(26px);\\r\\n  -ms-transform: translateX(26px);\\r\\n  transform: translateX(26px);\\r\\n}\\r\\n\\r\\n.slider.round {\\r\\n  border-radius: 34px;\\r\\n}\\r\\n\\r\\n.slider.round:before {\\r\\n  border-radius: 50%;\\r\\n}\\r\\n\\r\\n.modal {\\r\\n  width: 100vw;\\r\\n  height: 100vh;\\r\\n  background: #00000024;\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: center;\\r\\n  backdrop-filter: blur(28px);\\r\\n  position: fixed;\\r\\n  top: 0;\\r\\n  left: 0;\\r\\n  z-index: 100;\\r\\n}\\r\\n\\r\\n.wallet-selector {\\r\\n  background: var(--trending-item-bg);\\r\\n  width: 500px;\\r\\n  border-radius: 20px;\\r\\n}\\r\\n\\r\\n.wallet-item {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: center;\\r\\n  padding: 20px;\\r\\n  cursor: pointer;\\r\\n  border-bottom: 1px solid #a9abb517;\\r\\n  user-select: none;\\r\\n}\\r\\n\\r\\n.wallet-item:last-child {\\r\\n  border: none;\\r\\n}\\r\\n\\r\\n.wallet-item p {\\r\\n  margin-left: 20px;\\r\\n}\\r\\n\\r\\n.wallet-item:hover {\\r\\n  background: #17191e2e;\\r\\n}\\r\\n\\r\\n.cmc-chat-container {\\r\\n  width: 500px;\\r\\n}\\r\\n\\r\\n.cmc-chat {\\r\\n  background: var(--cmc-chat-bg);\\r\\n  padding: 20px;\\r\\n  border-radius: 10px;\\r\\n}\\r\\n\\r\\n.avatar-container {\\r\\n  border-radius: 100px;\\r\\n  width: 40px;\\r\\n  height: 40px;\\r\\n  overflow: hidden;\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: center;\\r\\n}\\r\\n\\r\\n.bullish-label svg {\\r\\n  fill: var(--green);\\r\\n}\\r\\n\\r\\n.bearish-label svg {\\r\\n  fill: var(--red);\\r\\n}\\r\\n\\r\\n.bullish-label,\\r\\n.bearish-label {\\r\\n  border: 1px solid #ffffff24;\\r\\n  border-radius: 5px;\\r\\n  padding: 2px 11px;\\r\\n  display: flex;\\r\\n  width: min-content;\\r\\n  align-items: center;\\r\\n}\\r\\n\\r\\n.bullish-label svg,\\r\\n.bearish-label svg {\\r\\n  margin-right: 7px;\\r\\n}\\r\\n\\r\\n.cmc-chat .input-box {\\r\\n  background: var(--trending-item-bg);\\r\\n  width: 100%;\\r\\n  padding: 17px;\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  border-radius: 10px;\\r\\n  margin: 25px 0;\\r\\n  color: var(--primary-color);\\r\\n}\\r\\n\\r\\n.cmc-chat .input-box input {\\r\\n  width: 100%;\\r\\n  height: 31px;\\r\\n  background: transparent;\\r\\n  padding: 10px;\\r\\n  color: #fff;\\r\\n  font-size: 17px;\\r\\n}\\r\\n\\r\\n.flex-horizontal-end {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: flex-end;\\r\\n}\\r\\n\\r\\n.text-align-left {\\r\\n  display: flex;\\r\\n  flex-direction: column;\\r\\n}\\r\\n\\r\\n.chat-user {\\r\\n  display: flex;\\r\\n  justify-content: center;\\r\\n  align-items: center;\\r\\n  justify-content: flex-start;\\r\\n}\\r\\n\\r\\n.chat-user .text-align-left {\\r\\n  margin-top: -17px;\\r\\n  margin-left: 10px;\\r\\n}\\r\\n\\r\\n.bullish-filled {\\r\\n  background: var(--green);\\r\\n}\\r\\n\\r\\n.bullish-filled svg,\\r\\n.bearish-filled svg {\\r\\n  fill: #fff;\\r\\n}\\r\\n\\r\\n.bearish-filled {\\r\\n  background: var(--red);\\r\\n}\\r\\n\\r\\n.chat-card {\\r\\n  margin-top: 20px;\\r\\n  padding-top: 50px;\\r\\n  border-top: 1px solid var(--trending-item-bg);\\r\\n}\\r\\n\\r\\n.chat-card .chat-user {\\r\\n  margin-bottom: 20px;\\r\\n}\\r\\n\\r\\n.chat-user-info {\\r\\n  width: 400px;\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: space-between;\\r\\n}\\r\\n\\r\\n.post-action {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  color: #61636e;\\r\\n}\\r\\n\\r\\n.post-action svg {\\r\\n  margin-right: 10px;\\r\\n}\\r\\n\\r\\n.post-actions-container {\\r\\n  margin-top: 20px;\\r\\n}\\r\\n\\r\\n.price-converter {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: space-between;\\r\\n  background: #171924;\\r\\n  padding: 24px 20px;\\r\\n  border-radius: 20px;\\r\\n  border: 1px solid #ffc8c80f;\\r\\n} */\\r\\n\",null],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls5XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOV0udXNlWzJdIS4vc3R5bGVzL2dsb2JhbHMuY3NzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ3dIO0FBQ3hILDhCQUE4QixrSEFBMkI7QUFDekQ7QUFDQSwwWEFBMFgsNEJBQTRCLDRCQUE0QixnQ0FBZ0Msa0NBQWtDLFVBQVUsd0JBQXdCLHFCQUFxQixHQUFHLHFQQUFxUCxzQkFBc0IsMkNBQTJDLDZCQUE2QiwwQkFBMEIsb0JBQW9CLHVQQUF1UCxVQUFVLGdLQUFnSyxlQUFlLGlDQUFpQyxVQUFVLDJOQUEyTixlQUFlLDJCQUEyQixrQ0FBa0MsVUFBVSxpR0FBaUcsOENBQThDLDhDQUE4QyxHQUFHLGtHQUFrRyx1QkFBdUIseUJBQXlCLEdBQUcsaUZBQWlGLG1CQUFtQiw2QkFBNkIsR0FBRywyRUFBMkUsd0JBQXdCLEdBQUcsMEpBQTBKLHlIQUF5SCwyQkFBMkIsVUFBVSxpRUFBaUUsbUJBQW1CLEdBQUcsMkdBQTJHLG1CQUFtQixtQkFBbUIsdUJBQXVCLDZCQUE2QixHQUFHLFNBQVMsb0JBQW9CLEdBQUcsU0FBUyxnQkFBZ0IsR0FBRyxnYkFBZ2Isb0JBQW9CLGtDQUFrQyxzQ0FBc0MsVUFBVSxrTUFBa00sMEJBQTBCLDRCQUE0QixpQ0FBaUMsaUNBQWlDLDJCQUEyQixzQkFBc0IsdUJBQXVCLFVBQVUsOEZBQThGLHlCQUF5QixHQUFHLG1MQUFtTCxnQ0FBZ0MsMENBQTBDLG1DQUFtQyxVQUFVLCtGQUErRixrQkFBa0IsR0FBRywrTUFBK00scUJBQXFCLEdBQUcsbUZBQW1GLDZC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TUFBTSxNQUFNLE1BQU0sS0FBSyxXQUFXLE1BQU0sTUFBTSxNQUFNLEtBQUssV0FBVyxNQUFNLE1BQU0sTUFBTSxNQUFNLFVBQVUsTUFBTSxPQUFPLE1BQU0sS0FBSyxxQkFBcUIscUJBQXFCLE1BQU0sTUFBTSxNQUFNLEtBQUssV0FBVyxNQUFNLE9BQU8sTUFBTSxLQUFLLHFCQUFxQixvQkFBb0IsTUFBTSxNQUFNLE1BQU0sS0FBSyxXQUFXLE1BQU0sTUFBTSxNQUFNLGlCQUFpQixVQUFVLE1BQU0sS0FBSyxVQUFVLFVBQVUsTUFBTSxLQUFLLFVBQVUsTUFBTSxPQUFPLFdBQVcsVUFBVSxVQUFVLE1BQU0sTUFBTSxNQUFNLEtBQUssV0FBVyxNQUFNLE9BQU8sTUFBTSxLQUFLLG9CQUFvQixvQkFBb0IsTUFBTSxNQUFNLG9CQUFvQixvQkFBb0IsTUFBTSxNQUFNLE1BQU0sTUFBTSxVQUFVLE1BQU0sTUFBTSxLQUFLLEtBQUssVUFBVSxNQUFNLFFBQVEsTUFBTSxZQUFZLG9CQUFvQixxQkFBcUIsTUFBTSxNQUFNLE1BQU0sTUFBTSxVQUFVLFVBQVUsTUFBTSxLQUFLLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxXQUFXLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsS0FBSyxNQUFNLEtBQUssV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFdBQVcsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxLQUFLLEtBQUssS0FBSyxLQUFLLE1BQU0sT0FBTyxLQUFLLEtBQUssTUFBTSxLQUFLLE9BQU8sS0FBSyxLQUFLLE1BQU0sS0FBSyxPQUFPLEtBQUssS0FBSyxNQUFNLEtBQUssT0FBTyxLQUFLLEtBQUssTUFBTSxLQUFLLE9BQU8sS0FBSyxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFdBQVcsTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFdBQVcsTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFB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MEJBQTBCLGdDQUFnQyxLQUFLLDBCQUEwQixvQkFBb0IsNkJBQTZCLEtBQUssb0JBQW9CLG9CQUFvQiw4QkFBOEIsMEJBQTBCLGtDQUFrQyxLQUFLLHFDQUFxQyx3QkFBd0Isd0JBQXdCLEtBQUsseUJBQXlCLCtCQUErQixLQUFLLHFEQUFxRCxpQkFBaUIsS0FBSyx5QkFBeUIsNkJBQTZCLEtBQUssb0JBQW9CLHVCQUF1Qix3QkFBd0Isb0RBQW9ELEtBQUssK0JBQStCLDBCQUEwQixLQUFLLHlCQUF5QixtQkFBbUIsb0JBQW9CLDBCQUEwQixxQ0FBcUMsS0FBSyxzQkFBc0Isb0JBQW9CLDBCQUEwQixxQkFBcUIsS0FBSywwQkFBMEIseUJBQXlCLEtBQUssaUNBQWlDLHVCQUF1QixLQUFLLDBCQUEwQixvQkFBb0IsMEJBQTBCLHFDQUFxQywwQkFBMEIseUJBQXlCLDBCQUEwQixrQ0FBa0MsTUFBTSw4QkFBOEI7QUFDM3lvRDtBQUNBLCtEQUFlLHVCQUF1QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3N0eWxlcy9nbG9iYWxzLmNzcz80YjU2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIvKlxcbiEgdGFpbHdpbmRjc3MgdjMuMS44IHwgTUlUIExpY2Vuc2UgfCBodHRwczovL3RhaWx3aW5kY3NzLmNvbVxcbiovLypcXG4xLiBQcmV2ZW50IHBhZGRpbmcgYW5kIGJvcmRlciBmcm9tIGFmZmVjdGluZyBlbGVtZW50IHdpZHRoLiAoaHR0cHM6Ly9naXRodWIuY29tL21vemRldnMvY3NzcmVtZWR5L2lzc3Vlcy80KVxcbjIuIEFsbG93IGFkZGluZyBhIGJvcmRlciB0byBhbiBlbGVtZW50IGJ5IGp1c3QgYWRkaW5nIGEgYm9yZGVyLXdpZHRoLiAoaHR0cHM6Ly9naXRodWIuY29tL3RhaWx3aW5kY3NzL3RhaWx3aW5kY3NzL3B1bGwvMTE2KVxcbiovXFxuXFxuKixcXG46OmJlZm9yZSxcXG46OmFmdGVyIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IC8qIDEgKi9cXG4gIGJvcmRlci13aWR0aDogMDsgLyogMiAqL1xcbiAgYm9yZGVyLXN0eWxlOiBzb2xpZDsgLyogMiAqL1xcbiAgYm9yZGVyLWNvbG9yOiAjZTVlN2ViOyAvKiAyICovXFxufVxcblxcbjo6YmVmb3JlLFxcbjo6YWZ0ZXIge1xcbiAgLS10dy1jb250ZW50OiAnJztcXG59XFxuXFxuLypcXG4xLiBVc2UgYSBjb25zaXN0ZW50IHNlbnNpYmxlIGxpbmUtaGVpZ2h0IGluIGFsbCBicm93c2Vycy5cXG4yLiBQcmV2ZW50IGFkanVzdG1lbnRzIG9mIGZvbnQgc2l6ZSBhZnRlciBvcmllbnRhdGlvbiBjaGFuZ2VzIGluIGlPUy5cXG4zLiBVc2UgYSBtb3JlIHJlYWRhYmxlIHRhYiBzaXplLlxcbjQuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgYHNhbnNgIGZvbnQtZmFtaWx5IGJ5IGRlZmF1bHQuXFxuKi9cXG5cXG5odG1sIHtcXG4gIGxpbmUtaGVpZ2h0OiAxLjU7IC8qIDEgKi9cXG4gIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogMTAwJTsgLyogMiAqL1xcbiAgLW1vei10YWItc2l6ZTogNDsgLyogMyAqL1xcbiAgLW8tdGFiLXNpemU6IDQ7XFxuICAgICB0YWItc2l6ZTogNDsgLyogMyAqL1xcbiAgZm9udC1mYW1pbHk6IHVpLXNhbnMtc2VyaWYsIHN5c3RlbS11aSwgLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBcXFwiU2Vnb2UgVUlcXFwiLCBSb2JvdG8sIFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsIEFyaWFsLCBcXFwiTm90byBTYW5zXFxcIiwgc2Fucy1zZXJpZiwgXFxcIkFwcGxlIENvbG9yIEVtb2ppXFxcIiwgXFxcIlNlZ29lIFVJIEVtb2ppXFxcIiwgXFxcIlNlZ29lIFVJIFN5bWJvbFxcXCIsIFxcXCJOb3RvIENvbG9yIEVtb2ppXFxcIjsgLyogNCAqL1xcbn1cXG5cXG4vKlxcbjEuIFJlbW92ZSB0aGUgbWFyZ2luIGluIGFsbCBicm93c2Vycy5cXG4yLiBJbmhlcml0IGxpbmUtaGVpZ2h0IGZyb20gYGh0bWxgIHNvIHVzZXJzIGNhbiBzZXQgdGhlbSBhcyBhIGNsYXNzIGRpcmVjdGx5IG9uIHRoZSBgaHRtbGAgZWxlbWVudC5cXG4qL1xcblxcbmJvZHkge1xcbiAgbWFyZ2luOiAwOyAvKiAxICovXFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDsgLyogMiAqL1xcbn1cXG5cXG4vKlxcbjEuIEFkZCB0aGUgY29ycmVjdCBoZWlnaHQgaW4gRmlyZWZveC5cXG4yLiBDb3JyZWN0IHRoZSBpbmhlcml0YW5jZSBvZiBib3JkZXIgY29sb3IgaW4gRmlyZWZveC4gKGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE5MDY1NSlcXG4zLiBFbnN1cmUgaG9yaXpvbnRhbCBydWxlcyBhcmUgdmlzaWJsZSBieSBkZWZhdWx0LlxcbiovXFxuXFxuaHIge1xcbiAgaGVpZ2h0OiAwOyAvKiAxICovXFxuICBjb2xvcjogaW5oZXJpdDsgLyogMiAqL1xcbiAgYm9yZGVyLXRvcC13aWR0aDogMXB4OyAvKiAzICovXFxufVxcblxcbi8qXFxuQWRkIHRoZSBjb3JyZWN0IHRleHQgZGVjb3JhdGlvbiBpbiBDaHJvbWUsIEVkZ2UsIGFuZCBTYWZhcmkuXFxuKi9cXG5cXG5hYmJyOndoZXJlKFt0aXRsZV0pIHtcXG4gIC13ZWJraXQtdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxufVxcblxcbi8qXFxuUmVtb3ZlIHRoZSBkZWZhdWx0IGZvbnQgc2l6ZSBhbmQgd2VpZ2h0IGZvciBoZWFkaW5ncy5cXG4qL1xcblxcbmgxLFxcbmgyLFxcbmgzLFxcbmg0LFxcbmg1LFxcbmg2IHtcXG4gIGZvbnQtc2l6ZTogaW5oZXJpdDtcXG4gIGZvbnQtd2VpZ2h0OiBpbmhlcml0O1xcbn1cXG5cXG4vKlxcblJlc2V0IGxpbmtzIHRvIG9wdGltaXplIGZvciBvcHQtaW4gc3R5bGluZyBpbnN0ZWFkIG9mIG9wdC1vdXQuXFxuKi9cXG5cXG5hIHtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBpbmhlcml0O1xcbn1cXG5cXG4vKlxcbkFkZCB0aGUgY29ycmVjdCBmb250IHdlaWdodCBpbiBFZGdlIGFuZCBTYWZhcmkuXFxuKi9cXG5cXG5iLFxcbnN0cm9uZyB7XFxuICBmb250LXdlaWdodDogYm9sZGVyO1xcbn1cXG5cXG4vKlxcbjEuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgYG1vbm9gIGZvbnQgZmFtaWx5IGJ5IGRlZmF1bHQuXFxuMi4gQ29ycmVjdCB0aGUgb2RkIGBlbWAgZm9udCBzaXppbmcgaW4gYWxsIGJyb3dzZXJzLlxcbiovXFxuXFxuY29kZSxcXG5rYmQsXFxuc2FtcCxcXG5wcmUge1xcbiAgZm9udC1mYW1pbHk6IHVpLW1vbm9zcGFjZSwgU0ZNb25vLVJlZ3VsYXIsIE1lbmxvLCBNb25hY28sIENvbnNvbGFzLCBcXFwiTGliZXJhdGlvbiBNb25vXFxcIiwgXFxcIkNvdXJpZXIgTmV3XFxcIiwgbW9ub3NwYWNlOyAvKiAxICovXFxuICBmb250LXNpemU6IDFlbTsgLyogMiAqL1xcbn1cXG5cXG4vKlxcbkFkZCB0aGUgY29ycmVjdCBmb250IHNpemUgaW4gYWxsIGJyb3dzZXJzLlxcbiovXFxuXFxuc21hbGwge1xcbiAgZm9udC1zaXplOiA4MCU7XFxufVxcblxcbi8qXFxuUHJldmVudCBgc3ViYCBhbmQgYHN1cGAgZWxlbWVudHMgZnJvbSBhZmZlY3RpbmcgdGhlIGxpbmUgaGVpZ2h0IGluIGFsbCBicm93c2Vycy5cXG4qL1xcblxcbnN1YixcXG5zdXAge1xcbiAgZm9udC1zaXplOiA3NSU7XFxuICBsaW5lLWhlaWdodDogMDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG59XFxuXFxuc3ViIHtcXG4gIGJvdHRvbTogLTAuMjVlbTtcXG59XFxuXFxuc3VwIHtcXG4gIHRvcDogLTAuNWVtO1xcbn1cXG5cXG4vKlxcbjEuIFJlbW92ZSB0ZXh0IGluZGVudGF0aW9uIGZyb20gdGFibGUgY29udGVudHMgaW4gQ2hyb21lIGFuZCBTYWZhcmkuIChodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05OTkwODgsIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDEyOTcpXFxuMi4gQ29ycmVjdCB0YWJsZSBib3JkZXIgY29sb3IgaW5oZXJpdGFuY2UgaW4gYWxsIENocm9tZSBhbmQgU2FmYXJpLiAoaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTM1NzI5LCBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTk1MDE2KVxcbjMuIFJlbW92ZSBnYXBzIGJldHdlZW4gdGFibGUgYm9yZGVycyBieSBkZWZhdWx0LlxcbiovXFxuXFxudGFibGUge1xcbiAgdGV4dC1pbmRlbnQ6IDA7IC8qIDEgKi9cXG4gIGJvcmRlci1jb2xvcjogaW5oZXJpdDsgLyogMiAqL1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTsgLyogMyAqL1xcbn1cXG5cXG4vKlxcbjEuIENoYW5nZSB0aGUgZm9udCBzdHlsZXMgaW4gYWxsIGJyb3dzZXJzLlxcbjIuIFJlbW92ZSB0aGUgbWFyZ2luIGluIEZpcmVmb3ggYW5kIFNhZmFyaS5cXG4zLiBSZW1vdmUgZGVmYXVsdCBwYWRkaW5nIGluIGFsbCBicm93c2Vycy5cXG4qL1xcblxcbmJ1dHRvbixcXG5pbnB1dCxcXG5vcHRncm91cCxcXG5zZWxlY3QsXFxudGV4dGFyZWEge1xcbiAgZm9udC1mYW1pbHk6IGluaGVyaXQ7IC8qIDEgKi9cXG4gIGZvbnQtc2l6ZTogMTAwJTsgLyogMSAqL1xcbiAgZm9udC13ZWlnaHQ6IGluaGVyaXQ7IC8qIDEgKi9cXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyAvKiAxICovXFxuICBjb2xvcjogaW5oZXJpdDsgLyogMSAqL1xcbiAgbWFyZ2luOiAwOyAvKiAyICovXFxuICBwYWRkaW5nOiAwOyAvKiAzICovXFxufVxcblxcbi8qXFxuUmVtb3ZlIHRoZSBpbmhlcml0YW5jZSBvZiB0ZXh0IHRyYW5zZm9ybSBpbiBFZGdlIGFuZCBGaXJlZm94LlxcbiovXFxuXFxuYnV0dG9uLFxcbnNlbGVjdCB7XFxuICB0ZXh0LXRyYW5zZm9ybTogbm9uZTtcXG59XFxuXFxuLypcXG4xLiBDb3JyZWN0IHRoZSBpbmFiaWxpdHkgdG8gc3R5bGUgY2xpY2thYmxlIHR5cGVzIGluIGlPUyBhbmQgU2FmYXJpLlxcbjIuIFJlbW92ZSBkZWZhdWx0IGJ1dHRvbiBzdHlsZXMuXFxuKi9cXG5cXG5idXR0b24sXFxuW3R5cGU9J2J1dHRvbiddLFxcblt0eXBlPSdyZXNldCddLFxcblt0eXBlPSdzdWJtaXQnXSB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjsgLyogMSAqL1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7IC8qIDIgKi9cXG4gIGJhY2tncm91bmQtaW1hZ2U6IG5vbmU7IC8qIDIgKi9cXG59XFxuXFxuLypcXG5Vc2UgdGhlIG1vZGVybiBGaXJlZm94IGZvY3VzIHN0eWxlIGZvciBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzLlxcbiovXFxuXFxuOi1tb3otZm9jdXNyaW5nIHtcXG4gIG91dGxpbmU6IGF1dG87XFxufVxcblxcbi8qXFxuUmVtb3ZlIHRoZSBhZGRpdGlvbmFsIGA6aW52YWxpZGAgc3R5bGVzIGluIEZpcmVmb3guIChodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9nZWNrby1kZXYvYmxvYi8yZjllYWNkOWQzZDk5NWM5MzdiNDI1MWE1NTU3ZDk1ZDQ5NGM5YmUxL2xheW91dC9zdHlsZS9yZXMvZm9ybXMuY3NzI0w3MjgtTDczNylcXG4qL1xcblxcbjotbW96LXVpLWludmFsaWQge1xcbiAgYm94LXNoYWRvdzogbm9uZTtcXG59XFxuXFxuLypcXG5BZGQgdGhlIGNvcnJlY3QgdmVydGljYWwgYWxpZ25tZW50IGluIENocm9tZSBhbmQgRmlyZWZveC5cXG4qL1xcblxcbnByb2dyZXNzIHtcXG4gIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG59XFxuXFxuLypcXG5Db3JyZWN0IHRoZSBjdXJzb3Igc3R5bGUgb2YgaW5jcmVtZW50IGFuZCBkZWNyZW1lbnQgYnV0dG9ucyBpbiBTYWZhcmkuXFxuKi9cXG5cXG46Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24sXFxuOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uIHtcXG4gIGhlaWdodDogYXV0bztcXG59XFxuXFxuLypcXG4xLiBDb3JyZWN0IHRoZSBvZGQgYXBwZWFyYW5jZSBpbiBDaHJvbWUgYW5kIFNhZmFyaS5cXG4yLiBDb3JyZWN0IHRoZSBvdXRsaW5lIHN0eWxlIGluIFNhZmFyaS5cXG4qL1xcblxcblt0eXBlPSdzZWFyY2gnXSB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IHRleHRmaWVsZDsgLyogMSAqL1xcbiAgb3V0bGluZS1vZmZzZXQ6IC0ycHg7IC8qIDIgKi9cXG59XFxuXFxuLypcXG5SZW1vdmUgdGhlIGlubmVyIHBhZGRpbmcgaW4gQ2hyb21lIGFuZCBTYWZhcmkgb24gbWFjT1MuXFxuKi9cXG5cXG46Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb24ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbn1cXG5cXG4vKlxcbjEuIENvcnJlY3QgdGhlIGluYWJpbGl0eSB0byBzdHlsZSBjbGlja2FibGUgdHlwZXMgaW4gaU9TIGFuZCBTYWZhcmkuXFxuMi4gQ2hhbmdlIGZvbnQgcHJvcGVydGllcyB0byBgaW5oZXJpdGAgaW4gU2FmYXJpLlxcbiovXFxuXFxuOjotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbiB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjsgLyogMSAqL1xcbiAgZm9udDogaW5oZXJpdDsgLyogMiAqL1xcbn1cXG5cXG4vKlxcbkFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIENocm9tZSBhbmQgU2FmYXJpLlxcbiovXFxuXFxuc3VtbWFyeSB7XFxuICBkaXNwbGF5OiBsaXN0LWl0ZW07XFxufVxcblxcbi8qXFxuUmVtb3ZlcyB0aGUgZGVmYXVsdCBzcGFjaW5nIGFuZCBib3JkZXIgZm9yIGFwcHJvcHJpYXRlIGVsZW1lbnRzLlxcbiovXFxuXFxuYmxvY2txdW90ZSxcXG5kbCxcXG5kZCxcXG5oMSxcXG5oMixcXG5oMyxcXG5oNCxcXG5oNSxcXG5oNixcXG5ocixcXG5maWd1cmUsXFxucCxcXG5wcmUge1xcbiAgbWFyZ2luOiAwO1xcbn1cXG5cXG5maWVsZHNldCB7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG5cXG5sZWdlbmQge1xcbiAgcGFkZGluZzogMDtcXG59XFxuXFxub2wsXFxudWwsXFxubWVudSB7XFxuICBsaXN0LXN0eWxlOiBub25lO1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG59XFxuXFxuLypcXG5QcmV2ZW50IHJlc2l6aW5nIHRleHRhcmVhcyBob3Jpem9udGFsbHkgYnkgZGVmYXVsdC5cXG4qL1xcblxcbnRleHRhcmVhIHtcXG4gIHJlc2l6ZTogdmVydGljYWw7XFxufVxcblxcbi8qXFxuMS4gUmVzZXQgdGhlIGRlZmF1bHQgcGxhY2Vob2xkZXIgb3BhY2l0eSBpbiBGaXJlZm94LiAoaHR0cHM6Ly9naXRodWIuY29tL3RhaWx3aW5kbGFicy90YWlsd2luZGNzcy9pc3N1ZXMvMzMwMClcXG4yLiBTZXQgdGhlIGRlZmF1bHQgcGxhY2Vob2xkZXIgY29sb3IgdG8gdGhlIHVzZXIncyBjb25maWd1cmVkIGdyYXkgNDAwIGNvbG9yLlxcbiovXFxuXFxuaW5wdXQ6Oi1tb3otcGxhY2Vob2xkZXIsIHRleHRhcmVhOjotbW96LXBsYWNlaG9sZGVyIHtcXG4gIG9wYWNpdHk6IDE7IC8qIDEgKi9cXG4gIGNvbG9yOiAjOWNhM2FmOyAvKiAyICovXFxufVxcblxcbmlucHV0OjpwbGFjZWhvbGRlcixcXG50ZXh0YXJlYTo6cGxhY2Vob2xkZXIge1xcbiAgb3BhY2l0eTogMTsgLyogMSAqL1xcbiAgY29sb3I6ICM5Y2EzYWY7IC8qIDIgKi9cXG59XFxuXFxuLypcXG5TZXQgdGhlIGRlZmF1bHQgY3Vyc29yIGZvciBidXR0b25zLlxcbiovXFxuXFxuYnV0dG9uLFxcbltyb2xlPVxcXCJidXR0b25cXFwiXSB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi8qXFxuTWFrZSBzdXJlIGRpc2FibGVkIGJ1dHRvbnMgZG9uJ3QgZ2V0IHRoZSBwb2ludGVyIGN1cnNvci5cXG4qL1xcbjpkaXNhYmxlZCB7XFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxufVxcblxcbi8qXFxuMS4gTWFrZSByZXBsYWNlZCBlbGVtZW50cyBgZGlzcGxheTogYmxvY2tgIGJ5IGRlZmF1bHQuIChodHRwczovL2dpdGh1Yi5jb20vbW96ZGV2cy9jc3NyZW1lZHkvaXNzdWVzLzE0KVxcbjIuIEFkZCBgdmVydGljYWwtYWxpZ246IG1pZGRsZWAgdG8gYWxpZ24gcmVwbGFjZWQgZWxlbWVudHMgbW9yZSBzZW5zaWJseSBieSBkZWZhdWx0LiAoaHR0cHM6Ly9naXRodWIuY29tL2plbnNpbW1vbnMvY3NzcmVtZWR5L2lzc3Vlcy8xNCNpc3N1ZWNvbW1lbnQtNjM0OTM0MjEwKVxcbiAgIFRoaXMgY2FuIHRyaWdnZXIgYSBwb29ybHkgY29uc2lkZXJlZCBsaW50IGVycm9yIGluIHNvbWUgdG9vbHMgYnV0IGlzIGluY2x1ZGVkIGJ5IGRlc2lnbi5cXG4qL1xcblxcbmltZyxcXG5zdmcsXFxudmlkZW8sXFxuY2FudmFzLFxcbmF1ZGlvLFxcbmlmcmFtZSxcXG5lbWJlZCxcXG5vYmplY3Qge1xcbiAgZGlzcGxheTogYmxvY2s7IC8qIDEgKi9cXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7IC8qIDIgKi9cXG59XFxuXFxuLypcXG5Db25zdHJhaW4gaW1hZ2VzIGFuZCB2aWRlb3MgdG8gdGhlIHBhcmVudCB3aWR0aCBhbmQgcHJlc2VydmUgdGhlaXIgaW50cmluc2ljIGFzcGVjdCByYXRpby4gKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3pkZXZzL2Nzc3JlbWVkeS9pc3N1ZXMvMTQpXFxuKi9cXG5cXG5pbWcsXFxudmlkZW8ge1xcbiAgbWF4LXdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiBhdXRvO1xcbn1cXG5cXG4qLCA6OmJlZm9yZSwgOjphZnRlciB7XFxuICAtLXR3LWJvcmRlci1zcGFjaW5nLXg6IDA7XFxuICAtLXR3LWJvcmRlci1zcGFjaW5nLXk6IDA7XFxuICAtLXR3LXRyYW5zbGF0ZS14OiAwO1xcbiAgLS10dy10cmFuc2xhdGUteTogMDtcXG4gIC0tdHctcm90YXRlOiAwO1xcbiAgLS10dy1za2V3LXg6IDA7XFxuICAtLXR3LXNrZXcteTogMDtcXG4gIC0tdHctc2NhbGUteDogMTtcXG4gIC0tdHctc2NhbGUteTogMTtcXG4gIC0tdHctcGFuLXg6ICA7XFxuICAtLXR3LXBhbi15OiAgO1xcbiAgLS10dy1waW5jaC16b29tOiAgO1xcbiAgLS10dy1zY3JvbGwtc25hcC1zdHJpY3RuZXNzOiBwcm94aW1pdHk7XFxuICAtLXR3LW9yZGluYWw6ICA7XFxuICAtLXR3LXNsYXNoZWQtemVybzogIDtcXG4gIC0tdHctbnVtZXJpYy1maWd1cmU6ICA7XFxuICAtLXR3LW51bWVyaWMtc3BhY2luZzogIDtcXG4gIC0tdHctbnVtZXJpYy1mcmFjdGlvbjogIDtcXG4gIC0tdHctcmluZy1pbnNldDogIDtcXG4gIC0tdHctcmluZy1vZmZzZXQtd2lkdGg6IDBweDtcXG4gIC0tdHctcmluZy1vZmZzZXQtY29sb3I6ICNmZmY7XFxuICAtLXR3LXJpbmctY29sb3I6IHJnYig1OSAxMzAgMjQ2IC8gMC41KTtcXG4gIC0tdHctcmluZy1vZmZzZXQtc2hhZG93OiAwIDAgIzAwMDA7XFxuICAtLXR3LXJpbmctc2hhZG93OiAwIDAgIzAwMDA7XFxuICAtLXR3LXNoYWRvdzogMCAwICMwMDAwO1xcbiAgLS10dy1zaGFkb3ctY29sb3JlZDogMCAwICMwMDAwO1xcbiAgLS10dy1ibHVyOiAgO1xcbiAgLS10dy1icmlnaHRuZXNzOiAgO1xcbiAgLS10dy1jb250cmFzdDogIDtcXG4gIC0tdHctZ3JheXNjYWxlOiAgO1xcbiAgLS10dy1odWUtcm90YXRlOiAgO1xcbiAgLS10dy1pbnZlcnQ6ICA7XFxuICAtLXR3LXNhdHVyYXRlOiAgO1xcbiAgLS10dy1zZXBpYTogIDtcXG4gIC0tdHctZHJvcC1zaGFkb3c6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWJsdXI6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWJyaWdodG5lc3M6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWNvbnRyYXN0OiAgO1xcbiAgLS10dy1iYWNrZHJvcC1ncmF5c2NhbGU6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWh1ZS1yb3RhdGU6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWludmVydDogIDtcXG4gIC0tdHctYmFja2Ryb3Atb3BhY2l0eTogIDtcXG4gIC0tdHctYmFja2Ryb3Atc2F0dXJhdGU6ICA7XFxuICAtLXR3LWJhY2tkcm9wLXNlcGlhOiAgO1xcbn1cXG5cXG46OmJhY2tkcm9wIHtcXG4gIC0tdHctYm9yZGVyLXNwYWNpbmcteDogMDtcXG4gIC0tdHctYm9yZGVyLXNwYWNpbmcteTogMDtcXG4gIC0tdHctdHJhbnNsYXRlLXg6IDA7XFxuICAtLXR3LXRyYW5zbGF0ZS15OiAwO1xcbiAgLS10dy1yb3RhdGU6IDA7XFxuICAtLXR3LXNrZXcteDogMDtcXG4gIC0tdHctc2tldy15OiAwO1xcbiAgLS10dy1zY2FsZS14OiAxO1xcbiAgLS10dy1zY2FsZS15OiAxO1xcbiAgLS10dy1wYW4teDogIDtcXG4gIC0tdHctcGFuLXk6ICA7XFxuICAtLXR3LXBpbmNoLXpvb206ICA7XFxuICAtLXR3LXNjcm9sbC1zbmFwLXN0cmljdG5lc3M6IHByb3hpbWl0eTtcXG4gIC0tdHctb3JkaW5hbDogIDtcXG4gIC0tdHctc2xhc2hlZC16ZXJvOiAgO1xcbiAgLS10dy1udW1lcmljLWZpZ3VyZTogIDtcXG4gIC0tdHctbnVtZXJpYy1zcGFjaW5nOiAgO1xcbiAgLS10dy1udW1lcmljLWZyYWN0aW9uOiAgO1xcbiAgLS10dy1yaW5nLWluc2V0OiAgO1xcbiAgLS10dy1yaW5nLW9mZnNldC13aWR0aDogMHB4O1xcbiAgLS10dy1yaW5nLW9mZnNldC1jb2xvcjogI2ZmZjtcXG4gIC0tdHctcmluZy1jb2xvcjogcmdiKDU5IDEzMCAyNDYgLyAwLjUpO1xcbiAgLS10dy1yaW5nLW9mZnNldC1zaGFkb3c6IDAgMCAjMDAwMDtcXG4gIC0tdHctcmluZy1zaGFkb3c6IDAgMCAjMDAwMDtcXG4gIC0tdHctc2hhZG93OiAwIDAgIzAwMDA7XFxuICAtLXR3LXNoYWRvdy1jb2xvcmVkOiAwIDAgIzAwMDA7XFxuICAtLXR3LWJsdXI6ICA7XFxuICAtLXR3LWJyaWdodG5lc3M6ICA7XFxuICAtLXR3LWNvbnRyYXN0OiAgO1xcbiAgLS10dy1ncmF5c2NhbGU6ICA7XFxuICAtLXR3LWh1ZS1yb3RhdGU6ICA7XFxuICAtLXR3LWludmVydDogIDtcXG4gIC0tdHctc2F0dXJhdGU6ICA7XFxuICAtLXR3LXNlcGlhOiAgO1xcbiAgLS10dy1kcm9wLXNoYWRvdzogIDtcXG4gIC0tdHctYmFja2Ryb3AtYmx1cjogIDtcXG4gIC0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzczogIDtcXG4gIC0tdHctYmFja2Ryb3AtY29udHJhc3Q6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWdyYXlzY2FsZTogIDtcXG4gIC0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZTogIDtcXG4gIC0tdHctYmFja2Ryb3AtaW52ZXJ0OiAgO1xcbiAgLS10dy1iYWNrZHJvcC1vcGFjaXR5OiAgO1xcbiAgLS10dy1iYWNrZHJvcC1zYXR1cmF0ZTogIDtcXG4gIC0tdHctYmFja2Ryb3Atc2VwaWE6ICA7XFxufVxcclxcbi5jb250YWluZXIge1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcclxcbkBtZWRpYSAobWluLXdpZHRoOiA2NDBweCkge1xcblxcbiAgLmNvbnRhaW5lciB7XFxuICAgIG1heC13aWR0aDogNjQwcHg7XFxuICB9XFxufVxcclxcbkBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkge1xcblxcbiAgLmNvbnRhaW5lciB7XFxuICAgIG1heC13aWR0aDogNzY4cHg7XFxuICB9XFxufVxcclxcbkBtZWRpYSAobWluLXdpZHRoOiAxMDI0cHgpIHtcXG5cXG4gIC5jb250YWluZXIge1xcbiAgICBtYXgtd2lkdGg6IDEwMjRweDtcXG4gIH1cXG59XFxyXFxuQG1lZGlhIChtaW4td2lkdGg6IDEyODBweCkge1xcblxcbiAgLmNvbnRhaW5lciB7XFxuICAgIG1heC13aWR0aDogMTI4MHB4O1xcbiAgfVxcbn1cXHJcXG5AbWVkaWEgKG1pbi13aWR0aDogMTUzNnB4KSB7XFxuXFxuICAuY29udGFpbmVyIHtcXG4gICAgbWF4LXdpZHRoOiAxNTM2cHg7XFxuICB9XFxufVxcclxcbi52aXNpYmxlIHtcXG4gIHZpc2liaWxpdHk6IHZpc2libGU7XFxufVxcclxcbi5maXhlZCB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxufVxcclxcbi5hYnNvbHV0ZSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcclxcbi5yZWxhdGl2ZSB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcclxcbi5ib3R0b20tNSB7XFxuICBib3R0b206IDEuMjVyZW07XFxufVxcclxcbi5yaWdodC0wIHtcXG4gIHJpZ2h0OiAwcHg7XFxufVxcclxcbi50b3AtMSB7XFxuICB0b3A6IDAuMjVyZW07XFxufVxcclxcbi50b3AtMCB7XFxuICB0b3A6IDBweDtcXG59XFxyXFxuLmxlZnQtMCB7XFxuICBsZWZ0OiAwcHg7XFxufVxcclxcbi56LTEwIHtcXG4gIHotaW5kZXg6IDEwO1xcbn1cXHJcXG4ubS1hdXRvIHtcXG4gIG1hcmdpbjogYXV0bztcXG59XFxyXFxuLm14LVxcXFxbMTBweFxcXFxdIHtcXG4gIG1hcmdpbi1sZWZ0OiAxMHB4O1xcbiAgbWFyZ2luLXJpZ2h0OiAxMHB4O1xcbn1cXHJcXG4ubXgtYXV0byB7XFxuICBtYXJnaW4tbGVmdDogYXV0bztcXG4gIG1hcmdpbi1yaWdodDogYXV0bztcXG59XFxyXFxuLm15LTEwIHtcXG4gIG1hcmdpbi10b3A6IDIuNXJlbTtcXG4gIG1hcmdpbi1ib3R0b206IDIuNXJlbTtcXG59XFxyXFxuLm15LTQge1xcbiAgbWFyZ2luLXRvcDogMXJlbTtcXG4gIG1hcmdpbi1ib3R0b206IDFyZW07XFxufVxcclxcbi5teS0zIHtcXG4gIG1hcmdpbi10b3A6IDAuNzVyZW07XFxuICBtYXJnaW4tYm90dG9tOiAwLjc1cmVtO1xcbn1cXHJcXG4ubXgtNSB7XFxuICBtYXJnaW4tbGVmdDogMS4yNXJlbTtcXG4gIG1hcmdpbi1yaWdodDogMS4yNXJlbTtcXG59XFxyXFxuLm10LTEwIHtcXG4gIG1hcmdpbi10b3A6IDIuNXJlbTtcXG59XFxyXFxuLm10LTIwIHtcXG4gIG1hcmdpbi10b3A6IDVyZW07XFxufVxcclxcbi5tYi0yIHtcXG4gIG1hcmdpbi1ib3R0b206IDAuNXJlbTtcXG59XFxyXFxuLm1yLTIge1xcbiAgbWFyZ2luLXJpZ2h0OiAwLjVyZW07XFxufVxcclxcbi5tbC01IHtcXG4gIG1hcmdpbi1sZWZ0OiAxLjI1cmVtO1xcbn1cXHJcXG4ubXItMTAge1xcbiAgbWFyZ2luLXJpZ2h0OiAyLjVyZW07XFxufVxcclxcbi5tbC0xIHtcXG4gIG1hcmdpbi1sZWZ0OiAwLjI1cmVtO1xcbn1cXHJcXG4ubWItNiB7XFxuICBtYXJnaW4tYm90dG9tOiAxLjVyZW07XFxufVxcclxcbi5tbC0yIHtcXG4gIG1hcmdpbi1sZWZ0OiAwLjVyZW07XFxufVxcclxcbi5tdC0yIHtcXG4gIG1hcmdpbi10b3A6IDAuNXJlbTtcXG59XFxyXFxuLm1sLTMge1xcbiAgbWFyZ2luLWxlZnQ6IDAuNzVyZW07XFxufVxcclxcbi5tdC0zIHtcXG4gIG1hcmdpbi10b3A6IDAuNzVyZW07XFxufVxcclxcbi5tci0zIHtcXG4gIG1hcmdpbi1yaWdodDogMC43NXJlbTtcXG59XFxyXFxuLm1iLTMge1xcbiAgbWFyZ2luLWJvdHRvbTogMC43NXJlbTtcXG59XFxyXFxuLm1sLTEwIHtcXG4gIG1hcmdpbi1sZWZ0OiAyLjVyZW07XFxufVxcclxcbi4tbWwtMTYge1xcbiAgbWFyZ2luLWxlZnQ6IC00cmVtO1xcbn1cXHJcXG4ubXItMSB7XFxuICBtYXJnaW4tcmlnaHQ6IDAuMjVyZW07XFxufVxcclxcbi5tci01IHtcXG4gIG1hcmdpbi1yaWdodDogMS4yNXJlbTtcXG59XFxyXFxuLm10LTUge1xcbiAgbWFyZ2luLXRvcDogMS4yNXJlbTtcXG59XFxyXFxuLm1iLTUge1xcbiAgbWFyZ2luLWJvdHRvbTogMS4yNXJlbTtcXG59XFxyXFxuLm1iLTQge1xcbiAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG59XFxyXFxuLmJsb2NrIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXHJcXG4uaW5saW5lLWJsb2NrIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG59XFxyXFxuLmZsZXgge1xcbiAgZGlzcGxheTogZmxleDtcXG59XFxyXFxuLnRhYmxlIHtcXG4gIGRpc3BsYXk6IHRhYmxlO1xcbn1cXHJcXG4uZ3JpZCB7XFxuICBkaXNwbGF5OiBncmlkO1xcbn1cXHJcXG4uaC1taW4ge1xcbiAgaGVpZ2h0OiAtbW96LW1pbi1jb250ZW50O1xcbiAgaGVpZ2h0OiBtaW4tY29udGVudDtcXG59XFxyXFxuLmgtMSB7XFxuICBoZWlnaHQ6IDAuMjVyZW07XFxufVxcclxcbi5oLXNjcmVlbiB7XFxuICBoZWlnaHQ6IDEwMHZoO1xcbn1cXHJcXG4ubWluLWgtc2NyZWVuIHtcXG4gIG1pbi1oZWlnaHQ6IDEwMHZoO1xcbn1cXHJcXG4udy0xXFxcXC81IHtcXG4gIHdpZHRoOiAyMCU7XFxufVxcclxcbi53LWZ1bGwge1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcclxcbi53LTJcXFxcLzMge1xcbiAgd2lkdGg6IDY2LjY2NjY2NyU7XFxufVxcclxcbi53LWZpdCB7XFxuICB3aWR0aDogLW1vei1maXQtY29udGVudDtcXG4gIHdpZHRoOiBmaXQtY29udGVudDtcXG59XFxyXFxuLnctMSB7XFxuICB3aWR0aDogMC4yNXJlbTtcXG59XFxyXFxuLnctbWluIHtcXG4gIHdpZHRoOiAtbW96LW1pbi1jb250ZW50O1xcbiAgd2lkdGg6IG1pbi1jb250ZW50O1xcbn1cXHJcXG4udy1zY3JlZW4ge1xcbiAgd2lkdGg6IDEwMHZ3O1xcbn1cXHJcXG4udy1tYXgge1xcbiAgd2lkdGg6IC1tb3otbWF4LWNvbnRlbnQ7XFxuICB3aWR0aDogbWF4LWNvbnRlbnQ7XFxufVxcclxcbi53LTFcXFxcLzMge1xcbiAgd2lkdGg6IDMzLjMzMzMzMyU7XFxufVxcclxcbi5taW4tdy1mdWxsIHtcXG4gIG1pbi13aWR0aDogMTAwJTtcXG59XFxyXFxuLm1heC13LXNtIHtcXG4gIG1heC13aWR0aDogMjRyZW07XFxufVxcclxcbi5tYXgtdy1zY3JlZW4tMnhsIHtcXG4gIG1heC13aWR0aDogMTUzNnB4O1xcbn1cXHJcXG4ubWF4LXctbGcge1xcbiAgbWF4LXdpZHRoOiAzMnJlbTtcXG59XFxyXFxuLm1heC13LXNjcmVlbi14bCB7XFxuICBtYXgtd2lkdGg6IDEyODBweDtcXG59XFxyXFxuLnRyYW5zZm9ybSB7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSh2YXIoLS10dy10cmFuc2xhdGUteCksIHZhcigtLXR3LXRyYW5zbGF0ZS15KSkgcm90YXRlKHZhcigtLXR3LXJvdGF0ZSkpIHNrZXdYKHZhcigtLXR3LXNrZXcteCkpIHNrZXdZKHZhcigtLXR3LXNrZXcteSkpIHNjYWxlWCh2YXIoLS10dy1zY2FsZS14KSkgc2NhbGVZKHZhcigtLXR3LXNjYWxlLXkpKTtcXG59XFxyXFxuLmN1cnNvci1wb2ludGVyIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxyXFxuLmdyaWQtY29scy0xIHtcXG4gIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDEsIG1pbm1heCgwLCAxZnIpKTtcXG59XFxyXFxuLmZsZXgtY29sIHtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxufVxcclxcbi5mbGV4LXdyYXAge1xcbiAgZmxleC13cmFwOiB3cmFwO1xcbn1cXHJcXG4uaXRlbXMtc3RhcnQge1xcbiAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XFxufVxcclxcbi5pdGVtcy1jZW50ZXIge1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxyXFxuLmp1c3RpZnktZW5kIHtcXG4gIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XFxufVxcclxcbi5qdXN0aWZ5LWNlbnRlciB7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG59XFxyXFxuLmp1c3RpZnktYmV0d2VlbiB7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxufVxcclxcbi5nYXAtNSB7XFxuICBnYXA6IDEuMjVyZW07XFxufVxcclxcbi5nYXAtXFxcXFsyMHB4XFxcXF0ge1xcbiAgZ2FwOiAyMHB4O1xcbn1cXHJcXG4uZ2FwLVxcXFxbMTAwcHhcXFxcXSB7XFxuICBnYXA6IDEwMHB4O1xcbn1cXHJcXG4ub3ZlcmZsb3ctaGlkZGVuIHtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxufVxcclxcbi53aGl0ZXNwYWNlLW5vd3JhcCB7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbn1cXHJcXG4ucm91bmRlZCB7XFxuICBib3JkZXItcmFkaXVzOiAwLjI1cmVtO1xcbn1cXHJcXG4ucm91bmRlZC0yeGwge1xcbiAgYm9yZGVyLXJhZGl1czogMXJlbTtcXG59XFxyXFxuLnJvdW5kZWQtbGcge1xcbiAgYm9yZGVyLXJhZGl1czogMC41cmVtO1xcbn1cXHJcXG4ucm91bmRlZC14bCB7XFxuICBib3JkZXItcmFkaXVzOiAwLjc1cmVtO1xcbn1cXHJcXG4ucm91bmRlZC1mdWxsIHtcXG4gIGJvcmRlci1yYWRpdXM6IDk5OTlweDtcXG59XFxyXFxuLnJvdW5kZWQtbWQge1xcbiAgYm9yZGVyLXJhZGl1czogMC4zNzVyZW07XFxufVxcclxcbi5ib3JkZXIge1xcbiAgYm9yZGVyLXdpZHRoOiAxcHg7XFxufVxcclxcbi5ib3JkZXItYiB7XFxuICBib3JkZXItYm90dG9tLXdpZHRoOiAxcHg7XFxufVxcclxcbi5ib3JkZXItbCB7XFxuICBib3JkZXItbGVmdC13aWR0aDogMXB4O1xcbn1cXHJcXG4uYm9yZGVyLXQge1xcbiAgYm9yZGVyLXRvcC13aWR0aDogMXB4O1xcbn1cXHJcXG4uYm9yZGVyLWdyYXktNTAwXFxcXC8xMCB7XFxuICBib3JkZXItY29sb3I6IHJnYigxMDcgMTE0IDEyOCAvIDAuMSk7XFxufVxcclxcbi5ib3JkZXItZ3JlZW4tNjAwIHtcXG4gIC0tdHctYm9yZGVyLW9wYWNpdHk6IDE7XFxuICBib3JkZXItY29sb3I6IHJnYigyMiAxNjMgNzQgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcbn1cXHJcXG4uYm9yZGVyLXJlZC02MDAge1xcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXG4gIGJvcmRlci1jb2xvcjogcmdiKDIyMCAzOCAzOCAvIHZhcigtLXR3LWJvcmRlci1vcGFjaXR5KSk7XFxufVxcclxcbi5ib3JkZXItZ3JheS03MDAge1xcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXG4gIGJvcmRlci1jb2xvcjogcmdiKDU1IDY1IDgxIC8gdmFyKC0tdHctYm9yZGVyLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJvcmRlci1ncmF5LTgwMCB7XFxuICAtLXR3LWJvcmRlci1vcGFjaXR5OiAxO1xcbiAgYm9yZGVyLWNvbG9yOiByZ2IoMzEgNDEgNTUgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcbn1cXHJcXG4uYm9yZGVyLWdyYXktNjAwXFxcXC81MCB7XFxuICBib3JkZXItY29sb3I6IHJnYig3NSA4NSA5OSAvIDAuNSk7XFxufVxcclxcbi5iZy1jeWFuLTYwMCB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoOCAxNDUgMTc4IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXHJcXG4uYmctXFxcXFtcXFxcIzE3MTkyNFxcXFxdIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyMyAyNSAzNiAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJnLVxcXFxbXFxcXCMyMjI1MzFcXFxcXSB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMzQgMzcgNDkgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5iZy1cXFxcW1xcXFwjNjE4OEZGXFxcXF0ge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDk3IDEzNiAyNTUgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5iZy1cXFxcW1xcXFwjMzIzNTQ2XFxcXF0ge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDUwIDUzIDcwIC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXHJcXG4uYmctZ3JlZW4tNjAwIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyMiAxNjMgNzQgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5iZy1yZWQtNTAwIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyMzkgNjggNjggLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5iZy1zbGF0ZS04MDAge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDMwIDQxIDU5IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXHJcXG4uYmctXFxcXFtcXFxcIzFBMUYzQVxcXFxdIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyNiAzMSA1OCAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJnLWJsdWUtNjAwIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigzNyA5OSAyMzUgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5iZy1cXFxcW1xcXFwjMTcxNzFBXFxcXF0ge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDIzIDIzIDI2IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXHJcXG4uYmctdHJhbnNwYXJlbnQge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxufVxcclxcbi5iZy1ibGFjayB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMCAwIDAgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5iZy1ibHVlLTUwMCB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoNTkgMTMwIDI0NiAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuLmJnLVxcXFxbXFxcXCMxZDRlZDhcXFxcXSB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjkgNzggMjE2IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXHJcXG4uYmctZ3JheS05MDBcXFxcLzkwIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigxNyAyNCAzOSAvIDAuOSk7XFxufVxcclxcbi5iZy13aGl0ZSB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjU1IDI1NSAyNTUgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcbi5iZy1ibHVlLTcwMCB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjkgNzggMjE2IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXHJcXG4udG8tY3lhbi0zMDAge1xcbiAgLS10dy1ncmFkaWVudC10bzogIzY3ZThmOTtcXG59XFxyXFxuLnAtMTAge1xcbiAgcGFkZGluZzogMi41cmVtO1xcbn1cXHJcXG4ucC0xIHtcXG4gIHBhZGRpbmc6IDAuMjVyZW07XFxufVxcclxcbi5wLTIge1xcbiAgcGFkZGluZzogMC41cmVtO1xcbn1cXHJcXG4ucC00IHtcXG4gIHBhZGRpbmc6IDFyZW07XFxufVxcclxcbi5wLTUge1xcbiAgcGFkZGluZzogMS4yNXJlbTtcXG59XFxyXFxuLnAtXFxcXFszMHB4XFxcXF0ge1xcbiAgcGFkZGluZzogMzBweDtcXG59XFxyXFxuLnAtMyB7XFxuICBwYWRkaW5nOiAwLjc1cmVtO1xcbn1cXHJcXG4ucHgtNiB7XFxuICBwYWRkaW5nLWxlZnQ6IDEuNXJlbTtcXG4gIHBhZGRpbmctcmlnaHQ6IDEuNXJlbTtcXG59XFxyXFxuLnB5LTJcXFxcLjUge1xcbiAgcGFkZGluZy10b3A6IDAuNjI1cmVtO1xcbiAgcGFkZGluZy1ib3R0b206IDAuNjI1cmVtO1xcbn1cXHJcXG4ucHktMiB7XFxuICBwYWRkaW5nLXRvcDogMC41cmVtO1xcbiAgcGFkZGluZy1ib3R0b206IDAuNXJlbTtcXG59XFxyXFxuLnB5LTQge1xcbiAgcGFkZGluZy10b3A6IDFyZW07XFxuICBwYWRkaW5nLWJvdHRvbTogMXJlbTtcXG59XFxyXFxuLnB4LTIge1xcbiAgcGFkZGluZy1sZWZ0OiAwLjVyZW07XFxuICBwYWRkaW5nLXJpZ2h0OiAwLjVyZW07XFxufVxcclxcbi5weC01IHtcXG4gIHBhZGRpbmctbGVmdDogMS4yNXJlbTtcXG4gIHBhZGRpbmctcmlnaHQ6IDEuMjVyZW07XFxufVxcclxcbi5weC0zIHtcXG4gIHBhZGRpbmctbGVmdDogMC43NXJlbTtcXG4gIHBhZGRpbmctcmlnaHQ6IDAuNzVyZW07XFxufVxcclxcbi5weS0xIHtcXG4gIHBhZGRpbmctdG9wOiAwLjI1cmVtO1xcbiAgcGFkZGluZy1ib3R0b206IDAuMjVyZW07XFxufVxcclxcbi5weC00IHtcXG4gIHBhZGRpbmctbGVmdDogMXJlbTtcXG4gIHBhZGRpbmctcmlnaHQ6IDFyZW07XFxufVxcclxcbi5weC0xMCB7XFxuICBwYWRkaW5nLWxlZnQ6IDIuNXJlbTtcXG4gIHBhZGRpbmctcmlnaHQ6IDIuNXJlbTtcXG59XFxyXFxuLnB5LTUge1xcbiAgcGFkZGluZy10b3A6IDEuMjVyZW07XFxuICBwYWRkaW5nLWJvdHRvbTogMS4yNXJlbTtcXG59XFxyXFxuLnB5LTMge1xcbiAgcGFkZGluZy10b3A6IDAuNzVyZW07XFxuICBwYWRkaW5nLWJvdHRvbTogMC43NXJlbTtcXG59XFxyXFxuLnB0LTEwIHtcXG4gIHBhZGRpbmctdG9wOiAyLjVyZW07XFxufVxcclxcbi5wdC01IHtcXG4gIHBhZGRpbmctdG9wOiAxLjI1cmVtO1xcbn1cXHJcXG4ucGItMCB7XFxuICBwYWRkaW5nLWJvdHRvbTogMHB4O1xcbn1cXHJcXG4ucGwtMCB7XFxuICBwYWRkaW5nLWxlZnQ6IDBweDtcXG59XFxyXFxuLnByLTAge1xcbiAgcGFkZGluZy1yaWdodDogMHB4O1xcbn1cXHJcXG4ucGItNiB7XFxuICBwYWRkaW5nLWJvdHRvbTogMS41cmVtO1xcbn1cXHJcXG4ucGwtNSB7XFxuICBwYWRkaW5nLWxlZnQ6IDEuMjVyZW07XFxufVxcclxcbi5wdC0yMCB7XFxuICBwYWRkaW5nLXRvcDogNXJlbTtcXG59XFxyXFxuLnBsLTEge1xcbiAgcGFkZGluZy1sZWZ0OiAwLjI1cmVtO1xcbn1cXHJcXG4udGV4dC1sZWZ0IHtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxufVxcclxcbi50ZXh0LWNlbnRlciB7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcclxcbi50ZXh0LTV4bCB7XFxuICBmb250LXNpemU6IDNyZW07XFxuICBsaW5lLWhlaWdodDogMTtcXG59XFxyXFxuLnRleHQteHMge1xcbiAgZm9udC1zaXplOiAwLjc1cmVtO1xcbiAgbGluZS1oZWlnaHQ6IDFyZW07XFxufVxcclxcbi50ZXh0LXhsIHtcXG4gIGZvbnQtc2l6ZTogMS4yNXJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAxLjc1cmVtO1xcbn1cXHJcXG4udGV4dC1iYXNlIHtcXG4gIGZvbnQtc2l6ZTogMXJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAxLjVyZW07XFxufVxcclxcbi50ZXh0LXNtIHtcXG4gIGZvbnQtc2l6ZTogMC44NzVyZW07XFxuICBsaW5lLWhlaWdodDogMS4yNXJlbTtcXG59XFxyXFxuLnRleHQtM3hsIHtcXG4gIGZvbnQtc2l6ZTogMS44NzVyZW07XFxuICBsaW5lLWhlaWdodDogMi4yNXJlbTtcXG59XFxyXFxuLnRleHQtNHhsIHtcXG4gIGZvbnQtc2l6ZTogMi4yNXJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAyLjVyZW07XFxufVxcclxcbi50ZXh0LTJ4bCB7XFxuICBmb250LXNpemU6IDEuNXJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAycmVtO1xcbn1cXHJcXG4udGV4dC1cXFxcWzBcXFxcLjkzcmVtXFxcXF0ge1xcbiAgZm9udC1zaXplOiAwLjkzcmVtO1xcbn1cXHJcXG4uZm9udC1tZWRpdW0ge1xcbiAgZm9udC13ZWlnaHQ6IDUwMDtcXG59XFxyXFxuLmZvbnQtYm9sZCB7XFxuICBmb250LXdlaWdodDogNzAwO1xcbn1cXHJcXG4udXBwZXJjYXNlIHtcXG4gIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XFxufVxcclxcbi5sZWFkaW5nLXRpZ2h0IHtcXG4gIGxpbmUtaGVpZ2h0OiAxLjI1O1xcbn1cXHJcXG4udGV4dC13aGl0ZSB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoMjU1IDI1NSAyNTUgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxyXFxuLnRleHQtcmVkLTMwMCB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoMjUyIDE2NSAxNjUgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxyXFxuLnRleHQtY3lhbi0zMDAge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDEwMyAyMzIgMjQ5IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcclxcbi50ZXh0LVxcXFxbXFxcXCM2MTg4RkZcXFxcXSB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoOTcgMTM2IDI1NSAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXHJcXG4udGV4dC1ncmVlbi02MDAge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDIyIDE2MyA3NCAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXHJcXG4udGV4dC1cXFxcW1xcXFwjRUEzOTQzXFxcXF0ge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDIzNCA1NyA2NyAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXHJcXG4udGV4dC1ncmF5LTQwMCB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoMTU2IDE2MyAxNzUgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxyXFxuLnRleHQtcmVkLTUwMCB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoMjM5IDY4IDY4IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcclxcbi50ZXh0LWdyYXktNjAwIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYig3NSA4NSA5OSAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXHJcXG4udGV4dC1cXFxcW1xcXFwjMTdDNzg0XFxcXF0ge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDIzIDE5OSAxMzIgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxyXFxuLnVuZGVybGluZSB7XFxuICAtd2Via2l0LXRleHQtZGVjb3JhdGlvbi1saW5lOiB1bmRlcmxpbmU7XFxuICAgICAgICAgIHRleHQtZGVjb3JhdGlvbi1saW5lOiB1bmRlcmxpbmU7XFxufVxcclxcbi5vcGFjaXR5LTQwIHtcXG4gIG9wYWNpdHk6IDAuNDtcXG59XFxyXFxuLnNoYWRvdy1sZyB7XFxuICAtLXR3LXNoYWRvdzogMCAxMHB4IDE1cHggLTNweCByZ2IoMCAwIDAgLyAwLjEpLCAwIDRweCA2cHggLTRweCByZ2IoMCAwIDAgLyAwLjEpO1xcbiAgLS10dy1zaGFkb3ctY29sb3JlZDogMCAxMHB4IDE1cHggLTNweCB2YXIoLS10dy1zaGFkb3ctY29sb3IpLCAwIDRweCA2cHggLTRweCB2YXIoLS10dy1zaGFkb3ctY29sb3IpO1xcbiAgYm94LXNoYWRvdzogdmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93LCAwIDAgIzAwMDApLCB2YXIoLS10dy1yaW5nLXNoYWRvdywgMCAwICMwMDAwKSwgdmFyKC0tdHctc2hhZG93KTtcXG59XFxyXFxuLm91dGxpbmUtbm9uZSB7XFxuICBvdXRsaW5lOiAycHggc29saWQgdHJhbnNwYXJlbnQ7XFxuICBvdXRsaW5lLW9mZnNldDogMnB4O1xcbn1cXHJcXG4ucmluZy00IHtcXG4gIC0tdHctcmluZy1vZmZzZXQtc2hhZG93OiB2YXIoLS10dy1yaW5nLWluc2V0KSAwIDAgMCB2YXIoLS10dy1yaW5nLW9mZnNldC13aWR0aCkgdmFyKC0tdHctcmluZy1vZmZzZXQtY29sb3IpO1xcbiAgLS10dy1yaW5nLXNoYWRvdzogdmFyKC0tdHctcmluZy1pbnNldCkgMCAwIDAgY2FsYyg0cHggKyB2YXIoLS10dy1yaW5nLW9mZnNldC13aWR0aCkpIHZhcigtLXR3LXJpbmctY29sb3IpO1xcbiAgYm94LXNoYWRvdzogdmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93KSwgdmFyKC0tdHctcmluZy1zaGFkb3cpLCB2YXIoLS10dy1zaGFkb3csIDAgMCAjMDAwMCk7XFxufVxcclxcbi5ibHVyIHtcXG4gIC0tdHctYmx1cjogYmx1cig4cHgpO1xcbiAgZmlsdGVyOiB2YXIoLS10dy1ibHVyKSB2YXIoLS10dy1icmlnaHRuZXNzKSB2YXIoLS10dy1jb250cmFzdCkgdmFyKC0tdHctZ3JheXNjYWxlKSB2YXIoLS10dy1odWUtcm90YXRlKSB2YXIoLS10dy1pbnZlcnQpIHZhcigtLXR3LXNhdHVyYXRlKSB2YXIoLS10dy1zZXBpYSkgdmFyKC0tdHctZHJvcC1zaGFkb3cpO1xcbn1cXHJcXG4uZmlsdGVyIHtcXG4gIGZpbHRlcjogdmFyKC0tdHctYmx1cikgdmFyKC0tdHctYnJpZ2h0bmVzcykgdmFyKC0tdHctY29udHJhc3QpIHZhcigtLXR3LWdyYXlzY2FsZSkgdmFyKC0tdHctaHVlLXJvdGF0ZSkgdmFyKC0tdHctaW52ZXJ0KSB2YXIoLS10dy1zYXR1cmF0ZSkgdmFyKC0tdHctc2VwaWEpIHZhcigtLXR3LWRyb3Atc2hhZG93KTtcXG59XFxyXFxuLnRyYW5zaXRpb24ge1xcbiAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogY29sb3IsIGJhY2tncm91bmQtY29sb3IsIGJvcmRlci1jb2xvciwgZmlsbCwgc3Ryb2tlLCBvcGFjaXR5LCBib3gtc2hhZG93LCB0cmFuc2Zvcm0sIGZpbHRlciwgLXdlYmtpdC10ZXh0LWRlY29yYXRpb24tY29sb3IsIC13ZWJraXQtYmFja2Ryb3AtZmlsdGVyO1xcbiAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogY29sb3IsIGJhY2tncm91bmQtY29sb3IsIGJvcmRlci1jb2xvciwgdGV4dC1kZWNvcmF0aW9uLWNvbG9yLCBmaWxsLCBzdHJva2UsIG9wYWNpdHksIGJveC1zaGFkb3csIHRyYW5zZm9ybSwgZmlsdGVyLCBiYWNrZHJvcC1maWx0ZXI7XFxuICB0cmFuc2l0aW9uLXByb3BlcnR5OiBjb2xvciwgYmFja2dyb3VuZC1jb2xvciwgYm9yZGVyLWNvbG9yLCB0ZXh0LWRlY29yYXRpb24tY29sb3IsIGZpbGwsIHN0cm9rZSwgb3BhY2l0eSwgYm94LXNoYWRvdywgdHJhbnNmb3JtLCBmaWx0ZXIsIGJhY2tkcm9wLWZpbHRlciwgLXdlYmtpdC10ZXh0LWRlY29yYXRpb24tY29sb3IsIC13ZWJraXQtYmFja2Ryb3AtZmlsdGVyO1xcbiAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7XFxuICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAxNTBtcztcXG59XFxyXFxuLmR1cmF0aW9uLTE1MCB7XFxuICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAxNTBtcztcXG59XFxyXFxuLmVhc2UtaW4tb3V0IHtcXG4gIHRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpO1xcbn1cXHJcXG5cXHJcXG4vKiBAaW1wb3J0IHVybCgnaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3MyP2ZhbWlseT1Qb3BwaW5zOndnaHRAMTAwOzIwMDszMDA7NDAwOzUwMDs2MDA7NzAwOzgwMDs5MDAmZGlzcGxheT1zd2FwJyk7ICovXFxyXFxuLyogQGltcG9ydCB1cmwoJ2h0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzMj9mYW1pbHk9RnJlZG9rYTp3Z2h0QDMwMDs0MDA7NTAwOzYwMDs3MDAmZGlzcGxheT1zd2FwJyk7ICovXFxyXFxuXFxyXFxuYm9keSB7XFxyXFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCAjMGEwYjBjLCAjMDAwMDAwKTtcXHJcXG4gIGhlaWdodDogMTAwJTtcXHJcXG4gIHdpZHRoOiAxMDB2dztcXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG4qIHtcXHJcXG4gIGZvbnQtZmFtaWx5OiAnRnJlZG9rYScsIC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgJ1NlZ29lIFVJJywgUm9ib3RvLFxcclxcbiAgICBPeHlnZW4sIFVidW50dSwgQ2FudGFyZWxsLCAnT3BlbiBTYW5zJywgJ0hlbHZldGljYSBOZXVlJywgc2Fucy1zZXJpZjtcXHJcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxuICBsaXN0LXN0eWxlOiBub25lO1xcclxcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcclxcbiAgcGFkZGluZzogMDtcXHJcXG4gIG1hcmdpbjogMDtcXHJcXG4gIG91dGxpbmU6IG5vbmU7XFxyXFxuICBib3JkZXI6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbmJvZHkge1xcclxcbiAgbWluLWhlaWdodDogMTAwdmg7XFxyXFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCAjMWYyMjJiLCAjMTcxNzFhKTtcXHJcXG4gIGZvbnQtc2l6ZTogMC45N3JlbTtcXHJcXG4gIGNvbG9yOiAjZmZmO1xcclxcbn1cXHJcXG5cXHJcXG5hIHtcXHJcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcclxcbn1cXHJcXG5cXHJcXG46cm9vdCB7XFxyXFxuICAtLWhlYWRlci1iZzogIzE3MTcxYTtcXHJcXG4gIC0tcHJpbWFyeS1jb2xvcjogIzM4NjFmYjtcXHJcXG4gIC0tc2VhcmNoLWJveC1iZzogIzE4MTkyNDtcXHJcXG4gIC0tZ3JlZW46ICMxNmM3ODQ7XFxyXFxuICAtLXJlZDogI2VhMzk0MztcXHJcXG4gIC0tdGFibGUtaGVpZ2h0OiA4MHB4O1xcclxcbiAgLS10cmVuZGluZy1pdGVtLWJnOiAjMzIzNTQ2O1xcclxcbiAgLS1jbWMtY2hhdC1iZzogIzIyMjUzMTtcXHJcXG4gIG92ZXJmbG93LXg6IGhpZGRlbjtcXHJcXG59XFxyXFxuXFxyXFxuLmhlYWRlciB7XFxyXFxuICBiYWNrZ3JvdW5kOiB2YXIoLS1oZWFkZXItYmcpO1xcclxcbiAgY29sb3I6ICNmZmY7XFxyXFxuICBoZWlnaHQ6IDgwcHg7XFxyXFxufVxcclxcblxcclxcbi5oZWFkZXItd3JhcHBlcixcXHJcXG4uY21jLXRhYmxlLXdyYXBwZXIsXFxyXFxuLmNtYy10cmVuZGluZy13cmFwcGVyLFxcclxcbm1haW4ge1xcclxcbiAgbWFyZ2luOiBhdXRvO1xcclxcbiAgbWF4LXdpZHRoOiAxMzAwcHg7XFxyXFxufVxcclxcblxcclxcbi5oZWFkZXItd3JhcHBlciB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXHJcXG4gIGhlaWdodDogMTAwJTtcXHJcXG59XFxyXFxuXFxyXFxuLmhlYWRlciBuYXYge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxyXFxufVxcclxcblxcclxcbi5oZWFkZXIgbmF2IGEge1xcclxcbiAgY29sb3I6ICNmZmY7XFxyXFxuICBwYWRkaW5nOiAxNnB4O1xcclxcbn1cXHJcXG5cXHJcXG4uaGVhZGVyIG5hdiBhOmhvdmVyIHtcXHJcXG4gIGNvbG9yOiB2YXIoLS1wcmltYXJ5LWNvbG9yKTtcXHJcXG59XFxyXFxuXFxyXFxuLmhlYWRlciAubmF2LWl0ZW0ge1xcclxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbiAgZm9udC13ZWlnaHQ6IDUwMDtcXHJcXG59XFxyXFxuXFxyXFxuLmhlYWRlciAubmF2LWl0ZW0gLm5hdi1iYWRnZSB7XFxyXFxuICBiYWNrZ3JvdW5kOiB2YXIoLS1wcmltYXJ5LWNvbG9yKTtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDEwMHB4O1xcclxcbiAgYm94LXNoYWRvdzogMCAwIDdweCAzcHggIzAwMjdmZjtcXHJcXG4gIGhlaWdodDogNXB4O1xcclxcbiAgd2lkdGg6IDVweDtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIHRvcDogMDtcXHJcXG4gIHJpZ2h0OiA1cHg7XFxyXFxufVxcclxcblxcclxcbi5oZWFkZXIgLnJpZ2h0LWNvbnRlbnQgLmJ0biB7XFxyXFxuICBtYXJnaW46IDE1cHg7XFxyXFxufVxcclxcblxcclxcbi5oZWFkZXIgLnJpZ2h0LWNvbnRlbnQgYSB7XFxyXFxuICBtYXJnaW4tbGVmdDogMTVweDtcXHJcXG4gIGNvbG9yOiAjZmZmO1xcclxcbiAgZGlzcGxheTogYmxvY2s7XFxyXFxufVxcclxcblxcclxcbi5idG4ge1xcclxcbiAgYmFja2dyb3VuZDogdmFyKC0tcHJpbWFyeS1jb2xvcik7XFxyXFxuICBib3JkZXI6IG5vbmU7XFxyXFxuICBwYWRkaW5nOiAxMXB4IDIycHg7XFxyXFxuICBib3JkZXItcmFkaXVzOiAxMHB4O1xcclxcbiAgY29sb3I6ICNmZmY7XFxyXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxufVxcclxcblxcclxcbi5zZWFyY2gtYm94IHtcXHJcXG4gIGJhY2tncm91bmQ6IHZhcigtLXNlYXJjaC1ib3gtYmcpO1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gIHBhZGRpbmc6IDdweCAxMHB4O1xcclxcbiAgYm9yZGVyLXJhZGl1czogMTBweDtcXHJcXG59XFxyXFxuXFxyXFxuLnNlYXJjaC1ib3ggaW5wdXQge1xcclxcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxyXFxuICBjb2xvcjogI2ZmZjtcXHJcXG4gIHdpZHRoOiAxMDBweDtcXHJcXG59XFxyXFxuXFxyXFxuLnNlYXJjaC1ib3ggOjpwbGFjZWhvbGRlciB7XFxyXFxuICBjb2xvcjogIzQ3NGM1ZDtcXHJcXG4gIG1hcmdpbi1yaWdodDogMzBweDtcXHJcXG59XFxyXFxuXFxyXFxuLnNlYXJjaC1ib3ggc3ZnIHtcXHJcXG4gIHdpZHRoOiAyMHB4O1xcclxcbiAgaGVpZ2h0OiAyMHB4O1xcclxcbiAgbWFyZ2luLXJpZ2h0OiAxMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uc2VhcmNoLXNsYXNoLWJ0biB7XFxyXFxuICBiYWNrZ3JvdW5kOiAjN2Q4Mzk1O1xcclxcbiAgY29sb3I6ICNmZmY7XFxyXFxuICBib3JkZXItcmFkaXVzOiA2cHg7XFxyXFxuICB3aWR0aDogMzBweDtcXHJcXG4gIGhlaWdodDogMzBweDtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxyXFxuICBmb250LXNpemU6IDE0cHg7XFxyXFxufVxcclxcblxcclxcbi5mbGV4IHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxyXFxufVxcclxcblxcclxcbi5mbGV4LWJldHdlZW4ge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxyXFxufVxcclxcblxcclxcbi50ZXh0LWJ0biB7XFxyXFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXHJcXG4gIGN1cnNvcjogcG9pbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuLmZsZXgtc3RhcnQge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG59XFxyXFxuXFxyXFxudGFibGUge1xcclxcbiAgY29sb3I6ICNmZmY7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxyXFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcclxcbn1cXHJcXG5cXHJcXG50ciB7XFxyXFxuICBoZWlnaHQ6IHZhcigtLXRhYmxlLWhlaWdodCk7XFxyXFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgIzdkODM5NTFjO1xcclxcbiAgcGFkZGluZy1sZWZ0OiAyMHB4O1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcclxcbn1cXHJcXG5cXHJcXG4udGFibGUtcm93OmhvdmVyIHtcXHJcXG4gIGJhY2tncm91bmQ6ICMxOTFhMWY7XFxyXFxufVxcclxcblxcclxcbi50YWJsZS10aXRsZSBwIHtcXHJcXG4gIG1hcmdpbi1yaWdodDogNXB4O1xcclxcbn1cXHJcXG5cXHJcXG50YWJsZSB0ciB0ZDpsYXN0LWNoaWxkIHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAgaGVpZ2h0OiB2YXIoLS10YWJsZS1oZWlnaHQpO1xcclxcbiAgbWFyZ2luLWxlZnQ6IC03MHB4O1xcclxcbn1cXHJcXG5cXHJcXG50YWJsZSAuY2lyY3VsYXRpbmctc3VwcGx5LXZhbHVlIHtcXHJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gIHJpZ2h0OiAtMTAwcHg7XFxyXFxufVxcclxcblxcclxcbnRhYmxlIC52b2x1bWUtdmFsdWUge1xcclxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbiAgcmlnaHQ6IDQwcHg7XFxyXFxuICB0ZXh0LWFsaWduOiByaWdodDtcXHJcXG59XFxyXFxuXFxyXFxudGFibGUgLm1hcmtldC1jYXAtdmFsdWUge1xcclxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbiAgcmlnaHQ6IC00MHB4O1xcclxcbn1cXHJcXG5cXHJcXG50YWJsZSAudm9sdW1lLXZhbHVlIC5jb2luLWNyeXB0by12YWx1ZSB7XFxyXFxuICBmb250LXNpemU6IDEzcHg7XFxyXFxuICBtYXJnaW4tdG9wOiAzcHg7XFxyXFxufVxcclxcblxcclxcbnRhYmxlIC5idXktbGFiZWwge1xcclxcbiAgYmFja2dyb3VuZDogIzFhMjAzMztcXHJcXG4gIGNvbG9yOiAjNWM4MWYxO1xcclxcbiAgcGFkZGluZzogN3B4IDlweDtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDdweDtcXHJcXG4gIGZvbnQtc2l6ZTogMTJweDtcXHJcXG59XFxyXFxuXFxyXFxuLmZhZGUtdGV4dCB7XFxyXFxuICBvcGFjaXR5OiAwLjU7XFxyXFxufVxcclxcblxcclxcbi5yYXRlIHtcXHJcXG4gIHdpZHRoOiBtaW4tY29udGVudDtcXHJcXG59XFxyXFxuXFxyXFxuLnJhdGUgcCB7XFxyXFxuICBtYXJnaW4tbGVmdDogMTBweDtcXHJcXG59XFxyXFxuXFxyXFxuLmluY3JlbWVudC1yYXRlIHtcXHJcXG4gIGNvbG9yOiB2YXIoLS1ncmVlbik7XFxyXFxufVxcclxcblxcclxcbi5pbmNyZW1lbnQtcmF0ZSBzdmcge1xcclxcbiAgZmlsbDogdmFyKC0tZ3JlZW4pO1xcclxcbn1cXHJcXG5cXHJcXG4uZGVjcmVtZW50LXJhdGUge1xcclxcbiAgY29sb3I6IHZhcigtLXJlZCk7XFxyXFxufVxcclxcblxcclxcbi5kZWNyZW1lbnQtcmF0ZSBzdmcge1xcclxcbiAgZmlsbDogdmFyKC0tcmVkKTtcXHJcXG59XFxyXFxuXFxyXFxuLmluY3JlbWVudC1yYXRlIHN2ZyxcXHJcXG4uZGVjcmVtZW50LXJhdGUgc3ZnIHtcXHJcXG4gIG1hcmdpbi1yaWdodDogLTVweDtcXHJcXG59XFxyXFxuXFxyXFxudGQgLmZsZXgge1xcclxcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcclxcbn1cXHJcXG5cXHJcXG50ZCAuZmxleCBwIHtcXHJcXG4gIG1hcmdpbi1sZWZ0OiAxMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4udW5kZXJsaW5lIHtcXHJcXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcclxcbn1cXHJcXG5cXHJcXG4udHJlbmRpbmctY2FyZHMtY29udGFpbmVyIHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbn1cXHJcXG5cXHJcXG4udHJlbmRpbmctY2FyZCB7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIG1hcmdpbi1sZWZ0OiAyMHB4O1xcclxcbiAgYmFja2dyb3VuZDogdmFyKC0tdHJlbmRpbmctaXRlbS1iZyk7XFxyXFxuICBwYWRkaW5nOiAyMHB4O1xcclxcbiAgYm9yZGVyLXJhZGl1czogMTBweDtcXHJcXG4gIGNvbG9yOiAjZmZmO1xcclxcbn1cXHJcXG5cXHJcXG4udHJlbmRpbmctY2FyZDpmaXJzdC1jaGlsZCB7XFxyXFxuICBtYXJnaW4tbGVmdDogMDtcXHJcXG59XFxyXFxuXFxyXFxuLnRyZW5kaW5nLW1vcmUtYnRuIHtcXHJcXG4gIGNvbG9yOiB2YXIoLS1wcmltYXJ5LWNvbG9yKTtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcclxcbiAgd2lkdGg6IG1pbi1jb250ZW50O1xcclxcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXHJcXG4gIGN1cnNvcjogcG9pbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuLnRyZW5kaW5nLWNhcmQtcm93IHtcXHJcXG4gIG1hcmdpbi1ib3R0b206IDIwcHg7XFxyXFxufVxcclxcblxcclxcbi50cmVuZGluZy1jYXJkLXJvdzpsYXN0LWNoaWxkIHtcXHJcXG4gIG1hcmdpbi1ib3R0b206IDA7XFxyXFxufVxcclxcblxcclxcbi50cmVuZGluZy1jcnlwdG8tbmFtZS1pY29uIHtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIHBhZGRpbmctbGVmdDogMjBweDtcXHJcXG59XFxyXFxuXFxyXFxuLnRyZW5kaW5nLWNyeXB0by1uYW1lLWljb24gcCB7XFxyXFxuICBtYXJnaW4tbGVmdDogMjBweDtcXHJcXG59XFxyXFxuXFxyXFxuLnRyZW5kaW5nLW1vcmUtYnRuIHN2ZyB7XFxyXFxuICBmaWxsOiB2YXIoLS1wcmltYXJ5LWNvbG9yKTtcXHJcXG59XFxyXFxuXFxyXFxuLnN3aXRjaCB7XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxyXFxuICB3aWR0aDogNjBweDtcXHJcXG4gIGhlaWdodDogMzRweDtcXHJcXG59XFxyXFxuXFxyXFxuLnN3aXRjaCBpbnB1dCB7XFxyXFxuICBvcGFjaXR5OiAwO1xcclxcbiAgd2lkdGg6IDA7XFxyXFxuICBoZWlnaHQ6IDA7XFxyXFxufVxcclxcblxcclxcbi5zbGlkZXIge1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcclxcbiAgdG9wOiAwO1xcclxcbiAgbGVmdDogMDtcXHJcXG4gIHJpZ2h0OiAwO1xcclxcbiAgYm90dG9tOiAwO1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogI2NjYztcXHJcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogMC40cztcXHJcXG4gIHRyYW5zaXRpb246IDAuNHM7XFxyXFxufVxcclxcblxcclxcbi5zbGlkZXI6YmVmb3JlIHtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIGNvbnRlbnQ6ICcnO1xcclxcbiAgaGVpZ2h0OiAyNnB4O1xcclxcbiAgd2lkdGg6IDI2cHg7XFxyXFxuICBsZWZ0OiA0cHg7XFxyXFxuICBib3R0b206IDRweDtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcclxcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiAwLjRzO1xcclxcbiAgdHJhbnNpdGlvbjogMC40cztcXHJcXG59XFxyXFxuXFxyXFxuaW5wdXQ6Y2hlY2tlZCArIC5zbGlkZXIge1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogIzIxOTZmMztcXHJcXG59XFxyXFxuXFxyXFxuaW5wdXQ6Zm9jdXMgKyAuc2xpZGVyIHtcXHJcXG4gIGJveC1zaGFkb3c6IDAgMCAxcHggIzIxOTZmMztcXHJcXG59XFxyXFxuXFxyXFxuaW5wdXQ6Y2hlY2tlZCArIC5zbGlkZXI6YmVmb3JlIHtcXHJcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDI2cHgpO1xcclxcbiAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWCgyNnB4KTtcXHJcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgyNnB4KTtcXHJcXG59XFxyXFxuXFxyXFxuLnNsaWRlci5yb3VuZCB7XFxyXFxuICBib3JkZXItcmFkaXVzOiAzNHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uc2xpZGVyLnJvdW5kOmJlZm9yZSB7XFxyXFxuICBib3JkZXItcmFkaXVzOiA1MCU7XFxyXFxufVxcclxcblxcclxcbi5tb2RhbCB7XFxyXFxuICB3aWR0aDogMTAwdnc7XFxyXFxuICBoZWlnaHQ6IDEwMHZoO1xcclxcbiAgYmFja2dyb3VuZDogIzAwMDAwMDI0O1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gIGJhY2tkcm9wLWZpbHRlcjogYmx1cigyOHB4KTtcXHJcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXHJcXG4gIHRvcDogMDtcXHJcXG4gIGxlZnQ6IDA7XFxyXFxuICB6LWluZGV4OiAxMDA7XFxyXFxufVxcclxcblxcclxcbi53YWxsZXQtc2VsZWN0b3Ige1xcclxcbiAgYmFja2dyb3VuZDogdmFyKC0tdHJlbmRpbmctaXRlbS1iZyk7XFxyXFxuICB3aWR0aDogNTAwcHg7XFxyXFxuICBib3JkZXItcmFkaXVzOiAyMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4ud2FsbGV0LWl0ZW0ge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gIHBhZGRpbmc6IDIwcHg7XFxyXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2E5YWJiNTE3O1xcclxcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbi53YWxsZXQtaXRlbTpsYXN0LWNoaWxkIHtcXHJcXG4gIGJvcmRlcjogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuLndhbGxldC1pdGVtIHAge1xcclxcbiAgbWFyZ2luLWxlZnQ6IDIwcHg7XFxyXFxufVxcclxcblxcclxcbi53YWxsZXQtaXRlbTpob3ZlciB7XFxyXFxuICBiYWNrZ3JvdW5kOiAjMTcxOTFlMmU7XFxyXFxufVxcclxcblxcclxcbi5jbWMtY2hhdC1jb250YWluZXIge1xcclxcbiAgd2lkdGg6IDUwMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uY21jLWNoYXQge1xcclxcbiAgYmFja2dyb3VuZDogdmFyKC0tY21jLWNoYXQtYmcpO1xcclxcbiAgcGFkZGluZzogMjBweDtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxyXFxufVxcclxcblxcclxcbi5hdmF0YXItY29udGFpbmVyIHtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDEwMHB4O1xcclxcbiAgd2lkdGg6IDQwcHg7XFxyXFxuICBoZWlnaHQ6IDQwcHg7XFxyXFxuICBvdmVyZmxvdzogaGlkZGVuO1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuLmJ1bGxpc2gtbGFiZWwgc3ZnIHtcXHJcXG4gIGZpbGw6IHZhcigtLWdyZWVuKTtcXHJcXG59XFxyXFxuXFxyXFxuLmJlYXJpc2gtbGFiZWwgc3ZnIHtcXHJcXG4gIGZpbGw6IHZhcigtLXJlZCk7XFxyXFxufVxcclxcblxcclxcbi5idWxsaXNoLWxhYmVsLFxcclxcbi5iZWFyaXNoLWxhYmVsIHtcXHJcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNmZmZmZmYyNDtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDVweDtcXHJcXG4gIHBhZGRpbmc6IDJweCAxMXB4O1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIHdpZHRoOiBtaW4tY29udGVudDtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxufVxcclxcblxcclxcbi5idWxsaXNoLWxhYmVsIHN2ZyxcXHJcXG4uYmVhcmlzaC1sYWJlbCBzdmcge1xcclxcbiAgbWFyZ2luLXJpZ2h0OiA3cHg7XFxyXFxufVxcclxcblxcclxcbi5jbWMtY2hhdCAuaW5wdXQtYm94IHtcXHJcXG4gIGJhY2tncm91bmQ6IHZhcigtLXRyZW5kaW5nLWl0ZW0tYmcpO1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICBwYWRkaW5nOiAxN3B4O1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBib3JkZXItcmFkaXVzOiAxMHB4O1xcclxcbiAgbWFyZ2luOiAyNXB4IDA7XFxyXFxuICBjb2xvcjogdmFyKC0tcHJpbWFyeS1jb2xvcik7XFxyXFxufVxcclxcblxcclxcbi5jbWMtY2hhdCAuaW5wdXQtYm94IGlucHV0IHtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcbiAgaGVpZ2h0OiAzMXB4O1xcclxcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxyXFxuICBwYWRkaW5nOiAxMHB4O1xcclxcbiAgY29sb3I6ICNmZmY7XFxyXFxuICBmb250LXNpemU6IDE3cHg7XFxyXFxufVxcclxcblxcclxcbi5mbGV4LWhvcml6b250YWwtZW5kIHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcXHJcXG59XFxyXFxuXFxyXFxuLnRleHQtYWxpZ24tbGVmdCB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG59XFxyXFxuXFxyXFxuLmNoYXQtdXNlciB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcclxcbn1cXHJcXG5cXHJcXG4uY2hhdC11c2VyIC50ZXh0LWFsaWduLWxlZnQge1xcclxcbiAgbWFyZ2luLXRvcDogLTE3cHg7XFxyXFxuICBtYXJnaW4tbGVmdDogMTBweDtcXHJcXG59XFxyXFxuXFxyXFxuLmJ1bGxpc2gtZmlsbGVkIHtcXHJcXG4gIGJhY2tncm91bmQ6IHZhcigtLWdyZWVuKTtcXHJcXG59XFxyXFxuXFxyXFxuLmJ1bGxpc2gtZmlsbGVkIHN2ZyxcXHJcXG4uYmVhcmlzaC1maWxsZWQgc3ZnIHtcXHJcXG4gIGZpbGw6ICNmZmY7XFxyXFxufVxcclxcblxcclxcbi5iZWFyaXNoLWZpbGxlZCB7XFxyXFxuICBiYWNrZ3JvdW5kOiB2YXIoLS1yZWQpO1xcclxcbn1cXHJcXG5cXHJcXG4uY2hhdC1jYXJkIHtcXHJcXG4gIG1hcmdpbi10b3A6IDIwcHg7XFxyXFxuICBwYWRkaW5nLXRvcDogNTBweDtcXHJcXG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCB2YXIoLS10cmVuZGluZy1pdGVtLWJnKTtcXHJcXG59XFxyXFxuXFxyXFxuLmNoYXQtY2FyZCAuY2hhdC11c2VyIHtcXHJcXG4gIG1hcmdpbi1ib3R0b206IDIwcHg7XFxyXFxufVxcclxcblxcclxcbi5jaGF0LXVzZXItaW5mbyB7XFxyXFxuICB3aWR0aDogNDAwcHg7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXHJcXG59XFxyXFxuXFxyXFxuLnBvc3QtYWN0aW9uIHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAgY29sb3I6ICM2MTYzNmU7XFxyXFxufVxcclxcblxcclxcbi5wb3N0LWFjdGlvbiBzdmcge1xcclxcbiAgbWFyZ2luLXJpZ2h0OiAxMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4ucG9zdC1hY3Rpb25zLWNvbnRhaW5lciB7XFxyXFxuICBtYXJnaW4tdG9wOiAyMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4ucHJpY2UtY29udmVydGVyIHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcclxcbiAgYmFja2dyb3VuZDogIzE3MTkyNDtcXHJcXG4gIHBhZGRpbmc6IDI0cHggMjBweDtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDIwcHg7XFxyXFxuICBib3JkZXI6IDFweCBzb2xpZCAjZmZjOGM4MGY7XFxyXFxufSAqL1xcclxcblxcclxcbi5ob3ZlclxcXFw6YmctY3lhbi02MDA6aG92ZXIge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDggMTQ1IDE3OCAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuXFxyXFxuLmhvdmVyXFxcXDp0ZXh0LXJlZC0zMDA6aG92ZXIge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDI1MiAxNjUgMTY1IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcclxcblxcclxcbi5ob3ZlclxcXFw6b3BhY2l0eS01MDpob3ZlciB7XFxuICBvcGFjaXR5OiAwLjU7XFxufVxcclxcblxcclxcbi5ob3ZlclxcXFw6b3BhY2l0eS02MDpob3ZlciB7XFxuICBvcGFjaXR5OiAwLjY7XFxufVxcclxcblxcclxcbi5ob3ZlclxcXFw6c2hhZG93LWxnOmhvdmVyIHtcXG4gIC0tdHctc2hhZG93OiAwIDEwcHggMTVweCAtM3B4IHJnYigwIDAgMCAvIDAuMSksIDAgNHB4IDZweCAtNHB4IHJnYigwIDAgMCAvIDAuMSk7XFxuICAtLXR3LXNoYWRvdy1jb2xvcmVkOiAwIDEwcHggMTVweCAtM3B4IHZhcigtLXR3LXNoYWRvdy1jb2xvciksIDAgNHB4IDZweCAtNHB4IHZhcigtLXR3LXNoYWRvdy1jb2xvcik7XFxuICBib3gtc2hhZG93OiB2YXIoLS10dy1yaW5nLW9mZnNldC1zaGFkb3csIDAgMCAjMDAwMCksIHZhcigtLXR3LXJpbmctc2hhZG93LCAwIDAgIzAwMDApLCB2YXIoLS10dy1zaGFkb3cpO1xcbn1cXHJcXG5cXHJcXG4uZm9jdXNcXFxcOmJnLWN5YW4tNjAwOmZvY3VzIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYig4IDE0NSAxNzggLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcblxcclxcbi5mb2N1c1xcXFw6c2hhZG93LWxnOmZvY3VzIHtcXG4gIC0tdHctc2hhZG93OiAwIDEwcHggMTVweCAtM3B4IHJnYigwIDAgMCAvIDAuMSksIDAgNHB4IDZweCAtNHB4IHJnYigwIDAgMCAvIDAuMSk7XFxuICAtLXR3LXNoYWRvdy1jb2xvcmVkOiAwIDEwcHggMTVweCAtM3B4IHZhcigtLXR3LXNoYWRvdy1jb2xvciksIDAgNHB4IDZweCAtNHB4IHZhcigtLXR3LXNoYWRvdy1jb2xvcik7XFxuICBib3gtc2hhZG93OiB2YXIoLS10dy1yaW5nLW9mZnNldC1zaGFkb3csIDAgMCAjMDAwMCksIHZhcigtLXR3LXJpbmctc2hhZG93LCAwIDAgIzAwMDApLCB2YXIoLS10dy1zaGFkb3cpO1xcbn1cXHJcXG5cXHJcXG4uZm9jdXNcXFxcOm91dGxpbmUtbm9uZTpmb2N1cyB7XFxuICBvdXRsaW5lOiAycHggc29saWQgdHJhbnNwYXJlbnQ7XFxuICBvdXRsaW5lLW9mZnNldDogMnB4O1xcbn1cXHJcXG5cXHJcXG4uZm9jdXNcXFxcOnJpbmctMDpmb2N1cyB7XFxuICAtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdzogdmFyKC0tdHctcmluZy1pbnNldCkgMCAwIDAgdmFyKC0tdHctcmluZy1vZmZzZXQtd2lkdGgpIHZhcigtLXR3LXJpbmctb2Zmc2V0LWNvbG9yKTtcXG4gIC0tdHctcmluZy1zaGFkb3c6IHZhcigtLXR3LXJpbmctaW5zZXQpIDAgMCAwIGNhbGMoMHB4ICsgdmFyKC0tdHctcmluZy1vZmZzZXQtd2lkdGgpKSB2YXIoLS10dy1yaW5nLWNvbG9yKTtcXG4gIGJveC1zaGFkb3c6IHZhcigtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdyksIHZhcigtLXR3LXJpbmctc2hhZG93KSwgdmFyKC0tdHctc2hhZG93LCAwIDAgIzAwMDApO1xcbn1cXHJcXG5cXHJcXG4uYWN0aXZlXFxcXDpiZy1yZWQtMzAwOmFjdGl2ZSB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjUyIDE2NSAxNjUgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcclxcblxcclxcbi5hY3RpdmVcXFxcOmJnLWdyZWVuLTYwMDphY3RpdmUge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDIyIDE2MyA3NCAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuXFxyXFxuLmFjdGl2ZVxcXFw6YmctcmVkLTUwMDphY3RpdmUge1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDIzOSA2OCA2OCAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxyXFxuXFxyXFxuLmFjdGl2ZVxcXFw6c2hhZG93LWxnOmFjdGl2ZSB7XFxuICAtLXR3LXNoYWRvdzogMCAxMHB4IDE1cHggLTNweCByZ2IoMCAwIDAgLyAwLjEpLCAwIDRweCA2cHggLTRweCByZ2IoMCAwIDAgLyAwLjEpO1xcbiAgLS10dy1zaGFkb3ctY29sb3JlZDogMCAxMHB4IDE1cHggLTNweCB2YXIoLS10dy1zaGFkb3ctY29sb3IpLCAwIDRweCA2cHggLTRweCB2YXIoLS10dy1zaGFkb3ctY29sb3IpO1xcbiAgYm94LXNoYWRvdzogdmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93LCAwIDAgIzAwMDApLCB2YXIoLS10dy1yaW5nLXNoYWRvdywgMCAwICMwMDAwKSwgdmFyKC0tdHctc2hhZG93KTtcXG59XFxyXFxuXFxyXFxuQG1lZGlhIChtaW4td2lkdGg6IDY0MHB4KSB7XFxuXFxuICAuc21cXFxcOmdyaWQtY29scy0xIHtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMSwgbWlubWF4KDAsIDFmcikpO1xcbiAgfVxcbn1cXHJcXG5cXHJcXG5AbWVkaWEgKG1pbi13aWR0aDogNzY4cHgpIHtcXG5cXG4gIC5tZFxcXFw6Z3JpZC1jb2xzLTMge1xcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCgzLCBtaW5tYXgoMCwgMWZyKSk7XFxuICB9XFxufVxcclxcblxcclxcbkBtZWRpYSAobWluLXdpZHRoOiAxMDI0cHgpIHtcXG5cXG4gIC5sZ1xcXFw6Z3JpZC1jb2xzLTMge1xcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCgzLCBtaW5tYXgoMCwgMWZyKSk7XFxuICB9XFxufVxcclxcblxcclxcbkBtZWRpYSAobWluLXdpZHRoOiAxMjgwcHgpIHtcXG5cXG4gIC54bFxcXFw6Z3JpZC1jb2xzLTMge1xcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCgzLCBtaW5tYXgoMCwgMWZyKSk7XFxuICB9XFxufVxcclxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9zdHlsZXMvZ2xvYmFscy5jc3NcIixcIjxubyBzb3VyY2U+XCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBOztDQUFjLENBQWQ7OztDQUFjOztBQUFkOzs7RUFBQSxzQkFBYyxFQUFkLE1BQWM7RUFBZCxlQUFjLEVBQWQsTUFBYztFQUFkLG1CQUFjLEVBQWQsTUFBYztFQUFkLHFCQUFjLEVBQWQsTUFBYztBQUFBOztBQUFkOztFQUFBLGdCQUFjO0FBQUE7O0FBQWQ7Ozs7O0NBQWM7O0FBQWQ7RUFBQSxnQkFBYyxFQUFkLE1BQWM7RUFBZCw4QkFBYyxFQUFkLE1BQWM7RUFBZCxnQkFBYyxFQUFkLE1BQWM7RUFBZCxjQUFjO0tBQWQsV0FBYyxFQUFkLE1BQWM7RUFBZCw0TkFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7O0NBQWM7O0FBQWQ7RUFBQSxTQUFjLEVBQWQsTUFBYztFQUFkLG9CQUFjLEVBQWQsTUFBYztBQUFBOztBQUFkOzs7O0NBQWM7O0FBQWQ7RUFBQSxTQUFjLEVBQWQsTUFBYztFQUFkLGNBQWMsRUFBZCxNQUFjO0VBQWQscUJBQWMsRUFBZCxNQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7RUFBQSx5Q0FBYztVQUFkLGlDQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7Ozs7OztFQUFBLGtCQUFjO0VBQWQsb0JBQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLGNBQWM7RUFBZCx3QkFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkOztFQUFBLG1CQUFjO0FBQUE7O0FBQWQ7OztDQUFjOztBQUFkOzs7O0VBQUEsK0dBQWMsRUFBZCxNQUFjO0VBQWQsY0FBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLGNBQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDs7RUFBQSxjQUFjO0VBQWQsY0FBYztFQUFkLGtCQUFjO0VBQWQsd0JBQWM7QUFBQTs7QUFBZDtFQUFBLGVBQWM7QUFBQTs7QUFBZDtFQUFBLFdBQWM7QUFBQTs7QUFBZDs7OztDQUFjOztBQUFkO0VBQUEsY0FBYyxFQUFkLE1BQWM7RUFBZCxxQkFBYyxFQUFkLE1BQWM7RUFBZCx5QkFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7OztDQUFjOztBQUFkOzs7OztFQUFBLG9CQUFjLEVBQWQsTUFBYztFQUFkLGVBQWMsRUFBZCxNQUFjO0VBQWQsb0JBQWMsRUFBZCxNQUFjO0VBQWQsb0JBQWMsRUFBZCxNQUFjO0VBQWQsY0FBYyxFQUFkLE1BQWM7RUFBZCxTQUFjLEVBQWQsTUFBYztFQUFkLFVBQWMsRUFBZCxNQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7O0VBQUEsb0JBQWM7QUFBQTs7QUFBZDs7O0NBQWM7O0FBQWQ7Ozs7RUFBQSwwQkFBYyxFQUFkLE1BQWM7RUFBZCw2QkFBYyxFQUFkLE1BQWM7RUFBZCxzQkFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLGFBQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLGdCQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7RUFBQSx3QkFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkOztFQUFBLFlBQWM7QUFBQTs7QUFBZDs7O0NBQWM7O0FBQWQ7RUFBQSw2QkFBYyxFQUFkLE1BQWM7RUFBZCxvQkFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLHdCQUFjO0FBQUE7O0FBQWQ7OztDQUFjOztBQUFkO0VBQUEsMEJBQWMsRUFBZCxNQUFjO0VBQWQsYUFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLGtCQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7Ozs7Ozs7Ozs7Ozs7RUFBQSxTQUFjO0FBQUE7O0FBQWQ7RUFBQSxTQUFjO0VBQWQsVUFBYztBQUFBOztBQUFkO0VBQUEsVUFBYztBQUFBOztBQUFkOzs7RUFBQSxnQkFBYztFQUFkLFNBQWM7RUFBZCxVQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7RUFBQSxnQkFBYztBQUFBOztBQUFkOzs7Q0FBYzs7QUFBZDtFQUFBLFVBQWMsRUFBZCxNQUFjO0VBQWQsY0FBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7RUFBQSxVQUFjLEVBQWQsTUFBYztFQUFkLGNBQWMsRUFBZCxNQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7O0VBQUEsZUFBYztBQUFBOztBQUFkOztDQUFjO0FBQWQ7RUFBQSxlQUFjO0FBQUE7O0FBQWQ7Ozs7Q0FBYzs7QUFBZDs7Ozs7Ozs7RUFBQSxjQUFjLEVBQWQsTUFBYztFQUFkLHNCQUFjLEVBQWQsTUFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkOztFQUFBLGVBQWM7RUFBZCxZQUFjO0FBQUE7O0FBQWQ7RUFBQSx3QkFBYztFQUFkLHdCQUFjO0VBQWQsbUJBQWM7RUFBZCxtQkFBYztFQUFkLGNBQWM7RUFBZCxjQUFjO0VBQWQsY0FBYztFQUFkLGVBQWM7RUFBZCxlQUFjO0VBQWQsYUFBYztFQUFkLGFBQWM7RUFBZCxrQkFBYztFQUFkLHNDQUFjO0VBQWQsZUFBYztFQUFkLG9CQUFjO0VBQWQsc0JBQWM7RUFBZCx1QkFBYztFQUFkLHdCQUFjO0VBQWQsa0JBQWM7RUFBZCwyQkFBYztFQUFkLDRCQUFjO0VBQWQsc0NBQWM7RUFBZCxrQ0FBYztFQUFkLDJCQUFjO0VBQWQsc0JBQWM7RUFBZCw4QkFBYztFQUFkLFlBQWM7RUFBZCxrQkFBYztFQUFkLGdCQUFjO0VBQWQsaUJBQWM7RUFBZCxrQkFBYztFQUFkLGNBQWM7RUFBZCxnQkFBYztFQUFkLGFBQWM7RUFBZCxtQkFBYztFQUFkLHFCQUFjO0VBQWQsMkJBQWM7RUFBZCx5QkFBYztFQUFkLDBCQUFjO0VBQWQsMkJBQWM7RUFBZCx1QkFBYztFQUFkLHdCQUFjO0VBQWQseUJBQWM7RUFBZDtBQUFjOztBQUFkO0VBQUEsd0JBQWM7RUFBZCx3QkFBYztFQUFkLG1CQUFjO0VBQWQsbUJBQWM7RUFBZCxjQUFjO0VBQWQsY0FBYztFQUFkLGNBQWM7RUFBZCxlQUFjO0VBQWQsZUFBYztFQUFkLGFBQWM7RUFBZCxhQUFjO0VBQWQsa0JBQWM7RUFBZCxzQ0FBYztFQUFkLGVBQWM7RUFBZCxvQkFBYztFQUFkLHNCQUFjO0VBQWQsdUJBQWM7RUFBZCx3QkFBYztFQUFkLGtCQUFjO0VBQWQsMkJBQWM7RUFBZCw0QkFBYztFQUFkLHNDQUFjO0VBQWQsa0NBQWM7RUFBZCwyQkFBYztFQUFkLHNCQUFjO0VBQWQsOEJBQWM7RUFBZCxZQUFjO0VBQWQsa0JBQWM7RUFBZCxnQkFBYztFQUFkLGlCQUFjO0VBQWQsa0JBQWM7RUFBZCxjQUFjO0VBQWQsZ0JBQWM7RUFBZCxhQUFjO0VBQWQsbUJBQWM7RUFBZCxxQkFBYztFQUFkLDJCQUFjO0VBQWQseUJBQWM7RUFBZCwwQkFBYztFQUFkLDJCQUFjO0VBQWQsdUJBQWM7RUFBZCx3QkFBYztFQUFkLHlCQUFjO0VBQWQ7QUFBYztBQUNkO0VBQUE7QUFBb0I7QUFBcEI7O0VBQUE7SUFBQTtFQUFvQjtBQUFBO0FBQXBCOztFQUFBO0lBQUE7RUFBb0I7QUFBQTtBQUFwQjs7RUFBQTtJQUFBO0VBQW9CO0FBQUE7QUFBcEI7O0VBQUE7SUFBQTtFQUFvQjtBQUFBO0FBQXBCOztFQUFBO0lBQUE7RUFBb0I7QUFBQTtBQUNwQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxpQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxpQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxnQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsd0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsdUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSx1QkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLHVCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxzQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxzQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxzQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxzQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEscUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsbUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsaUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEscUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEscUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLGVBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsZUFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxpQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsdUNBQW1CO1VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSwrRUFBbUI7RUFBbkIsbUdBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsOEJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsMkdBQW1CO0VBQW5CLHlHQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsd0tBQW1CO0VBQW5CLHdKQUFtQjtFQUFuQixnTkFBbUI7RUFBbkIsd0RBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjs7QUFFbkIsMkhBQTJIO0FBQzNILDJHQUEyRzs7QUFFM0c7RUFDRSx3REFBd0Q7RUFDeEQsWUFBWTtFQUNaLFlBQVk7QUFDZDs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBOGlCRzs7QUEzakJIO0VBQUEsbUJDQUE7RURBQTtDQ0FBOztBREFBO0VBQUEscUJDQUE7RURBQTtDQ0FBOztBREFBO0VBQUE7Q0NBQTs7QURBQTtFQUFBO0NDQUE7O0FEQUE7RUFBQSxnRkNBQTtFREFBLG9HQ0FBO0VEQUE7Q0NBQTs7QURBQTtFQUFBLG1CQ0FBO0VEQUE7Q0NBQTs7QURBQTtFQUFBLGdGQ0FBO0VEQUEsb0dDQUE7RURBQTtDQ0FBOztBREFBO0VBQUEsK0JDQUE7RURBQTtDQ0FBOztBREFBO0VBQUEsNEdDQUE7RURBQSwwR0NBQTtFREFBO0NDQUE7O0FEQUE7RUFBQSxtQkNBQTtFREFBO0NDQUE7O0FEQUE7RUFBQSxtQkNBQTtFREFBO0NDQUE7O0FEQUE7RUFBQSxtQkNBQTtFREFBO0NDQUE7O0FEQUE7RUFBQSxnRkNBQTtFREFBLG9HQ0FBO0VEQUE7Q0NBQTs7QURBQTs7RUFBQTtJQUFBO0dDQUE7Q0FBQTs7QURBQTs7RUFBQTtJQUFBO0dDQUE7Q0FBQTs7QURBQTs7RUFBQTtJQUFBO0dDQUE7Q0FBQTs7QURBQTs7RUFBQTtJQUFBO0dDQUE7Q0FBQVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJAdGFpbHdpbmQgYmFzZTtcXHJcXG5AdGFpbHdpbmQgY29tcG9uZW50cztcXHJcXG5AdGFpbHdpbmQgdXRpbGl0aWVzO1xcclxcblxcclxcbi8qIEBpbXBvcnQgdXJsKCdodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2NzczI/ZmFtaWx5PVBvcHBpbnM6d2dodEAxMDA7MjAwOzMwMDs0MDA7NTAwOzYwMDs3MDA7ODAwOzkwMCZkaXNwbGF5PXN3YXAnKTsgKi9cXHJcXG4vKiBAaW1wb3J0IHVybCgnaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3MyP2ZhbWlseT1GcmVkb2thOndnaHRAMzAwOzQwMDs1MDA7NjAwOzcwMCZkaXNwbGF5PXN3YXAnKTsgKi9cXHJcXG5cXHJcXG5ib2R5IHtcXHJcXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byBib3R0b20sICMwYTBiMGMsICMwMDAwMDApO1xcclxcbiAgaGVpZ2h0OiAxMDAlO1xcclxcbiAgd2lkdGg6IDEwMHZ3O1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbioge1xcclxcbiAgZm9udC1mYW1pbHk6ICdGcmVkb2thJywgLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCAnU2Vnb2UgVUknLCBSb2JvdG8sXFxyXFxuICAgIE94eWdlbiwgVWJ1bnR1LCBDYW50YXJlbGwsICdPcGVuIFNhbnMnLCAnSGVsdmV0aWNhIE5ldWUnLCBzYW5zLXNlcmlmO1xcclxcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG4gIGxpc3Qtc3R5bGU6IG5vbmU7XFxyXFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxyXFxuICBwYWRkaW5nOiAwO1xcclxcbiAgbWFyZ2luOiAwO1xcclxcbiAgb3V0bGluZTogbm9uZTtcXHJcXG4gIGJvcmRlcjogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuYm9keSB7XFxyXFxuICBtaW4taGVpZ2h0OiAxMDB2aDtcXHJcXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byBib3R0b20sICMxZjIyMmIsICMxNzE3MWEpO1xcclxcbiAgZm9udC1zaXplOiAwLjk3cmVtO1xcclxcbiAgY29sb3I6ICNmZmY7XFxyXFxufVxcclxcblxcclxcbmEge1xcclxcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbjpyb290IHtcXHJcXG4gIC0taGVhZGVyLWJnOiAjMTcxNzFhO1xcclxcbiAgLS1wcmltYXJ5LWNvbG9yOiAjMzg2MWZiO1xcclxcbiAgLS1zZWFyY2gtYm94LWJnOiAjMTgxOTI0O1xcclxcbiAgLS1ncmVlbjogIzE2Yzc4NDtcXHJcXG4gIC0tcmVkOiAjZWEzOTQzO1xcclxcbiAgLS10YWJsZS1oZWlnaHQ6IDgwcHg7XFxyXFxuICAtLXRyZW5kaW5nLWl0ZW0tYmc6ICMzMjM1NDY7XFxyXFxuICAtLWNtYy1jaGF0LWJnOiAjMjIyNTMxO1xcclxcbiAgb3ZlcmZsb3cteDogaGlkZGVuO1xcclxcbn1cXHJcXG5cXHJcXG4uaGVhZGVyIHtcXHJcXG4gIGJhY2tncm91bmQ6IHZhcigtLWhlYWRlci1iZyk7XFxyXFxuICBjb2xvcjogI2ZmZjtcXHJcXG4gIGhlaWdodDogODBweDtcXHJcXG59XFxyXFxuXFxyXFxuLmhlYWRlci13cmFwcGVyLFxcclxcbi5jbWMtdGFibGUtd3JhcHBlcixcXHJcXG4uY21jLXRyZW5kaW5nLXdyYXBwZXIsXFxyXFxubWFpbiB7XFxyXFxuICBtYXJnaW46IGF1dG87XFxyXFxuICBtYXgtd2lkdGg6IDEzMDBweDtcXHJcXG59XFxyXFxuXFxyXFxuLmhlYWRlci13cmFwcGVyIHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcclxcbiAgaGVpZ2h0OiAxMDAlO1xcclxcbn1cXHJcXG5cXHJcXG4uaGVhZGVyIG5hdiB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXHJcXG59XFxyXFxuXFxyXFxuLmhlYWRlciBuYXYgYSB7XFxyXFxuICBjb2xvcjogI2ZmZjtcXHJcXG4gIHBhZGRpbmc6IDE2cHg7XFxyXFxufVxcclxcblxcclxcbi5oZWFkZXIgbmF2IGE6aG92ZXIge1xcclxcbiAgY29sb3I6IHZhcigtLXByaW1hcnktY29sb3IpO1xcclxcbn1cXHJcXG5cXHJcXG4uaGVhZGVyIC5uYXYtaXRlbSB7XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuICBmb250LXdlaWdodDogNTAwO1xcclxcbn1cXHJcXG5cXHJcXG4uaGVhZGVyIC5uYXYtaXRlbSAubmF2LWJhZGdlIHtcXHJcXG4gIGJhY2tncm91bmQ6IHZhcigtLXByaW1hcnktY29sb3IpO1xcclxcbiAgYm9yZGVyLXJhZGl1czogMTAwcHg7XFxyXFxuICBib3gtc2hhZG93OiAwIDAgN3B4IDNweCAjMDAyN2ZmO1xcclxcbiAgaGVpZ2h0OiA1cHg7XFxyXFxuICB3aWR0aDogNXB4O1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgdG9wOiAwO1xcclxcbiAgcmlnaHQ6IDVweDtcXHJcXG59XFxyXFxuXFxyXFxuLmhlYWRlciAucmlnaHQtY29udGVudCAuYnRuIHtcXHJcXG4gIG1hcmdpbjogMTVweDtcXHJcXG59XFxyXFxuXFxyXFxuLmhlYWRlciAucmlnaHQtY29udGVudCBhIHtcXHJcXG4gIG1hcmdpbi1sZWZ0OiAxNXB4O1xcclxcbiAgY29sb3I6ICNmZmY7XFxyXFxuICBkaXNwbGF5OiBibG9jaztcXHJcXG59XFxyXFxuXFxyXFxuLmJ0biB7XFxyXFxuICBiYWNrZ3JvdW5kOiB2YXIoLS1wcmltYXJ5LWNvbG9yKTtcXHJcXG4gIGJvcmRlcjogbm9uZTtcXHJcXG4gIHBhZGRpbmc6IDExcHggMjJweDtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxyXFxuICBjb2xvcjogI2ZmZjtcXHJcXG4gIGN1cnNvcjogcG9pbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuLnNlYXJjaC1ib3gge1xcclxcbiAgYmFja2dyb3VuZDogdmFyKC0tc2VhcmNoLWJveC1iZyk7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcbiAgcGFkZGluZzogN3B4IDEwcHg7XFxyXFxuICBib3JkZXItcmFkaXVzOiAxMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uc2VhcmNoLWJveCBpbnB1dCB7XFxyXFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXHJcXG4gIGNvbG9yOiAjZmZmO1xcclxcbiAgd2lkdGg6IDEwMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uc2VhcmNoLWJveCA6OnBsYWNlaG9sZGVyIHtcXHJcXG4gIGNvbG9yOiAjNDc0YzVkO1xcclxcbiAgbWFyZ2luLXJpZ2h0OiAzMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uc2VhcmNoLWJveCBzdmcge1xcclxcbiAgd2lkdGg6IDIwcHg7XFxyXFxuICBoZWlnaHQ6IDIwcHg7XFxyXFxuICBtYXJnaW4tcmlnaHQ6IDEwcHg7XFxyXFxufVxcclxcblxcclxcbi5zZWFyY2gtc2xhc2gtYnRuIHtcXHJcXG4gIGJhY2tncm91bmQ6ICM3ZDgzOTU7XFxyXFxuICBjb2xvcjogI2ZmZjtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDZweDtcXHJcXG4gIHdpZHRoOiAzMHB4O1xcclxcbiAgaGVpZ2h0OiAzMHB4O1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gIGZvbnQtc2l6ZTogMTRweDtcXHJcXG59XFxyXFxuXFxyXFxuLmZsZXgge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuLmZsZXgtYmV0d2VlbiB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXHJcXG59XFxyXFxuXFxyXFxuLnRleHQtYnRuIHtcXHJcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcclxcbn1cXHJcXG5cXHJcXG4uZmxleC1zdGFydCB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbn1cXHJcXG5cXHJcXG50YWJsZSB7XFxyXFxuICBjb2xvcjogI2ZmZjtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcbiAgdGV4dC1hbGlnbjogbGVmdDtcXHJcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxyXFxufVxcclxcblxcclxcbnRyIHtcXHJcXG4gIGhlaWdodDogdmFyKC0tdGFibGUtaGVpZ2h0KTtcXHJcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjN2Q4Mzk1MWM7XFxyXFxuICBwYWRkaW5nLWxlZnQ6IDIwcHg7XFxyXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxufVxcclxcblxcclxcbi50YWJsZS1yb3c6aG92ZXIge1xcclxcbiAgYmFja2dyb3VuZDogIzE5MWExZjtcXHJcXG59XFxyXFxuXFxyXFxuLnRhYmxlLXRpdGxlIHAge1xcclxcbiAgbWFyZ2luLXJpZ2h0OiA1cHg7XFxyXFxufVxcclxcblxcclxcbnRhYmxlIHRyIHRkOmxhc3QtY2hpbGQge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBoZWlnaHQ6IHZhcigtLXRhYmxlLWhlaWdodCk7XFxyXFxuICBtYXJnaW4tbGVmdDogLTcwcHg7XFxyXFxufVxcclxcblxcclxcbnRhYmxlIC5jaXJjdWxhdGluZy1zdXBwbHktdmFsdWUge1xcclxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbiAgcmlnaHQ6IC0xMDBweDtcXHJcXG59XFxyXFxuXFxyXFxudGFibGUgLnZvbHVtZS12YWx1ZSB7XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuICByaWdodDogNDBweDtcXHJcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcclxcbn1cXHJcXG5cXHJcXG50YWJsZSAubWFya2V0LWNhcC12YWx1ZSB7XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuICByaWdodDogLTQwcHg7XFxyXFxufVxcclxcblxcclxcbnRhYmxlIC52b2x1bWUtdmFsdWUgLmNvaW4tY3J5cHRvLXZhbHVlIHtcXHJcXG4gIGZvbnQtc2l6ZTogMTNweDtcXHJcXG4gIG1hcmdpbi10b3A6IDNweDtcXHJcXG59XFxyXFxuXFxyXFxudGFibGUgLmJ1eS1sYWJlbCB7XFxyXFxuICBiYWNrZ3JvdW5kOiAjMWEyMDMzO1xcclxcbiAgY29sb3I6ICM1YzgxZjE7XFxyXFxuICBwYWRkaW5nOiA3cHggOXB4O1xcclxcbiAgYm9yZGVyLXJhZGl1czogN3B4O1xcclxcbiAgZm9udC1zaXplOiAxMnB4O1xcclxcbn1cXHJcXG5cXHJcXG4uZmFkZS10ZXh0IHtcXHJcXG4gIG9wYWNpdHk6IDAuNTtcXHJcXG59XFxyXFxuXFxyXFxuLnJhdGUge1xcclxcbiAgd2lkdGg6IG1pbi1jb250ZW50O1xcclxcbn1cXHJcXG5cXHJcXG4ucmF0ZSBwIHtcXHJcXG4gIG1hcmdpbi1sZWZ0OiAxMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uaW5jcmVtZW50LXJhdGUge1xcclxcbiAgY29sb3I6IHZhcigtLWdyZWVuKTtcXHJcXG59XFxyXFxuXFxyXFxuLmluY3JlbWVudC1yYXRlIHN2ZyB7XFxyXFxuICBmaWxsOiB2YXIoLS1ncmVlbik7XFxyXFxufVxcclxcblxcclxcbi5kZWNyZW1lbnQtcmF0ZSB7XFxyXFxuICBjb2xvcjogdmFyKC0tcmVkKTtcXHJcXG59XFxyXFxuXFxyXFxuLmRlY3JlbWVudC1yYXRlIHN2ZyB7XFxyXFxuICBmaWxsOiB2YXIoLS1yZWQpO1xcclxcbn1cXHJcXG5cXHJcXG4uaW5jcmVtZW50LXJhdGUgc3ZnLFxcclxcbi5kZWNyZW1lbnQtcmF0ZSBzdmcge1xcclxcbiAgbWFyZ2luLXJpZ2h0OiAtNXB4O1xcclxcbn1cXHJcXG5cXHJcXG50ZCAuZmxleCB7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxyXFxufVxcclxcblxcclxcbnRkIC5mbGV4IHAge1xcclxcbiAgbWFyZ2luLWxlZnQ6IDEwcHg7XFxyXFxufVxcclxcblxcclxcbi51bmRlcmxpbmUge1xcclxcbiAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxyXFxufVxcclxcblxcclxcbi50cmVuZGluZy1jYXJkcy1jb250YWluZXIge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxufVxcclxcblxcclxcbi50cmVuZGluZy1jYXJkIHtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcbiAgbWFyZ2luLWxlZnQ6IDIwcHg7XFxyXFxuICBiYWNrZ3JvdW5kOiB2YXIoLS10cmVuZGluZy1pdGVtLWJnKTtcXHJcXG4gIHBhZGRpbmc6IDIwcHg7XFxyXFxuICBib3JkZXItcmFkaXVzOiAxMHB4O1xcclxcbiAgY29sb3I6ICNmZmY7XFxyXFxufVxcclxcblxcclxcbi50cmVuZGluZy1jYXJkOmZpcnN0LWNoaWxkIHtcXHJcXG4gIG1hcmdpbi1sZWZ0OiAwO1xcclxcbn1cXHJcXG5cXHJcXG4udHJlbmRpbmctbW9yZS1idG4ge1xcclxcbiAgY29sb3I6IHZhcigtLXByaW1hcnktY29sb3IpO1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxyXFxuICB3aWR0aDogbWluLWNvbnRlbnQ7XFxyXFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcclxcbn1cXHJcXG5cXHJcXG4udHJlbmRpbmctY2FyZC1yb3cge1xcclxcbiAgbWFyZ2luLWJvdHRvbTogMjBweDtcXHJcXG59XFxyXFxuXFxyXFxuLnRyZW5kaW5nLWNhcmQtcm93Omxhc3QtY2hpbGQge1xcclxcbiAgbWFyZ2luLWJvdHRvbTogMDtcXHJcXG59XFxyXFxuXFxyXFxuLnRyZW5kaW5nLWNyeXB0by1uYW1lLWljb24ge1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgcGFkZGluZy1sZWZ0OiAyMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4udHJlbmRpbmctY3J5cHRvLW5hbWUtaWNvbiBwIHtcXHJcXG4gIG1hcmdpbi1sZWZ0OiAyMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4udHJlbmRpbmctbW9yZS1idG4gc3ZnIHtcXHJcXG4gIGZpbGw6IHZhcigtLXByaW1hcnktY29sb3IpO1xcclxcbn1cXHJcXG5cXHJcXG4uc3dpdGNoIHtcXHJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXHJcXG4gIHdpZHRoOiA2MHB4O1xcclxcbiAgaGVpZ2h0OiAzNHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uc3dpdGNoIGlucHV0IHtcXHJcXG4gIG9wYWNpdHk6IDA7XFxyXFxuICB3aWR0aDogMDtcXHJcXG4gIGhlaWdodDogMDtcXHJcXG59XFxyXFxuXFxyXFxuLnNsaWRlciB7XFxyXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuICB0b3A6IDA7XFxyXFxuICBsZWZ0OiAwO1xcclxcbiAgcmlnaHQ6IDA7XFxyXFxuICBib3R0b206IDA7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2NjO1xcclxcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiAwLjRzO1xcclxcbiAgdHJhbnNpdGlvbjogMC40cztcXHJcXG59XFxyXFxuXFxyXFxuLnNsaWRlcjpiZWZvcmUge1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgY29udGVudDogJyc7XFxyXFxuICBoZWlnaHQ6IDI2cHg7XFxyXFxuICB3aWR0aDogMjZweDtcXHJcXG4gIGxlZnQ6IDRweDtcXHJcXG4gIGJvdHRvbTogNHB4O1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxyXFxuICAtd2Via2l0LXRyYW5zaXRpb246IDAuNHM7XFxyXFxuICB0cmFuc2l0aW9uOiAwLjRzO1xcclxcbn1cXHJcXG5cXHJcXG5pbnB1dDpjaGVja2VkICsgLnNsaWRlciB7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjE5NmYzO1xcclxcbn1cXHJcXG5cXHJcXG5pbnB1dDpmb2N1cyArIC5zbGlkZXIge1xcclxcbiAgYm94LXNoYWRvdzogMCAwIDFweCAjMjE5NmYzO1xcclxcbn1cXHJcXG5cXHJcXG5pbnB1dDpjaGVja2VkICsgLnNsaWRlcjpiZWZvcmUge1xcclxcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMjZweCk7XFxyXFxuICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDI2cHgpO1xcclxcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDI2cHgpO1xcclxcbn1cXHJcXG5cXHJcXG4uc2xpZGVyLnJvdW5kIHtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDM0cHg7XFxyXFxufVxcclxcblxcclxcbi5zbGlkZXIucm91bmQ6YmVmb3JlIHtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXHJcXG59XFxyXFxuXFxyXFxuLm1vZGFsIHtcXHJcXG4gIHdpZHRoOiAxMDB2dztcXHJcXG4gIGhlaWdodDogMTAwdmg7XFxyXFxuICBiYWNrZ3JvdW5kOiAjMDAwMDAwMjQ7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcbiAgYmFja2Ryb3AtZmlsdGVyOiBibHVyKDI4cHgpO1xcclxcbiAgcG9zaXRpb246IGZpeGVkO1xcclxcbiAgdG9wOiAwO1xcclxcbiAgbGVmdDogMDtcXHJcXG4gIHotaW5kZXg6IDEwMDtcXHJcXG59XFxyXFxuXFxyXFxuLndhbGxldC1zZWxlY3RvciB7XFxyXFxuICBiYWNrZ3JvdW5kOiB2YXIoLS10cmVuZGluZy1pdGVtLWJnKTtcXHJcXG4gIHdpZHRoOiA1MDBweDtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDIwcHg7XFxyXFxufVxcclxcblxcclxcbi53YWxsZXQtaXRlbSB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcbiAgcGFkZGluZzogMjBweDtcXHJcXG4gIGN1cnNvcjogcG9pbnRlcjtcXHJcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjYTlhYmI1MTc7XFxyXFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuLndhbGxldC1pdGVtOmxhc3QtY2hpbGQge1xcclxcbiAgYm9yZGVyOiBub25lO1xcclxcbn1cXHJcXG5cXHJcXG4ud2FsbGV0LWl0ZW0gcCB7XFxyXFxuICBtYXJnaW4tbGVmdDogMjBweDtcXHJcXG59XFxyXFxuXFxyXFxuLndhbGxldC1pdGVtOmhvdmVyIHtcXHJcXG4gIGJhY2tncm91bmQ6ICMxNzE5MWUyZTtcXHJcXG59XFxyXFxuXFxyXFxuLmNtYy1jaGF0LWNvbnRhaW5lciB7XFxyXFxuICB3aWR0aDogNTAwcHg7XFxyXFxufVxcclxcblxcclxcbi5jbWMtY2hhdCB7XFxyXFxuICBiYWNrZ3JvdW5kOiB2YXIoLS1jbWMtY2hhdC1iZyk7XFxyXFxuICBwYWRkaW5nOiAyMHB4O1xcclxcbiAgYm9yZGVyLXJhZGl1czogMTBweDtcXHJcXG59XFxyXFxuXFxyXFxuLmF2YXRhci1jb250YWluZXIge1xcclxcbiAgYm9yZGVyLXJhZGl1czogMTAwcHg7XFxyXFxuICB3aWR0aDogNDBweDtcXHJcXG4gIGhlaWdodDogNDBweDtcXHJcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcbn1cXHJcXG5cXHJcXG4uYnVsbGlzaC1sYWJlbCBzdmcge1xcclxcbiAgZmlsbDogdmFyKC0tZ3JlZW4pO1xcclxcbn1cXHJcXG5cXHJcXG4uYmVhcmlzaC1sYWJlbCBzdmcge1xcclxcbiAgZmlsbDogdmFyKC0tcmVkKTtcXHJcXG59XFxyXFxuXFxyXFxuLmJ1bGxpc2gtbGFiZWwsXFxyXFxuLmJlYXJpc2gtbGFiZWwge1xcclxcbiAgYm9yZGVyOiAxcHggc29saWQgI2ZmZmZmZjI0O1xcclxcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xcclxcbiAgcGFkZGluZzogMnB4IDExcHg7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgd2lkdGg6IG1pbi1jb250ZW50O1xcclxcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuLmJ1bGxpc2gtbGFiZWwgc3ZnLFxcclxcbi5iZWFyaXNoLWxhYmVsIHN2ZyB7XFxyXFxuICBtYXJnaW4tcmlnaHQ6IDdweDtcXHJcXG59XFxyXFxuXFxyXFxuLmNtYy1jaGF0IC5pbnB1dC1ib3gge1xcclxcbiAgYmFja2dyb3VuZDogdmFyKC0tdHJlbmRpbmctaXRlbS1iZyk7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIHBhZGRpbmc6IDE3cHg7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxyXFxuICBtYXJnaW46IDI1cHggMDtcXHJcXG4gIGNvbG9yOiB2YXIoLS1wcmltYXJ5LWNvbG9yKTtcXHJcXG59XFxyXFxuXFxyXFxuLmNtYy1jaGF0IC5pbnB1dC1ib3ggaW5wdXQge1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICBoZWlnaHQ6IDMxcHg7XFxyXFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXHJcXG4gIHBhZGRpbmc6IDEwcHg7XFxyXFxuICBjb2xvcjogI2ZmZjtcXHJcXG4gIGZvbnQtc2l6ZTogMTdweDtcXHJcXG59XFxyXFxuXFxyXFxuLmZsZXgtaG9yaXpvbnRhbC1lbmQge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xcclxcbn1cXHJcXG5cXHJcXG4udGV4dC1hbGlnbi1sZWZ0IHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbn1cXHJcXG5cXHJcXG4uY2hhdC11c2VyIHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxyXFxufVxcclxcblxcclxcbi5jaGF0LXVzZXIgLnRleHQtYWxpZ24tbGVmdCB7XFxyXFxuICBtYXJnaW4tdG9wOiAtMTdweDtcXHJcXG4gIG1hcmdpbi1sZWZ0OiAxMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uYnVsbGlzaC1maWxsZWQge1xcclxcbiAgYmFja2dyb3VuZDogdmFyKC0tZ3JlZW4pO1xcclxcbn1cXHJcXG5cXHJcXG4uYnVsbGlzaC1maWxsZWQgc3ZnLFxcclxcbi5iZWFyaXNoLWZpbGxlZCBzdmcge1xcclxcbiAgZmlsbDogI2ZmZjtcXHJcXG59XFxyXFxuXFxyXFxuLmJlYXJpc2gtZmlsbGVkIHtcXHJcXG4gIGJhY2tncm91bmQ6IHZhcigtLXJlZCk7XFxyXFxufVxcclxcblxcclxcbi5jaGF0LWNhcmQge1xcclxcbiAgbWFyZ2luLXRvcDogMjBweDtcXHJcXG4gIHBhZGRpbmctdG9wOiA1MHB4O1xcclxcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkIHZhcigtLXRyZW5kaW5nLWl0ZW0tYmcpO1xcclxcbn1cXHJcXG5cXHJcXG4uY2hhdC1jYXJkIC5jaGF0LXVzZXIge1xcclxcbiAgbWFyZ2luLWJvdHRvbTogMjBweDtcXHJcXG59XFxyXFxuXFxyXFxuLmNoYXQtdXNlci1pbmZvIHtcXHJcXG4gIHdpZHRoOiA0MDBweDtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcclxcbn1cXHJcXG5cXHJcXG4ucG9zdC1hY3Rpb24ge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBjb2xvcjogIzYxNjM2ZTtcXHJcXG59XFxyXFxuXFxyXFxuLnBvc3QtYWN0aW9uIHN2ZyB7XFxyXFxuICBtYXJnaW4tcmlnaHQ6IDEwcHg7XFxyXFxufVxcclxcblxcclxcbi5wb3N0LWFjdGlvbnMtY29udGFpbmVyIHtcXHJcXG4gIG1hcmdpbi10b3A6IDIwcHg7XFxyXFxufVxcclxcblxcclxcbi5wcmljZS1jb252ZXJ0ZXIge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxyXFxuICBiYWNrZ3JvdW5kOiAjMTcxOTI0O1xcclxcbiAgcGFkZGluZzogMjRweCAyMHB4O1xcclxcbiAgYm9yZGVyLXJhZGl1czogMjBweDtcXHJcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNmZmM4YzgwZjtcXHJcXG59ICovXFxyXFxuXCIsbnVsbF0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./styles/globals.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js ***!
  \************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/ // css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function(useSourceMap) {\n    var list = [] // return the list of modules as css string\n    ;\n    list.toString = function toString() {\n        return this.map(function(item) {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            var content = cssWithMappingToString(item, useSourceMap);\n            if (item[2]) {\n                return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n            }\n            return content;\n        }).join(\"\");\n    } // import a list of modules into the list\n    ;\n    // eslint-disable-next-line func-names\n    // @ts-expect-error TODO: fix type\n    list.i = function(modules, mediaQuery, dedupe) {\n        if (typeof modules === \"string\") {\n            // eslint-disable-next-line no-param-reassign\n            modules = [\n                [\n                    null,\n                    modules,\n                    \"\"\n                ]\n            ];\n        }\n        var alreadyImportedModules = {};\n        if (dedupe) {\n            for(var i = 0; i < this.length; i++){\n                // eslint-disable-next-line prefer-destructuring\n                var id = this[i][0];\n                if (id != null) {\n                    alreadyImportedModules[id] = true;\n                }\n            }\n        }\n        for(var _i = 0; _i < modules.length; _i++){\n            var item = [].concat(modules[_i]);\n            if (dedupe && alreadyImportedModules[item[0]]) {\n                continue;\n            }\n            if (mediaQuery) {\n                if (!item[2]) {\n                    item[2] = mediaQuery;\n                } else {\n                    item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n                }\n            }\n            list.push(item);\n        }\n    };\n    return list;\n};\nfunction cssWithMappingToString(item, useSourceMap) {\n    var content = item[1] || \"\" // eslint-disable-next-line prefer-destructuring\n    ;\n    var cssMapping = item[3];\n    if (!cssMapping) {\n        return content;\n    }\n    if (useSourceMap && typeof btoa === \"function\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        var sourceMapping = toComment(cssMapping);\n        var sourceURLs = cssMapping.sources.map(function(source) {\n            return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n        });\n        return [\n            content\n        ].concat(sourceURLs).concat([\n            sourceMapping\n        ]).join(\"\\n\");\n    }\n    return [\n        content\n    ].join(\"\\n\");\n} // Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n    // eslint-disable-next-line no-undef\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    return \"/*# \".concat(data, \" */\");\n}\n\n//# sourceMappingURL=api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHFCQUFxQjtBQUN6RTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanM/Y2E0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovIC8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcbiAgICB2YXIgbGlzdCA9IFtdIC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcbiAgICA7XG4gICAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG4gICAgICAgICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH0pLmpvaW4oXCJcIik7XG4gICAgfSAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAgIDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogZml4IHR5cGVcbiAgICBsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIG1vZHVsZXMgPSBbXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBtb2R1bGVzLFxuICAgICAgICAgICAgICAgICAgICBcIlwiXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuICAgICAgICBpZiAoZGVkdXBlKSB7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgICAgICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcbiAgICAgICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvcih2YXIgX2kgPSAwOyBfaSA8IG1vZHVsZXMubGVuZ3RoOyBfaSsrKXtcbiAgICAgICAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2ldKTtcbiAgICAgICAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVsyXSA9IFwiXCIuY29uY2F0KG1lZGlhUXVlcnksIFwiIGFuZCBcIikuY29uY2F0KGl0ZW1bMl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGxpc3Q7XG59O1xuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcbiAgICB2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgXCJcIiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICA7XG4gICAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuICAgIGlmICghY3NzTWFwcGluZykge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgdmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG4gICAgICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCBcIlwiKS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBjb250ZW50XG4gICAgICAgIF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbXG4gICAgICAgICAgICBzb3VyY2VNYXBwaW5nXG4gICAgICAgIF0pLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgIGNvbnRlbnRcbiAgICBdLmpvaW4oXCJcXG5cIik7XG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcbiAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgcmV0dXJuIFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app! ***!
  \*******************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/_app\",\n      function () {\n        return __webpack_require__(/*! private-next-pages/_app */ \"./pages/_app.js\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/_app\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD1wcml2YXRlLW5leHQtcGFnZXMlMkZfYXBwJnBhZ2U9JTJGX2FwcCEuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxnREFBeUI7QUFDaEQ7QUFDQTtBQUNBLE9BQU8sSUFBVTtBQUNqQixNQUFNLFVBQVU7QUFDaEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzY3ODIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9fYXBwXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwicHJpdmF0ZS1uZXh0LXBhZ2VzL19hcHBcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL19hcHBcIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!\n"));

/***/ }),

/***/ "./pages/index.css":
/*!*************************!*\
  !*** ./pages/index.css ***!
  \*************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./index.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./pages/index.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./index.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./pages/index.css\",\n      function () {\n        content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./index.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./pages/index.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9pbmRleC5jc3MuanMiLCJtYXBwaW5ncyI6IkFBQUEsVUFBVSxtQkFBTyxDQUFDLG9OQUF3RztBQUMxSCwwQkFBMEIsbUJBQU8sQ0FBQyxrZUFBNk87O0FBRS9ROztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxJQUFJLElBQVU7QUFDZCx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxpQkFBaUI7QUFDckIsTUFBTSxrZUFBNk87QUFDblA7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxrZUFBNk87O0FBRXZROztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixVQUFVOztBQUUxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsVUFBVTtBQUNaO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3BhZ2VzL2luZGV4LmNzcz9hODJlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBhcGkgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls5XS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzldLnVzZVsyXSEuL2luZGV4LmNzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgc3R5bGUtbG9hZGVyIGluamVjdHMgQ1NTIGludG8gdGhlIGJvdHRvbVxuICAgICAgICAgICAgICAgICAgICAvLyBvZiA8aGVhZD4uIFRoaXMgY2F1c2VzIG9yZGVyaW5nIHByb2JsZW1zIGJldHdlZW4gZGV2XG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBwcm9kLiBUbyBmaXggdGhpcywgd2UgcmVuZGVyIGEgPG5vc2NyaXB0PiB0YWcgYXNcbiAgICAgICAgICAgICAgICAgICAgLy8gYW4gYW5jaG9yIGZvciB0aGUgc3R5bGVzIHRvIGJlIHBsYWNlZCBiZWZvcmUuIFRoZXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0eWxlcyB3aWxsIGJlIGFwcGxpZWQgX2JlZm9yZV8gPHN0eWxlIGpzeCBnbG9iYWw+LlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSBlbGVtZW50cyBzaG91bGQgYWx3YXlzIGV4aXN0LiBJZiB0aGV5IGRvIG5vdCxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5jaG9yRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGFuY2hvckVsZW1lbnQucGFyZW50Tm9kZS8vIE5vcm1hbGx5IDxoZWFkPlxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuICAgICAgICAgICAgICAgICAgICAvLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gdHJhY2sgdGhlIGxhc3QgaW5zZXJ0ZWQgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgYW5jaG9yRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfTtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2FscyB8fCBtb2R1bGUuaG90LmludmFsaWRhdGUpIHtcbiAgICB2YXIgaXNFcXVhbExvY2FscyA9IGZ1bmN0aW9uIGlzRXF1YWxMb2NhbHMoYSwgYiwgaXNOYW1lZEV4cG9ydCkge1xuICAgIGlmICghYSAmJiBiIHx8IGEgJiYgIWIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgcDtcbiAgICBmb3IocCBpbiBhKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKHAgaW4gYil7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFbcF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOV0udXNlWzFdIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls5XS51c2VbMl0hLi9pbmRleC5jc3NcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzldLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOV0udXNlWzJdIS4vaW5kZXguY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pages/index.css\n"));

/***/ }),

/***/ "./styles/globals.css":
/*!****************************!*\
  !*** ./styles/globals.css ***!
  \****************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./styles/globals.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./styles/globals.css\",\n      function () {\n        content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[9].use[2]!./styles/globals.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvZ2xvYmFscy5jc3MuanMiLCJtYXBwaW5ncyI6IkFBQUEsVUFBVSxtQkFBTyxDQUFDLG9OQUF3RztBQUMxSCwwQkFBMEIsbUJBQU8sQ0FBQyx1ZUFBK087O0FBRWpSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxJQUFJLElBQVU7QUFDZCx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxpQkFBaUI7QUFDckIsTUFBTSx1ZUFBK087QUFDclA7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyx1ZUFBK087O0FBRXpROztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixVQUFVOztBQUUxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsVUFBVTtBQUNaO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3N0eWxlcy9nbG9iYWxzLmNzcz8xNzQ0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBhcGkgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls5XS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzldLnVzZVsyXSEuL2dsb2JhbHMuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCBzdHlsZS1sb2FkZXIgaW5qZWN0cyBDU1MgaW50byB0aGUgYm90dG9tXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIDxoZWFkPi4gVGhpcyBjYXVzZXMgb3JkZXJpbmcgcHJvYmxlbXMgYmV0d2VlbiBkZXZcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHByb2QuIFRvIGZpeCB0aGlzLCB3ZSByZW5kZXIgYSA8bm9zY3JpcHQ+IHRhZyBhc1xuICAgICAgICAgICAgICAgICAgICAvLyBhbiBhbmNob3IgZm9yIHRoZSBzdHlsZXMgdG8gYmUgcGxhY2VkIGJlZm9yZS4gVGhlc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gc3R5bGVzIHdpbGwgYmUgYXBwbGllZCBfYmVmb3JlXyA8c3R5bGUganN4IGdsb2JhbD4uXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmNob3JFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNfX25leHRfY3NzX19ET19OT1RfVVNFX19cIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LCBhbmNob3JFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XG4gICAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBwO1xuICAgIGZvcihwIGluIGEpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFbcF0gIT09IGJbcF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IocCBpbiBiKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYVtwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls5XS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzldLnVzZVsyXSEuL2dsb2JhbHMuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls5XS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzldLnVzZVsyXSEuL2dsb2JhbHMuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./styles/globals.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js ***!
  \************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nconst isOldIE = function isOldIE() {\n    let memo;\n    return function memorize() {\n        if (typeof memo === \"undefined\") {\n            // Test for IE <= 9 as proposed by Browserhacks\n            // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n            // Tests for existence of standard globals is to allow style-loader\n            // to operate correctly into non-standard environments\n            // @see https://github.com/webpack-contrib/style-loader/issues/177\n            memo = Boolean(window && document && document.all && !window.atob);\n        }\n        return memo;\n    };\n}();\nconst getTargetElement = function() {\n    const memo = {};\n    return function memorize(target) {\n        if (typeof memo[target] === \"undefined\") {\n            let styleTarget = document.querySelector(target);\n            // Special case to return head of iframe instead of iframe itself\n            if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n                try {\n                    // This will throw an exception if access to iframe is blocked\n                    // due to cross-origin restrictions\n                    styleTarget = styleTarget.contentDocument.head;\n                } catch (e) {\n                    // istanbul ignore next\n                    styleTarget = null;\n                }\n            }\n            memo[target] = styleTarget;\n        }\n        return memo[target];\n    };\n}();\nconst stylesInDom = [];\nfunction getIndexByIdentifier(identifier) {\n    let result = -1;\n    for(let i = 0; i < stylesInDom.length; i++){\n        if (stylesInDom[i].identifier === identifier) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\nfunction modulesToDom(list, options) {\n    const idCountMap = {};\n    const identifiers = [];\n    for(let i = 0; i < list.length; i++){\n        const item = list[i];\n        const id = options.base ? item[0] + options.base : item[0];\n        const count = idCountMap[id] || 0;\n        const identifier = id + \" \" + count.toString();\n        idCountMap[id] = count + 1;\n        const index = getIndexByIdentifier(identifier);\n        const obj = {\n            css: item[1],\n            media: item[2],\n            sourceMap: item[3]\n        };\n        if (index !== -1) {\n            stylesInDom[index].references++;\n            stylesInDom[index].updater(obj);\n        } else {\n            stylesInDom.push({\n                identifier: identifier,\n                // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                updater: addStyle(obj, options),\n                references: 1\n            });\n        }\n        identifiers.push(identifier);\n    }\n    return identifiers;\n}\nfunction insertStyleElement(options) {\n    const style = document.createElement(\"style\");\n    const attributes = options.attributes || {};\n    if (typeof attributes.nonce === \"undefined\") {\n        const nonce = // eslint-disable-next-line no-undef\n         true ? __webpack_require__.nc : 0;\n        if (nonce) {\n            attributes.nonce = nonce;\n        }\n    }\n    Object.keys(attributes).forEach(function(key) {\n        style.setAttribute(key, attributes[key]);\n    });\n    if (typeof options.insert === \"function\") {\n        options.insert(style);\n    } else {\n        const target = getTargetElement(options.insert || \"head\");\n        if (!target) {\n            throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n        }\n        target.appendChild(style);\n    }\n    return style;\n}\nfunction removeStyleElement(style) {\n    // istanbul ignore if\n    if (style.parentNode === null) {\n        return false;\n    }\n    style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */ const replaceText = function replaceText() {\n    const textStore = [];\n    return function replace(index, replacement) {\n        textStore[index] = replacement;\n        return textStore.filter(Boolean).join(\"\\n\");\n    };\n}();\nfunction applyToSingletonTag(style, index, remove, obj) {\n    const css = remove ? \"\" : obj.media ? \"@media \" + obj.media + \" {\" + obj.css + \"}\" : obj.css;\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = replaceText(index, css);\n    } else {\n        const cssNode = document.createTextNode(css);\n        const childNodes = style.childNodes;\n        if (childNodes[index]) {\n            style.removeChild(childNodes[index]);\n        }\n        if (childNodes.length) {\n            style.insertBefore(cssNode, childNodes[index]);\n        } else {\n            style.appendChild(cssNode);\n        }\n    }\n}\nfunction applyToTag(style, _options, obj) {\n    let css = obj.css;\n    const media = obj.media;\n    const sourceMap = obj.sourceMap;\n    if (media) {\n        style.setAttribute(\"media\", media);\n    } else {\n        style.removeAttribute(\"media\");\n    }\n    if (sourceMap && typeof btoa !== \"undefined\") {\n        css += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n    }\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n    } else {\n        while(style.firstChild){\n            style.removeChild(style.firstChild);\n        }\n        style.appendChild(document.createTextNode(css));\n    }\n}\nlet singleton = null;\nlet singletonCounter = 0;\nfunction addStyle(obj, options) {\n    let style;\n    let update;\n    let remove;\n    if (options.singleton) {\n        const styleIndex = singletonCounter++;\n        style = singleton || (singleton = insertStyleElement(options));\n        update = applyToSingletonTag.bind(null, style, styleIndex, false);\n        remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n    } else {\n        style = insertStyleElement(options);\n        update = applyToTag.bind(null, style, options);\n        remove = function() {\n            removeStyleElement(style);\n        };\n    }\n    update(obj);\n    return function updateStyle(newObj) {\n        if (newObj) {\n            if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n                return;\n            }\n            update(obj = newObj);\n        } else {\n            remove();\n        }\n    };\n}\nmodule.exports = function(list, options) {\n    options = options || {};\n    // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n    // tags it will allow on a page\n    if (!options.singleton && typeof options.singleton !== \"boolean\") {\n        options.singleton = isOldIE();\n    }\n    list = list || [];\n    let lastIdentifiers = modulesToDom(list, options);\n    return function update(newList) {\n        newList = newList || [];\n        if (Object.prototype.toString.call(newList) !== \"[object Array]\") {\n            return;\n        }\n        for(let i = 0; i < lastIdentifiers.length; i++){\n            const identifier = lastIdentifiers[i];\n            const index = getIndexByIdentifier(identifier);\n            stylesInDom[index].references--;\n        }\n        const newLastIdentifiers = modulesToDom(newList, options);\n        for(let i1 = 0; i1 < lastIdentifiers.length; i1++){\n            const identifier = lastIdentifiers[i1];\n            const index = getIndexByIdentifier(identifier);\n            if (stylesInDom[index].references === 0) {\n                stylesInDom[index].updater();\n                stylesInDom.splice(index, 1);\n            }\n        }\n        lastIdentifiers = newLastIdentifiers;\n    };\n};\n\n//# sourceMappingURL=injectStylesIntoStyleTag.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXdDLEdBQUcsc0JBQWlCLEdBQUcsQ0FBSTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxxRUFBcUUsZ0JBQWdCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNkJBQTZCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzPzI2ZWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBpc09sZElFID0gZnVuY3Rpb24gaXNPbGRJRSgpIHtcbiAgICBsZXQgbWVtbztcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgLy8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcbiAgICAgICAgICAgIC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcbiAgICAgICAgICAgIC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuICAgICAgICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG4gICAgICAgICAgICBtZW1vID0gQm9vbGVhbih3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbn0oKTtcbmNvbnN0IGdldFRhcmdldEVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBtZW1vID0ge307XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKHRhcmdldCkge1xuICAgICAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbGV0IHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcbiAgICAgICAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAgICAgICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gICAgfTtcbn0oKTtcbmNvbnN0IHN0eWxlc0luRG9tID0gW107XG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gICAgbGV0IHJlc3VsdCA9IC0xO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzdHlsZXNJbkRvbS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGlmIChzdHlsZXNJbkRvbVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgaWRDb3VudE1hcCA9IHt9O1xuICAgIGNvbnN0IGlkZW50aWZpZXJzID0gW107XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspe1xuICAgICAgICBjb25zdCBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgY29uc3QgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICAgICAgY29uc3QgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gaWQgKyBcIiBcIiArIGNvdW50LnRvU3RyaW5nKCk7XG4gICAgICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgICBjb25zdCBvYmogPSB7XG4gICAgICAgICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICAgICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgICAgICAgIHNvdXJjZU1hcDogaXRlbVszXVxuICAgICAgICB9O1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcysrO1xuICAgICAgICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlc0luRG9tLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuICAgIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25zdCBub25jZSA9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgICB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG4gICAgICAgIGlmIChub25jZSkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0IHx8IFwiaGVhZFwiKTtcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xufVxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gICAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gICAgaWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqLyBjb25zdCByZXBsYWNlVGV4dCA9IGZ1bmN0aW9uIHJlcGxhY2VUZXh0KCkge1xuICAgIGNvbnN0IHRleHRTdG9yZSA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiByZXBsYWNlKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgICAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCJcXG5cIik7XG4gICAgfTtcbn0oKTtcbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICAgIGNvbnN0IGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmoubWVkaWEgPyBcIkBtZWRpYSBcIiArIG9iai5tZWRpYSArIFwiIHtcIiArIG9iai5jc3MgKyBcIn1cIiA6IG9iai5jc3M7XG4gICAgLy8gRm9yIG9sZCBJRVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi8gaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuICAgICAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgICAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIF9vcHRpb25zLCBvYmopIHtcbiAgICBsZXQgY3NzID0gb2JqLmNzcztcbiAgICBjb25zdCBtZWRpYSA9IG9iai5tZWRpYTtcbiAgICBjb25zdCBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKFwibWVkaWFcIik7XG4gICAgfVxuICAgIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuICAgIH1cbiAgICAvLyBGb3Igb2xkIElFXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqLyBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUoc3R5bGUuZmlyc3RDaGlsZCl7XG4gICAgICAgICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgICB9XG59XG5sZXQgc2luZ2xldG9uID0gbnVsbDtcbmxldCBzaW5nbGV0b25Db3VudGVyID0gMDtcbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICAgIGxldCBzdHlsZTtcbiAgICBsZXQgdXBkYXRlO1xuICAgIGxldCByZW1vdmU7XG4gICAgaWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG4gICAgICAgIHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuICAgICAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcbiAgICAgICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZSA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgICAgICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcbiAgICAgICAgcmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB1cGRhdGUob2JqKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XG4gICAgICAgIGlmIChuZXdPYmopIHtcbiAgICAgICAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuICAgIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcbiAgICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG4gICAgfVxuICAgIGxpc3QgPSBsaXN0IHx8IFtdO1xuICAgIGxldCBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0xpc3QpICE9PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG4gICAgICAgIGZvcihsZXQgaTEgPSAwOyBpMSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkxKyspe1xuICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpMV07XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgaWYgKHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIoKTtcbiAgICAgICAgICAgICAgICBzdHlsZXNJbkRvbS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgICB9O1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\n"));

/***/ }),

/***/ "./context/context.js":
/*!****************************!*\
  !*** ./context/context.js ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CoinMarketContext\": function() { return /* binding */ CoinMarketContext; },\n/* harmony export */   \"CoinMarketProvider\": function() { return /* binding */ CoinMarketProvider; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\n// import { useMoralis } from 'react-moralis'\n// import { useMoralisQuery } from 'react-moralis'\n// import {\n//   dogeAbi,\n//   daiAbi,\n//   linkAbi,\n//   usdcAbi,\n//   dogeAddress,\n//   linkAddress,\n//   daiAddress,\n//   usdcAddress,\n// } from '../lib/constants'\nconst CoinMarketContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)();\nconst CoinMarketProvider = (param)=>{\n    let { children  } = param;\n    //   const { isAuthenticated, user, Moralis } = useMoralis()\n    //   const {\n    //     data: coins,\n    //     error,\n    //     isLoading: loadingCoins,\n    //   } = useMoralisQuery('Coins')\n    //   const [currentAccount, setCurrentAccount] = useState('')\n    //   const [openBuyCryptoModal, setOpenBuyCryptoModal] = useState(false)\n    //   const [fromToken, setFromToken] = useState('ETH')\n    //   const [toToken, setToToken] = useState('')\n    //   const [amount, setAmount] = useState('')\n    //   useEffect(() => {\n    //     if (isAuthenticated) {\n    //       const account = user.get('ethAddress')\n    //       setCurrentAccount(account)\n    //     }\n    //   }, [isAuthenticated])\n    //   const getContractAddress = () => {\n    //     if (fromToken === 'Dai') return daiAddress\n    //     if (fromToken === 'Dogecoin') return dogeAddress\n    //     if (fromToken === 'Link') return linkAddress\n    //     if (fromToken === 'usdc') return usdcAddress\n    //   }\n    //   const getToAddress = () => {\n    //     if (toToken === 'Dai') return daiAddress\n    //     if (toToken === 'Dogecoin') return dogeAddress\n    //     if (toToken === 'Link') return linkAddress\n    //     if (toToken === 'Usdc') return usdcAddress\n    //   }\n    //   const getToAbi = () => {\n    //     if (toToken === 'Dai') return daiAbi\n    //     if (toToken === 'Dogecoin') return dogeAbi\n    //     if (toToken === 'Link') return linkAbi\n    //     if (toToken === 'Usdc') return usdcAbi\n    //   }\n    //   const openModal = () => {\n    //     setOpenBuyCryptoModal(true)\n    //   }\n    //   //Mint function for the token with send ether to the contract\n    //   const mint = async () => {\n    //     try {\n    //       if (fromToken === 'ETH') {\n    //         if (!isAuthenticated) return\n    //         await Moralis.enableWeb3()\n    //         const contractAddress = getToAddress()\n    //         const abi = getToAbi()\n    //         let options = {\n    //           contractAddress: contractAddress,\n    //           functionName: 'mint',\n    //           abi: abi,\n    //           params: {\n    //             to: currentAccount,\n    //             amount: Moralis.Units.Token(amount),\n    //           },\n    //         }\n    //         sendEth()\n    //         const transaction = await Moralis.executeFunction(options)\n    //         const receipt = await transaction.wait(4)\n    //         console.log(receipt)\n    //       } else {\n    //         swapTokens()\n    //       }\n    //     } catch (error) {\n    //       console.error(error.message)\n    //     }\n    //   }\n    //   const swapTokens = async () => {\n    //     try {\n    //       if (!isAuthenticated) return\n    //       await Moralis.enableWeb3()\n    //       if (fromToken === toToken) return alert('You cannot swap the same token')\n    //       const fromOptions = {\n    //         type: 'erc20',\n    //         amount: Moralis.Units.Token(amount, '18'),\n    //         receiver: getContractAddress(),\n    //         contractAddress: getContractAddress(),\n    //       }\n    //       const toMintOptions = {\n    //         contractAddress: getToAddress(),\n    //         functionName: 'mint',\n    //         abi: getToAbi(),\n    //         params: {\n    //           to: currentAccount,\n    //           amount: Moralis.Units.Token(amount, '18'),\n    //         },\n    //       }\n    //       let fromTransaction = await Moralis.transfer(fromOptions)\n    //       let toMintTransaction = await Moralis.executeFunction(toMintOptions)\n    //       let fromReceipt = await fromTransaction.wait()\n    //       let toReceipt = await toMintTransaction.wait()\n    //       console.log(fromReceipt)\n    //       console.log(toReceipt)\n    //     } catch (error) {\n    //       console.error(error.message)\n    //     }\n    //   }\n    //   //Send eth function\n    //   const sendEth = async () => {\n    //     if (!isAuthenticated) return\n    //     const contractAddress = getToAddress()\n    //     let options = {\n    //       type: 'native',\n    //       amount: Moralis.Units.ETH('0.01'),\n    //       receiver: contractAddress,\n    //     }\n    //     const transaction = await Moralis.transfer(options)\n    //     const receipt = await transaction.wait()\n    //     console.log(receipt)\n    //   }\n    const getTopTenCoins = async ()=>{\n        try {\n            const res = await fetch(\"/api/getTopTen\");\n            const data = await res.json();\n            return data.data.data;\n        } catch (e) {\n            console.log(e.message);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CoinMarketContext.Provider, {\n        value: {\n            getTopTenCoins\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"E:\\\\coinmart\\\\context\\\\context.js\",\n        lineNumber: 153,\n        columnNumber: 5\n    }, undefined);\n};\n_c = CoinMarketProvider;\nvar _c;\n$RefreshReg$(_c, \"CoinMarketProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WUFDVkMsUUFBUUMsR0FBRyxDQUFDRixFQUFFRyxPQUFPO1FBQ3ZCO0lBQ0Y7SUFFQSxxQkFDRSw4REFBQ1gsa0JBQWtCWSxRQUFRO1FBQ3pCQyxPQUFPO1lBQ0xWO1FBYUY7a0JBRUNEOzs7Ozs7QUFHUCxFQUFDO0tBM0pZRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb250ZXh0L2NvbnRleHQuanM/NzJlYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnXHJcbi8vIGltcG9ydCB7IHVzZU1vcmFsaXMgfSBmcm9tICdyZWFjdC1tb3JhbGlzJ1xyXG5cclxuLy8gaW1wb3J0IHsgdXNlTW9yYWxpc1F1ZXJ5IH0gZnJvbSAncmVhY3QtbW9yYWxpcydcclxuLy8gaW1wb3J0IHtcclxuLy8gICBkb2dlQWJpLFxyXG4vLyAgIGRhaUFiaSxcclxuLy8gICBsaW5rQWJpLFxyXG4vLyAgIHVzZGNBYmksXHJcbi8vICAgZG9nZUFkZHJlc3MsXHJcbi8vICAgbGlua0FkZHJlc3MsXHJcbi8vICAgZGFpQWRkcmVzcyxcclxuLy8gICB1c2RjQWRkcmVzcyxcclxuLy8gfSBmcm9tICcuLi9saWIvY29uc3RhbnRzJ1xyXG5cclxuZXhwb3J0IGNvbnN0IENvaW5NYXJrZXRDb250ZXh0ID0gY3JlYXRlQ29udGV4dCgpXHJcblxyXG5leHBvcnQgY29uc3QgQ29pbk1hcmtldFByb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xyXG4vLyAgIGNvbnN0IHsgaXNBdXRoZW50aWNhdGVkLCB1c2VyLCBNb3JhbGlzIH0gPSB1c2VNb3JhbGlzKClcclxuLy8gICBjb25zdCB7XHJcbi8vICAgICBkYXRhOiBjb2lucyxcclxuLy8gICAgIGVycm9yLFxyXG4vLyAgICAgaXNMb2FkaW5nOiBsb2FkaW5nQ29pbnMsXHJcbi8vICAgfSA9IHVzZU1vcmFsaXNRdWVyeSgnQ29pbnMnKVxyXG5cclxuLy8gICBjb25zdCBbY3VycmVudEFjY291bnQsIHNldEN1cnJlbnRBY2NvdW50XSA9IHVzZVN0YXRlKCcnKVxyXG4vLyAgIGNvbnN0IFtvcGVuQnV5Q3J5cHRvTW9kYWwsIHNldE9wZW5CdXlDcnlwdG9Nb2RhbF0gPSB1c2VTdGF0ZShmYWxzZSlcclxuLy8gICBjb25zdCBbZnJvbVRva2VuLCBzZXRGcm9tVG9rZW5dID0gdXNlU3RhdGUoJ0VUSCcpXHJcbi8vICAgY29uc3QgW3RvVG9rZW4sIHNldFRvVG9rZW5dID0gdXNlU3RhdGUoJycpXHJcbi8vICAgY29uc3QgW2Ftb3VudCwgc2V0QW1vdW50XSA9IHVzZVN0YXRlKCcnKVxyXG5cclxuLy8gICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4vLyAgICAgaWYgKGlzQXV0aGVudGljYXRlZCkge1xyXG4vLyAgICAgICBjb25zdCBhY2NvdW50ID0gdXNlci5nZXQoJ2V0aEFkZHJlc3MnKVxyXG4vLyAgICAgICBzZXRDdXJyZW50QWNjb3VudChhY2NvdW50KVxyXG4vLyAgICAgfVxyXG4vLyAgIH0sIFtpc0F1dGhlbnRpY2F0ZWRdKVxyXG5cclxuLy8gICBjb25zdCBnZXRDb250cmFjdEFkZHJlc3MgPSAoKSA9PiB7XHJcbi8vICAgICBpZiAoZnJvbVRva2VuID09PSAnRGFpJykgcmV0dXJuIGRhaUFkZHJlc3NcclxuLy8gICAgIGlmIChmcm9tVG9rZW4gPT09ICdEb2dlY29pbicpIHJldHVybiBkb2dlQWRkcmVzc1xyXG4vLyAgICAgaWYgKGZyb21Ub2tlbiA9PT0gJ0xpbmsnKSByZXR1cm4gbGlua0FkZHJlc3NcclxuLy8gICAgIGlmIChmcm9tVG9rZW4gPT09ICd1c2RjJykgcmV0dXJuIHVzZGNBZGRyZXNzXHJcbi8vICAgfVxyXG5cclxuLy8gICBjb25zdCBnZXRUb0FkZHJlc3MgPSAoKSA9PiB7XHJcbi8vICAgICBpZiAodG9Ub2tlbiA9PT0gJ0RhaScpIHJldHVybiBkYWlBZGRyZXNzXHJcbi8vICAgICBpZiAodG9Ub2tlbiA9PT0gJ0RvZ2Vjb2luJykgcmV0dXJuIGRvZ2VBZGRyZXNzXHJcbi8vICAgICBpZiAodG9Ub2tlbiA9PT0gJ0xpbmsnKSByZXR1cm4gbGlua0FkZHJlc3NcclxuLy8gICAgIGlmICh0b1Rva2VuID09PSAnVXNkYycpIHJldHVybiB1c2RjQWRkcmVzc1xyXG4vLyAgIH1cclxuXHJcbi8vICAgY29uc3QgZ2V0VG9BYmkgPSAoKSA9PiB7XHJcbi8vICAgICBpZiAodG9Ub2tlbiA9PT0gJ0RhaScpIHJldHVybiBkYWlBYmlcclxuLy8gICAgIGlmICh0b1Rva2VuID09PSAnRG9nZWNvaW4nKSByZXR1cm4gZG9nZUFiaVxyXG4vLyAgICAgaWYgKHRvVG9rZW4gPT09ICdMaW5rJykgcmV0dXJuIGxpbmtBYmlcclxuLy8gICAgIGlmICh0b1Rva2VuID09PSAnVXNkYycpIHJldHVybiB1c2RjQWJpXHJcbi8vICAgfVxyXG5cclxuLy8gICBjb25zdCBvcGVuTW9kYWwgPSAoKSA9PiB7XHJcbi8vICAgICBzZXRPcGVuQnV5Q3J5cHRvTW9kYWwodHJ1ZSlcclxuLy8gICB9XHJcblxyXG4vLyAgIC8vTWludCBmdW5jdGlvbiBmb3IgdGhlIHRva2VuIHdpdGggc2VuZCBldGhlciB0byB0aGUgY29udHJhY3RcclxuLy8gICBjb25zdCBtaW50ID0gYXN5bmMgKCkgPT4ge1xyXG4vLyAgICAgdHJ5IHtcclxuLy8gICAgICAgaWYgKGZyb21Ub2tlbiA9PT0gJ0VUSCcpIHtcclxuLy8gICAgICAgICBpZiAoIWlzQXV0aGVudGljYXRlZCkgcmV0dXJuXHJcbi8vICAgICAgICAgYXdhaXQgTW9yYWxpcy5lbmFibGVXZWIzKClcclxuLy8gICAgICAgICBjb25zdCBjb250cmFjdEFkZHJlc3MgPSBnZXRUb0FkZHJlc3MoKVxyXG4vLyAgICAgICAgIGNvbnN0IGFiaSA9IGdldFRvQWJpKClcclxuXHJcbi8vICAgICAgICAgbGV0IG9wdGlvbnMgPSB7XHJcbi8vICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IGNvbnRyYWN0QWRkcmVzcyxcclxuLy8gICAgICAgICAgIGZ1bmN0aW9uTmFtZTogJ21pbnQnLFxyXG4vLyAgICAgICAgICAgYWJpOiBhYmksXHJcbi8vICAgICAgICAgICBwYXJhbXM6IHtcclxuLy8gICAgICAgICAgICAgdG86IGN1cnJlbnRBY2NvdW50LFxyXG4vLyAgICAgICAgICAgICBhbW91bnQ6IE1vcmFsaXMuVW5pdHMuVG9rZW4oYW1vdW50KSxcclxuLy8gICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgfVxyXG4vLyAgICAgICAgIHNlbmRFdGgoKVxyXG4vLyAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgTW9yYWxpcy5leGVjdXRlRnVuY3Rpb24ob3B0aW9ucylcclxuLy8gICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdHJhbnNhY3Rpb24ud2FpdCg0KVxyXG4vLyAgICAgICAgIGNvbnNvbGUubG9nKHJlY2VpcHQpXHJcbi8vICAgICAgIH0gZWxzZSB7XHJcbi8vICAgICAgICAgc3dhcFRva2VucygpXHJcbi8vICAgICAgIH1cclxuLy8gICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbi8vICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IubWVzc2FnZSlcclxuLy8gICAgIH1cclxuLy8gICB9XHJcblxyXG4vLyAgIGNvbnN0IHN3YXBUb2tlbnMgPSBhc3luYyAoKSA9PiB7XHJcbi8vICAgICB0cnkge1xyXG4vLyAgICAgICBpZiAoIWlzQXV0aGVudGljYXRlZCkgcmV0dXJuXHJcbi8vICAgICAgIGF3YWl0IE1vcmFsaXMuZW5hYmxlV2ViMygpXHJcblxyXG4vLyAgICAgICBpZiAoZnJvbVRva2VuID09PSB0b1Rva2VuKSByZXR1cm4gYWxlcnQoJ1lvdSBjYW5ub3Qgc3dhcCB0aGUgc2FtZSB0b2tlbicpXHJcblxyXG4vLyAgICAgICBjb25zdCBmcm9tT3B0aW9ucyA9IHtcclxuLy8gICAgICAgICB0eXBlOiAnZXJjMjAnLFxyXG4vLyAgICAgICAgIGFtb3VudDogTW9yYWxpcy5Vbml0cy5Ub2tlbihhbW91bnQsICcxOCcpLFxyXG4vLyAgICAgICAgIHJlY2VpdmVyOiBnZXRDb250cmFjdEFkZHJlc3MoKSxcclxuLy8gICAgICAgICBjb250cmFjdEFkZHJlc3M6IGdldENvbnRyYWN0QWRkcmVzcygpLFxyXG4vLyAgICAgICB9XHJcbi8vICAgICAgIGNvbnN0IHRvTWludE9wdGlvbnMgPSB7XHJcbi8vICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBnZXRUb0FkZHJlc3MoKSxcclxuLy8gICAgICAgICBmdW5jdGlvbk5hbWU6ICdtaW50JyxcclxuLy8gICAgICAgICBhYmk6IGdldFRvQWJpKCksXHJcbi8vICAgICAgICAgcGFyYW1zOiB7XHJcbi8vICAgICAgICAgICB0bzogY3VycmVudEFjY291bnQsXHJcbi8vICAgICAgICAgICBhbW91bnQ6IE1vcmFsaXMuVW5pdHMuVG9rZW4oYW1vdW50LCAnMTgnKSxcclxuLy8gICAgICAgICB9LFxyXG4vLyAgICAgICB9XHJcbi8vICAgICAgIGxldCBmcm9tVHJhbnNhY3Rpb24gPSBhd2FpdCBNb3JhbGlzLnRyYW5zZmVyKGZyb21PcHRpb25zKVxyXG4vLyAgICAgICBsZXQgdG9NaW50VHJhbnNhY3Rpb24gPSBhd2FpdCBNb3JhbGlzLmV4ZWN1dGVGdW5jdGlvbih0b01pbnRPcHRpb25zKVxyXG4vLyAgICAgICBsZXQgZnJvbVJlY2VpcHQgPSBhd2FpdCBmcm9tVHJhbnNhY3Rpb24ud2FpdCgpXHJcbi8vICAgICAgIGxldCB0b1JlY2VpcHQgPSBhd2FpdCB0b01pbnRUcmFuc2FjdGlvbi53YWl0KClcclxuLy8gICAgICAgY29uc29sZS5sb2coZnJvbVJlY2VpcHQpXHJcbi8vICAgICAgIGNvbnNvbGUubG9nKHRvUmVjZWlwdClcclxuLy8gICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbi8vICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IubWVzc2FnZSlcclxuLy8gICAgIH1cclxuLy8gICB9XHJcblxyXG4vLyAgIC8vU2VuZCBldGggZnVuY3Rpb25cclxuLy8gICBjb25zdCBzZW5kRXRoID0gYXN5bmMgKCkgPT4ge1xyXG4vLyAgICAgaWYgKCFpc0F1dGhlbnRpY2F0ZWQpIHJldHVyblxyXG4vLyAgICAgY29uc3QgY29udHJhY3RBZGRyZXNzID0gZ2V0VG9BZGRyZXNzKClcclxuXHJcbi8vICAgICBsZXQgb3B0aW9ucyA9IHtcclxuLy8gICAgICAgdHlwZTogJ25hdGl2ZScsXHJcbi8vICAgICAgIGFtb3VudDogTW9yYWxpcy5Vbml0cy5FVEgoJzAuMDEnKSxcclxuLy8gICAgICAgcmVjZWl2ZXI6IGNvbnRyYWN0QWRkcmVzcyxcclxuLy8gICAgIH1cclxuLy8gICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgTW9yYWxpcy50cmFuc2ZlcihvcHRpb25zKVxyXG4vLyAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRyYW5zYWN0aW9uLndhaXQoKVxyXG4vLyAgICAgY29uc29sZS5sb2cocmVjZWlwdClcclxuLy8gICB9XHJcblxyXG4gIGNvbnN0IGdldFRvcFRlbkNvaW5zID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goJy9hcGkvZ2V0VG9wVGVuJylcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKClcclxuICAgICAgcmV0dXJuIGRhdGEuZGF0YS5kYXRhXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGUubWVzc2FnZSlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8Q29pbk1hcmtldENvbnRleHQuUHJvdmlkZXJcclxuICAgICAgdmFsdWU9e3tcclxuICAgICAgICBnZXRUb3BUZW5Db2lucyxcclxuLy8gICAgICAgICBvcGVuQnV5Q3J5cHRvTW9kYWwsXHJcbi8vICAgICAgICAgc2V0T3BlbkJ1eUNyeXB0b01vZGFsLFxyXG4vLyAgICAgICAgIGNvaW5zLFxyXG4vLyAgICAgICAgIGxvYWRpbmdDb2lucyxcclxuLy8gICAgICAgICBmcm9tVG9rZW4sXHJcbi8vICAgICAgICAgdG9Ub2tlbixcclxuLy8gICAgICAgICBzZXRGcm9tVG9rZW4sXHJcbi8vICAgICAgICAgc2V0VG9Ub2tlbixcclxuLy8gICAgICAgICBhbW91bnQsXHJcbi8vICAgICAgICAgc2V0QW1vdW50LFxyXG4vLyAgICAgICAgIG1pbnQsXHJcbi8vICAgICAgICAgb3Blbk1vZGFsLFxyXG4gICAgICB9fVxyXG4gICAgPlxyXG4gICAgICB7Y2hpbGRyZW59XHJcbiAgICA8L0NvaW5NYXJrZXRDb250ZXh0LlByb3ZpZGVyPlxyXG4gIClcclxufVxyXG4iXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiQ29pbk1hcmtldENvbnRleHQiLCJDb2luTWFya2V0UHJvdmlkZXIiLCJjaGlsZHJlbiIsImdldFRvcFRlbkNvaW5zIiwicmVzIiwiZmV0Y2giLCJkYXRhIiwianNvbiIsImUiLCJjb25zb2xlIiwibG9nIiwibWVzc2FnZSIsIlByb3ZpZGVyIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./context/context.js\n"));

/***/ }),

/***/ "./context/gunContext.js":
/*!*******************************!*\
  !*** ./context/gunContext.js ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GunContext\": function() { return /* binding */ GunContext; },\n/* harmony export */   \"GunProvider\": function() { return /* binding */ GunProvider; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var gun__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gun */ \"./node_modules/gun/browser.js\");\n/* harmony import */ var gun__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(gun__WEBPACK_IMPORTED_MODULE_2__);\n\nvar _s = $RefreshSig$();\n\n\nconst gun = gun__WEBPACK_IMPORTED_MODULE_2___default()([\n    \"https://discord-gun-node.herokuapp.com/gun\"\n]);\nconst GunContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)();\nconst initialState = {\n    messages: []\n};\nconst reducer = (state, action)=>{\n    try {\n        if (action.type == \"clear\") return {\n            messages: []\n        };\n        if (action.type == \"add\") {\n            return {\n                messages: [\n                    ...state.messages,\n                    action.data\n                ]\n            };\n        }\n    } catch (error) {\n        console.error(error);\n    }\n};\nconst GunProvider = (param)=>{\n    let { children  } = param;\n    _s();\n    const [state, dispatch] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useReducer)(reducer, initialState);\n    const getMessages = (_name)=>{\n        const messagesRef = gun.get(_name);\n        messagesRef.map().once((message)=>{\n            dispatch({\n                type: \"add\",\n                data: {\n                    sender: message.sender,\n                    content: message.content,\n                    avatar: message.avatar,\n                    createdAt: message.createdAt,\n                    messageId: message.messageId,\n                    isBullish: message.isBullish\n                }\n            });\n        });\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(GunContext.Provider, {\n        value: {\n            gun,\n            getMessages,\n            state\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"E:\\\\coinmart\\\\context\\\\gunContext.js\",\n        lineNumber: 43,\n        columnNumber: 5\n    }, undefined);\n};\n_s(GunProvider, \"6JWkGZ32UPfojeNx+xqn8ZU8A0Q=\");\n_c = GunProvider;\nvar _c;\n$RefreshReg$(_c, \"GunProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb250ZXh0L2d1bkNvbnRleHQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFpRDtBQUM1QjtBQUVyQixNQUFNRyxNQUFNRCwwQ0FBR0EsQ0FBQztJQUFDO0NBQTZDO0FBRXZELE1BQU1FLDJCQUFhSixvREFBYUEsR0FBRTtBQUV6QyxNQUFNSyxlQUFlO0lBQUVDLFVBQVUsRUFBRTtBQUFDO0FBRXBDLE1BQU1DLFVBQVUsQ0FBQ0MsT0FBT0MsU0FBVztJQUNqQyxJQUFJO1FBQ0YsSUFBSUEsT0FBT0MsSUFBSSxJQUFJLFNBQVMsT0FBTztZQUFFSixVQUFVLEVBQUU7UUFBQztRQUNsRCxJQUFJRyxPQUFPQyxJQUFJLElBQUksT0FBTztZQUN4QixPQUFPO2dCQUFFSixVQUFVO3VCQUFJRSxNQUFNRixRQUFRO29CQUFFRyxPQUFPRSxJQUFJO2lCQUFDO1lBQUM7UUFDdEQsQ0FBQztJQUNILEVBQUUsT0FBT0MsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUNBO0lBQ2hCO0FBQ0Y7QUFFTyxNQUFNRSxjQUFjLFNBQWtCO1FBQWpCLEVBQUVDLFNBQVEsRUFBRTs7SUFDdEMsTUFBTSxDQUFDUCxPQUFPUSxTQUFTLEdBQUdmLGlEQUFVQSxDQUFDTSxTQUFTRjtJQUU5QyxNQUFNWSxjQUFjQyxDQUFBQSxRQUFTO1FBQzNCLE1BQU1DLGNBQWNoQixJQUFJaUIsR0FBRyxDQUFDRjtRQUU1QkMsWUFBWUUsR0FBRyxHQUFHQyxJQUFJLENBQUNDLENBQUFBLFVBQVc7WUFDaENQLFNBQVM7Z0JBQ1BOLE1BQU07Z0JBQ05DLE1BQU07b0JBQ0phLFFBQVFELFFBQVFDLE1BQU07b0JBQ3RCQyxTQUFTRixRQUFRRSxPQUFPO29CQUN4QkMsUUFBUUgsUUFBUUcsTUFBTTtvQkFDdEJDLFdBQVdKLFFBQVFJLFNBQVM7b0JBQzVCQyxXQUFXTCxRQUFRSyxTQUFTO29CQUM1QkMsV0FBV04sUUFBUU0sU0FBUztnQkFDOUI7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxxQkFDRSw4REFBQ3pCLFdBQVcwQixRQUFRO1FBQ2xCQyxPQUFPO1lBQ0w1QjtZQUNBYztZQUNBVDtRQUNGO2tCQUVDTzs7Ozs7O0FBR1AsRUFBQztHQWhDWUQ7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29udGV4dC9ndW5Db250ZXh0LmpzP2QyMjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlUmVkdWNlciB9IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgR3VuIGZyb20gJ2d1bidcclxuXHJcbmNvbnN0IGd1biA9IEd1bihbJ2h0dHBzOi8vZGlzY29yZC1ndW4tbm9kZS5oZXJva3VhcHAuY29tL2d1biddKVxyXG5cclxuZXhwb3J0IGNvbnN0IEd1bkNvbnRleHQgPSBjcmVhdGVDb250ZXh0KClcclxuXHJcbmNvbnN0IGluaXRpYWxTdGF0ZSA9IHsgbWVzc2FnZXM6IFtdIH1cclxuXHJcbmNvbnN0IHJlZHVjZXIgPSAoc3RhdGUsIGFjdGlvbikgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBpZiAoYWN0aW9uLnR5cGUgPT0gJ2NsZWFyJykgcmV0dXJuIHsgbWVzc2FnZXM6IFtdIH1cclxuICAgIGlmIChhY3Rpb24udHlwZSA9PSAnYWRkJykge1xyXG4gICAgICByZXR1cm4geyBtZXNzYWdlczogWy4uLnN0YXRlLm1lc3NhZ2VzLCBhY3Rpb24uZGF0YV0gfVxyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IEd1blByb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xyXG4gIGNvbnN0IFtzdGF0ZSwgZGlzcGF0Y2hdID0gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsU3RhdGUpXHJcblxyXG4gIGNvbnN0IGdldE1lc3NhZ2VzID0gX25hbWUgPT4ge1xyXG4gICAgY29uc3QgbWVzc2FnZXNSZWYgPSBndW4uZ2V0KF9uYW1lKVxyXG5cclxuICAgIG1lc3NhZ2VzUmVmLm1hcCgpLm9uY2UobWVzc2FnZSA9PiB7XHJcbiAgICAgIGRpc3BhdGNoKHtcclxuICAgICAgICB0eXBlOiAnYWRkJyxcclxuICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICBzZW5kZXI6IG1lc3NhZ2Uuc2VuZGVyLFxyXG4gICAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50LFxyXG4gICAgICAgICAgYXZhdGFyOiBtZXNzYWdlLmF2YXRhcixcclxuICAgICAgICAgIGNyZWF0ZWRBdDogbWVzc2FnZS5jcmVhdGVkQXQsXHJcbiAgICAgICAgICBtZXNzYWdlSWQ6IG1lc3NhZ2UubWVzc2FnZUlkLFxyXG4gICAgICAgICAgaXNCdWxsaXNoOiBtZXNzYWdlLmlzQnVsbGlzaCxcclxuICAgICAgICB9LFxyXG4gICAgICB9KVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8R3VuQ29udGV4dC5Qcm92aWRlclxyXG4gICAgICB2YWx1ZT17e1xyXG4gICAgICAgIGd1bixcclxuICAgICAgICBnZXRNZXNzYWdlcyxcclxuICAgICAgICBzdGF0ZSxcclxuICAgICAgfX1cclxuICAgID5cclxuICAgICAge2NoaWxkcmVufVxyXG4gICAgPC9HdW5Db250ZXh0LlByb3ZpZGVyPlxyXG4gIClcclxufVxyXG4iXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsInVzZVJlZHVjZXIiLCJHdW4iLCJndW4iLCJHdW5Db250ZXh0IiwiaW5pdGlhbFN0YXRlIiwibWVzc2FnZXMiLCJyZWR1Y2VyIiwic3RhdGUiLCJhY3Rpb24iLCJ0eXBlIiwiZGF0YSIsImVycm9yIiwiY29uc29sZSIsIkd1blByb3ZpZGVyIiwiY2hpbGRyZW4iLCJkaXNwYXRjaCIsImdldE1lc3NhZ2VzIiwiX25hbWUiLCJtZXNzYWdlc1JlZiIsImdldCIsIm1hcCIsIm9uY2UiLCJtZXNzYWdlIiwic2VuZGVyIiwiY29udGVudCIsImF2YXRhciIsImNyZWF0ZWRBdCIsIm1lc3NhZ2VJZCIsImlzQnVsbGlzaCIsIlByb3ZpZGVyIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./context/gunContext.js\n"));

/***/ }),

/***/ "./pages/_app.js":
/*!***********************!*\
  !*** ./pages/_app.js ***!
  \***********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../styles/globals.css */ \"./styles/globals.css\");\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_styles_globals_css__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _index_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.css */ \"./pages/index.css\");\n/* harmony import */ var _index_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_index_css__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _context_gunContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../context/gunContext */ \"./context/gunContext.js\");\n/* harmony import */ var _context_context__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../context/context */ \"./context/context.js\");\n\n\n\n// import { MoralisProvider } from 'react-moralis'\n\n\n\nfunction MyApp(param) {\n    let { Component , pageProps  } = param;\n    return(// <MoralisProvider\n    //   serverUrl='https://vlrdcbhyo4dj.grandmoralis.com:2053/server'\n    //   appId='7B8Tc39fqOfOosQYksMjQsjqUuo57TALzP4Cz5RC'\n    // >\n    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_context_gunContext__WEBPACK_IMPORTED_MODULE_3__.GunProvider, {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_context_context__WEBPACK_IMPORTED_MODULE_4__.CoinMarketProvider, {\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Component, {\n                ...pageProps\n            }, void 0, false, {\n                fileName: \"E:\\\\coinmart\\\\pages\\\\_app.js\",\n                lineNumber: 16,\n                columnNumber: 11\n            }, this)\n        }, void 0, false, {\n            fileName: \"E:\\\\coinmart\\\\pages\\\\_app.js\",\n            lineNumber: 15,\n            columnNumber: 9\n        }, this)\n    }, void 0, false, {\n        fileName: \"E:\\\\coinmart\\\\pages\\\\_app.js\",\n        lineNumber: 14,\n        columnNumber: 7\n    }, this));\n}\n_c = MyApp;\n/* harmony default export */ __webpack_exports__[\"default\"] = (MyApp);\nvar _c;\n$RefreshReg$(_c, \"MyApp\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9fYXBwLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBOEI7QUFDVjtBQUNwQixrREFBa0Q7QUFDQztBQUNBO0FBQ0k7QUFFdkQsU0FBU0csTUFBTSxLQUF3QixFQUFFO1FBQTFCLEVBQUVDLFVBQVMsRUFBRUMsVUFBUyxFQUFFLEdBQXhCO0lBQ2IsT0FDRSxtQkFBbUI7SUFDbkIsa0VBQWtFO0lBQ2xFLHFEQUFxRDtJQUNyRCxJQUFJO2tCQUNGLDhEQUFDTCw0REFBV0E7a0JBQ1YsNEVBQUNFLGdFQUFrQkE7c0JBQ2pCLDRFQUFDRTtnQkFBVyxHQUFHQyxTQUFTOzs7Ozs7Ozs7Ozs7Ozs7O0FBS2xDO0tBYlNGO0FBZVQsK0RBQWVBLEtBQUtBLEVBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvX2FwcC5qcz9lMGFkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi4vc3R5bGVzL2dsb2JhbHMuY3NzJ1xyXG5pbXBvcnQgJy4vaW5kZXguY3NzJ1xyXG4vLyBpbXBvcnQgeyBNb3JhbGlzUHJvdmlkZXIgfSBmcm9tICdyZWFjdC1tb3JhbGlzJ1xyXG5pbXBvcnQgeyBHdW5Qcm92aWRlciB9IGZyb20gJy4uL2NvbnRleHQvZ3VuQ29udGV4dCdcclxuaW1wb3J0IHsgTmV4dFVJUHJvdmlkZXIgfSBmcm9tICdAbmV4dHVpLW9yZy9yZWFjdCc7XHJcbmltcG9ydCB7IENvaW5NYXJrZXRQcm92aWRlciB9IGZyb20gJy4uL2NvbnRleHQvY29udGV4dCdcclxuXHJcbmZ1bmN0aW9uIE15QXBwKHsgQ29tcG9uZW50LCBwYWdlUHJvcHMgfSkge1xyXG4gIHJldHVybiAoXHJcbiAgICAvLyA8TW9yYWxpc1Byb3ZpZGVyXHJcbiAgICAvLyAgIHNlcnZlclVybD0naHR0cHM6Ly92bHJkY2JoeW80ZGouZ3JhbmRtb3JhbGlzLmNvbToyMDUzL3NlcnZlcidcclxuICAgIC8vICAgYXBwSWQ9JzdCOFRjMzlmcU9mT29zUVlrc01qUXNqcVV1bzU3VEFMelA0Q3o1UkMnXHJcbiAgICAvLyA+XHJcbiAgICAgIDxHdW5Qcm92aWRlcj5cclxuICAgICAgICA8Q29pbk1hcmtldFByb3ZpZGVyPlxyXG4gICAgICAgICAgPENvbXBvbmVudCB7Li4ucGFnZVByb3BzfSAvPlxyXG4gICAgICAgIDwvQ29pbk1hcmtldFByb3ZpZGVyPlxyXG4gICAgICA8L0d1blByb3ZpZGVyPlxyXG4gICAgLy8gPC9Nb3JhbGlzUHJvdmlkZXI+XHJcbiAgKVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNeUFwcFxyXG4iXSwibmFtZXMiOlsiR3VuUHJvdmlkZXIiLCJOZXh0VUlQcm92aWRlciIsIkNvaW5NYXJrZXRQcm92aWRlciIsIk15QXBwIiwiQ29tcG9uZW50IiwicGFnZVByb3BzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pages/_app.js\n"));

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_MODULE_REFERENCE;\n\n{\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n}\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      // eslint-disable-next-line no-fallthrough\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if ( !fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n    return type;\n  }\n} // $FlowFixMe only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner$1.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement$1(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement$1(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object') {\n      return;\n    }\n\n    if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else if (node) {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement$1(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement$1(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement$1(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement$1(null);\n    }\n  }\n}\n\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n\nvar jsxDEV$1 =  jsxWithValidation ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV$1;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyw0Q0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsZUFBZTtBQUNoSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQSxxQ0FBcUM7O0FBRXJDLGdDQUFnQztBQUNoQztBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxlQUFlO0FBQzFCLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBLGtCQUFr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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUEsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZCxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/MTdlMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG4vLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cblxudmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlOyAvLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cblxudmFyIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0U7XG5cbntcbiAgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1vZHVsZS5yZWZlcmVuY2UnKTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgIC8vIHdpdGguXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoICFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnO1xuICAgIHJldHVybiB0eXBlO1xuICB9XG59IC8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cblxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAge1xuICAgIHRyeSB7XG4gICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4gIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXG4gIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cbiAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4gIC8vXG4gIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcbiAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG4gIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxuICAvL1xuICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4gIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cbiAgLy9cbiAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbiAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XG4gIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcbiAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xuICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG4gIC8vXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBzZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSksIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYodHlwZSwgY29uZmlnLCBtYXliZUtleSwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICB7XG4gICAgaWYgKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICB7XG4gICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gICAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSk7XG5cbiAgICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgICAgfVxuXG4gICAgICBlcnJvcignUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIHNvdXJjZSwgc2VsZik7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn0gLy8gVGhlc2UgdHdvIGZ1bmN0aW9ucyBleGlzdCB0byBzdGlsbCBnZXQgY2hpbGQgd2FybmluZ3MgaW4gZGV2XG5cbnZhciBqc3hERVYkMSA9ICBqc3hXaXRoVmFsaWRhdGlvbiA7XG5cbmV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuZXhwb3J0cy5qc3hERVYgPSBqc3hERVYkMTtcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"./node_modules/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSx1SkFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz81Nzc3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react/jsx-dev-runtime.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!"), __webpack_exec__("./node_modules/next/dist/client/router.js"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);